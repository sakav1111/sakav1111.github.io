---
title: SpringBoot - Auditing with Hibernate Envers & Spring Data JPA
date: 2023-01-16 00:00:00 Z
categories:
- SpringBoot
tags:
- SpringBoot
layout: article
cover: /assets/logo/springboot.png
sharing: true
license: false
aside:
  toc: true
pageview: true
---

In the context of ORM, database auditing means tracking and logging events related to persistent entities, or simply entity versioning. Inspired by SQL triggers, the events are insert, update, and delete operations on entities. The benefits of database auditing are analogous to those provided by source version control.

Here are the sample related entities, *Bar* and *Foo,* that we'll use in this example:

Hibernate Envers
----------------------------------------------------------------------------

With Hibernate, we can make use of *Interceptors* and *EventListeners,* as well as database triggers, to accomplish auditing. But the ORM framework offers Envers, a module implementing auditing and versioning of persistent classes.

### 1.Get Started With Envers

To set up Envers, we need to add the *hibernate-envers* JAR into our classpath:

```
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-envers</artifactId>
    <version>${hibernate.version}</version>
</dependency>
```

Then we add the *@Audited* annotation, either on an *@Entity* (to audit the whole entity) or on specific *@Column*s (if we need to audit specific properties only):

```
@Entity
@Audited
public class Bar { ... }
```

Note that *Bar* has a one-to-many relationship with *Foo*. In this case, we either need to audit *Foo* as well by adding *@Audited* on *Foo,* or set *@NotAudited* on the relationship's property in *Bar*:

```
@OneToMany(mappedBy = "bar")
@NotAudited
private Set<Foo> fooSet;
```

### 2. Creating Audit Log Tables

There are several ways to create audit tables:

-   set *hibernate.hbm2ddl.auto* to *create*,* create-drop,* or *update*, so Envers can create them automatically
-   use o*rg.hibernate.tool.EnversSchemaGenerator* to export the complete database schema programmatically
-   set up an Ant task to generate appropriate DDL statements
-   use a Maven plugin for generating a database schema from our mappings (such as Juplo) to export Envers schema (works with Hibernate 4 and higher)

We'll go the first route, as it's the most straightforward, but be aware that using *hibernate.hbm2ddl.auto* isn't safe in production.

In our case, the *bar_AUD* and *foo_AUD* (if we've set *Foo* as *@Audited* as well) tables should be generated automatically. The audit tables copy all audited fields from the entity's table with two fields, *REVTYPE *(values are: "0" for adding, "1" for updating, and "2" for removing an entity) and *REV*.

Besides these, an extra table named *REVINFO* will be generated by default. It includes two important fields, *REV* and *REVTSTMP,* and records the timestamp of every revision. As we can guess, *bar_AUD.REV* and *foo_AUD.REV* are actually foreign keys to *REVINFO.REV.*

### 3. Configuring Envers

We can configure Envers properties just like any other Hibernate property.

For example, let's change the audit table suffix (which defaults to "*_AUD*") to "*_AUDIT_LOG.*" Here's how we set the value of the corresponding property *org.hibernate.envers.audit_table_suffix*:

```
Properties hibernateProperties = new Properties();
hibernateProperties.setProperty(
  "org.hibernate.envers.audit_table_suffix", "_AUDIT_LOG");
sessionFactory.setHibernateProperties(hibernateProperties);
```

A full listing of available properties can be found [in the Envers documentation](http://docs.jboss.org/envers/docs/#configuration).

### 4. Accessing Entity History

We can query for historic data in a way similar to querying data via the Hibernate Criteria API.  We can access the audit history of an entity using the *AuditReader* interface, which we can obtain with an open *EntityManager* or *Session* via the *AuditReaderFactory*:

```
AuditReader reader = AuditReaderFactory.get(session);
```

Envers provides *AuditQueryCreator* (returned by *AuditReader.createQuery()*) in order to create audit-specific queries. The following line will return all *Bar* instances modified at revision #2 (where *bar_AUDIT_LOG.REV = 2*):

```
AuditQuery query = reader.createQuery()
  .forEntitiesAtRevision(Bar.class, 2)
```

Here's how we can query for *Bar*'s revisions. It'll result in getting a list of all audited *Bar* instances in all their states:

```
AuditQuery query = reader.createQuery()
  .forRevisionsOfEntity(Bar.class, true, true);
```

If the second parameter is false, the result is joined with the *REVINFO* table. Otherwise, only entity instances are returned. The last parameter specifies whether to return deleted *Bar* instances.

Then we can specify constraints using the *AuditEntity* factory class:

```
query.addOrder(AuditEntity.revisionNumber().desc());
```


