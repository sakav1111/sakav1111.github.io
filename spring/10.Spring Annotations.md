---
title: Spring- Spring Annotations
permalink: "/spring/spring-annotations"
key: spring-spring-annotations
categories:
- Spring
tags:
- Spring
---

Spring Annotations 
======================

## DI Related Annotations

*1.@Autowired*

We can use the *@Autowired* to **mark a dependency which Spring is going to
resolve and inject**. We can use this annotation with a constructor, setter, or
field injection.
```java
Field injection:
-------------------------------
class Car {
    @Autowired
    Engine engine;
}


Setter injection:
-------------------------------
class Car {
    Engine engine;
 
    @Autowired
    void setEngine(Engine engine) {
        this.engine = engine;
    }
}


Constructor injection:
-------------------------------
class Car {
    Engine engine;
 
    @Autowired
    Car(Engine engine) {
        this.engine = engine;
    }
}
```


**2. @Bean**

*@Bean* marks a factory method which instantiates a Spring bean:
```java
@Bean
Engine engine() {
    return new Engine();
}
```


**Spring calls these methods** when a new instance of the return type is
required.

The resulting bean has the same name as the factory method. If we want to name
it differently, we can do so with the *name* or the *value* arguments of this
annotation (the argument *value* is an alias for the argument *name*):
```java
@Bean("engine")
Engine getEngine() {
    return new Engine();
}
```
Note, that all methods annotated with *@Bean* must be
in *@Configuration* classes.



**3. @Qualifier**  
We use @Qualifier along with *@Autowired* to **provide the bean id or bean
name** we want to use in ambiguous situations.
```java
@Autowired
@Qualifier("bike")
void setVehicle(Vehicle vehicle) {
    this.vehicle = vehicle;
}
```


**4. @Required**

*@Required* on setter methods to mark dependencies that we want to populate
through XML:
```java
@Required
void setColor(String color) {
    this.color = color;
}

<bean class="com.baeldung.annotations.Bike">
    <property name="color" value="green" />
</bean
```
Otherwise, *BeanInitializationException* will be thrown.




**5. @Value**

We can use [@Value](https://www.baeldung.com/spring-value-annotation) for
injecting property values into beans. It  s compatible with constructor, setter,
and field injection.
```java
Field injection:
-----------------------------
@Value("8")
int cylinderCount

Setter injection:
-----------------------------
@Autowired
void setCylinderCount(@Value("8") int cylinderCount) {
    this.cylinderCount = cylinderCount;
}


Constructor injection:
-----------------------------
Engine(@Value("8") int cylinderCount) {
    this.cylinderCount = cylinderCount;
}
```



*6.@Scope*  
We use *@Scope* to define
the [scope](https://www.baeldung.com/spring-bean-scopes) of
a *@Component* class or a *@Bean* definition*. *It can be either *singleton,
prototype, request, session, globalSession* or some custom scope.
```java
@Component
@Scope("prototype")
class Engine {}
```

### Diffrence beween @Component & @Configuration

`@Component` and `@Configuration` are both annotations used in the Spring Framework, but they serve different purposes.

-   `@Component` is a generic stereotype annotation used to indicate that a class is a Spring component. Spring components are classes that are managed by the Spring container and can be automatically discovered and instantiated. Examples include `@Service`, `@Repository`, and `@Controller`, which are specializations of `@Component`. When Spring scans the classpath for components, it looks for classes annotated with `@Component` (or its specializations) and registers them as beans in the application context.

-   `@Configuration`, on the other hand, is a special type of component annotation used to define a configuration class in Spring. Configuration classes are used to define beans and their dependencies using `@Bean` methods. These `@Bean` methods are called at runtime to create and configure the beans, which are then registered in the application context. Configuration classes can also define other configuration-related elements, such as `@Import` annotations to import other configuration classes, and `@PropertySource` annotations to specify external property files.

In summary, `@Component` is a generic stereotype annotation used to mark a class as a Spring component, while `@Configuration` is a specialized annotation used to define configuration classes in Spring, which are used to configure the Spring application context.


### why that all methods annotated with @Bean must be in @Configuration classes.
In Spring Framework, `@Bean` is used to indicate that a method produces a bean to be managed by the Spring container. When you annotate a method with `@Bean`, Spring will register that method's return value as a bean within the application context.

The reason why methods annotated with `@Bean` must be in `@Configuration` classes is because `@Configuration` is used to declare one or more `@Bean` methods. A `@Configuration` class essentially serves as a blueprint for defining beans in the Spring application context. Without `@Configuration`, Spring won't recognize the `@Bean` annotations.

In other words, `@Configuration` is a meta-annotation that indicates that the class contains methods that define beans. It tells Spring to process the `@Bean` methods within that class and register the beans in the application context.
