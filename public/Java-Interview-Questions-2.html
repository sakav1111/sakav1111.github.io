<!DOCTYPE html><html lang="en">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>SatyaCodes - Java - Interview Questions PART-2</title>

<meta name="description" content="Strings1.What is immutable object? Can you write immutable object?Class –Final, Private Variables –Final, Public params Constructor, OnlygettersImmutable cla...">
<link rel="canonical" href="/Java-Interview-Questions-2.html"><link rel="alternate" type="application/rss+xml" title="SatyaCodes" href="/feed.xml"><!-- start favicons snippet, use https://realfavicongenerator.net/ --><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicons snippet -->
 <link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" >
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Java - Interview Questions PART-2 | SatyaCodes</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Java - Interview Questions PART-2" />
<meta name="author" content="Satya Kaveti" />
<meta property="og:locale" content="en" />
<meta name="description" content="Strings 1.What is immutable object? Can you write immutable object? Class –Final, Private Variables –Final, Public params Constructor, Only getters Immutable classes are Java classes whose objects cannot be modified once created. Declare the class as final so it can’t be extended. Make all fields private &amp; final so that direct access is not allowed &amp; it’s values can be assigned only once. Initialize all the fields via a constructor Write getters only, not setters. // An immutable class public final class Student { final String name; final int regNo; public Student(String name, int regNo) { this.name = name; this.regNo = regNo; } public String getName() { return name; } public int getRegNo() { return regNo; } } // Driver class class Test { public static void main(String args[]) { Student s = new Student(&quot;ABC&quot;, 101); System.out.println(s.name); System.out.println(s.regNo); // Uncommenting below line causes error // s.regNo = 102; Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: The final field Student.regNo cannot be assigned } } 2.What is Singleton? Can you write critical section code for singleton? A Singleton class is one which allows us to create only one object for JVM. Private Constructor, Private Object, Public Static Factory Method Rules: Create Singleton class Object make it as PRIVATE Create PRIVATE constructor Every Singleton class contains at least one factory method ```java class Student { private static Student st; private Student() { System.out.println(“OBJECET Created FIRST TIME”); } public static Student getObject() { if (st == null) { st = new Student(); } else { System.out.println(“OBJECET ALREDAY CREATED”); } return st; } } public class Singleton { public static void main(String[] args) { Student s1 = Student.getObject(); Student s2 = Student.getObject(); System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); } } In above code, it will create multiple instances of Singleton class if called by more than one thread parallel `Double checked locking of Singleton` is a way to ensure only one instance of Singleton class is created through application life cycle. This will bring us to **double checked locking pattern**, where only critical section of code is locked. Programmer call it double checked locking because **there are two checks** - **for \_instance == null, one without locking and** - **other with locking (inside synchronized) block.** Here is how double checked locking looks like in Java ```java public static Singleton getInstanceDC() { if (_instance == null) { // Single Checked synchronized (Singleton.class) { if (_instance == null) { // Double checked _instance = new Singleton(); } } } return _instance; } For Cloning – we need to Ovveride clone() method &amp; Should throw CloneNotSupportException For Reflection - we need to throw RuntimeException(unchekd) in private Constructor Clone() will create new Object of Singleton Class? Cloning is a concept to create duplicate objects. Using clone we can create copy of object. Suppose, we ceate clone of a singleton object, then it wil create a copy that is there are two instances of a singleton class, hence the class is no more singleton. public static void main(String args[]) throws CloneNotSupportedException { Student s1 = Student.getObject(); Student s2 = Student.getObject(); Student s3 = (Student) s1.clone(); System.out.println(s1); System.out.println(s1); System.out.println(s3); } Student@15db9742 Student@15db9742 Student@6d06d69c // Creates new Object, our singleton failed. To overcome this, we should override clone() method, it should throw Exception, anyone tries to do clone class Student implements Cloneable{ ………. @Override protected Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(); } public static void main(String args[]) throws CloneNotSupportedException { Student s1 = Student.getObject(); Student s2 = Student.getObject(); Student s3 = (Student) s1.clone(); System.out.println(s1); System.out.println(s1); System.out.println(s3); } } Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException //We are GOOD now at Student.clone(Student.java:25) at Student.main(Student.java:33) Reflection: You can make the new instance of the Singleton class by changing the constructor visibility as public in run-time and create new instance using that constructor . public static void main(String args[]) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { Student s1 = Student.getObject(); Student s2 = null; //1.Making Construtor visible Constructor&lt;Student&gt;[] constructors = (Constructor&lt;Student&gt;[]) Student.class.getDeclaredConstructors(); for (Constructor constructor : constructors) { // Below code will destroy the singleton pattern constructor.setAccessible(true); s2 = (Student) constructor.newInstance(); } System.out.println(s1); System.out.println(s2); //Using Class of newInstance() Class c = Student.class; Student s1 = Student.getObject(); Student s2 = (Student) c.newInstance(); System.out.println(s1); // Student@15db9742 System.out.println(s2); // Student@6d06d69c -Failed again  } Student@15db9742 Student@6d06d69c //Failed again  To prevent Singleton failure while due to reflection you have to throw a run-time exception in constructor, if the constructor is already initialized . class Student implements Cloneable{ private static Student st; private Student() { if(st!=null) throw new RuntimeException(&quot;Go Fucker.....&quot;); } Exception in thread &quot;main&quot; java.lang.RuntimeException: Go Fucker..... at Student.&lt;init&gt;(Student.java:15) at sun.reflect.NativeConstructorAccessor How do you reverse a String in Java without using StringBuffer? The Java library provides String Buffer and StringBuilder class with reverse() method, which can be used to reverse String in Java. String reverse = &quot;&quot;; String source= &quot;My Name is Khan&quot;; for(int i = source.length() -1; i&gt;=0; i--){ reverse = reverse + source.charAt(i); } How to Print duplicate characters from String? public class RepreatedChar { public static void main(String[] args) { String a = &quot;success&quot;; // 1.convert into char array char[] c = a.toCharArray(); // 2.create Hashmap store key as character, count as value HashMap map = new HashMap&lt;&gt;(); for (char ch : c) { // 3.Check if Map contains given Char as &lt;key&gt; or not if (map.containsKey(ch)) { // if their, get the value &amp; increment it int i = (int) map.get(ch); i++; // add updated value to it map.put(ch, i); } else { // if not their , add key &amp; value as 1 map.put(ch, 1); } } Set set = map.entrySet(); Iterator iterator = set.iterator() ; while (iterator.hasNext()) { Map.Entry entry = (Entry) iterator.next(); System.out.println(entry.getKey()+&quot; : &quot;+entry.getValue()); } } } s : 3 c : 2 u : 1 e : 1 Reverse String in Java Get String length Iterate by using charAt() in reverse &amp; append to new String ```java public class ReverseString { public static void main(String[] args) { String s = “satyam”; String rev=””; int len = s.length(); for(int i=(len-1);i&gt;=0;i–){ rev = rev+s.charAt(i); } System.out.println(rev); } } ``` Is String contains Number or not public class RegEx { public static void main(String[] args) { // Regular expression in Java to check if String is number or not Pattern pattern = Pattern.compile(&quot;.*[^0-9].*&quot;); String[] inputs = { &quot;123&quot;, &quot;-123&quot;, &quot;123.12&quot;, &quot;abcd123&quot; }; /* Matches m = pattern.match(input); * boolean ch = m.match(); */ for (String input : inputs) { System.out.println(&quot;does &quot; + input + &quot; is number : &quot; + !pattern.matcher(input).matches()); } // Regular expression in java to check if String is 6 digit number or not String[] numbers = { &quot;123&quot;, &quot;1234&quot;, &quot;123.12&quot;, &quot;abcd123&quot;, &quot;123456&quot; }; Pattern digitPattern = Pattern.compile(&quot;\\d{6}&quot;); // Pattern digitPattern = Pattern.compile(&quot;\\d\\d\\d\\d\\d\\d&quot;); for (String number : numbers) { System.out.println(&quot;does &quot; + number + &quot; is 6 digit number : &quot; + digitPattern.matcher(number).matches()); } } } Java StringTokenizer With Multiple De-limiters? The java.util.StringTokenizer class allows an application to break a string into tokens. StringTokenizer(String str) This constructor a string tokenizer for the specified string. StringTokenizer(String str, String delim) This constructor constructs string tokenizer for the specified string. The 6 useful methods of StringTokenizer class are as follows: Public method Description boolean hasMoreTokens() checks if there is more tokens available. String nextToken() returns the next token from the StringTokenizer object. String nextToken(String delim) returns the next token based on the delimeter. boolean hasMoreElements() same as hasMoreTokens() method. Object nextElement() same as nextToken() but its return type is Object. int countTokens() returns the total number of tokens. Normal Example public class Simple{ public static void main(String args[]){ StringTokenizer st = new StringTokenizer(&quot;my name is khan&quot;,&quot; &quot;); //space while (st.hasMoreTokens()) { System.out.println(st.nextToken()); } } } ============================== Output:my name is khan Java StringTokenizer with Multiple De-limiters for this we have to specify the Delimiters , separated by //. for Example StringTokenizer tokenizer = new StringTokenizer(s, &quot;// //!//,//?//.//_//&#39;//@)&quot;); public class Singleton { public static void main(String[] args) { String s = &quot;He is a very very good boy, isn&#39;t he?&quot;; StringTokenizer tokenizer = new StringTokenizer(s, &quot;// //!//,//?//.//_//&#39;//@)&quot;); System.out.println(tokenizer.countTokens()); while (tokenizer.hasMoreTokens()) { System.out.println(tokenizer.nextToken()); } } } ==================== 10 He is a very very good boy isn t he Reverse Words in a String public class RevWords { public static void main(String[] args) { // using s.split(&quot;\\s&quot;); String s = &quot;My name is Satya&quot;; String words[] = s.split(&quot;\\s&quot;); String rev = &quot;&quot;; int len = words.length; for (int i = (len - 1); i &gt;= 0; i--) { rev = rev + words[i]; } System.out.println(rev); // using Collections.reverse(str) List&lt;String&gt; word = Arrays.asList(s.split(&quot;\\s&quot;)); Collections.reverse(word); System.out.println(word); } } Using String Tokenizer public class Test { public static void main(String args[]) { System.out.println(&quot;Using Constructor 1 -By Space &quot;); StringTokenizer st1 = new StringTokenizer(&quot;Hello Geeks How are you&quot;, &quot; &quot;); System.out.println(&quot;Get TokensCount in case of revers: &quot;+st1.countTokens()); while (st1.hasMoreTokens()) System.out.println(st1.nextToken()); System.out.println(&quot;Using Constructor 2 - By Given Symol&quot;); StringTokenizer st2 = new StringTokenizer(&quot;JAVA : Code : String&quot;, &quot; :&quot;); while (st2.hasMoreTokens()) System.out.println(st2.nextToken()); System.out.println(&quot;Using Constructor 3 - Using Flag&quot;); /* * If the flag is false, delimiter characters serve to separate tokens. For * example, if string is &quot;hello geeks&quot; and delimiter is &quot; &quot;, then tokens are * &quot;hello&quot; and &quot;geeks&quot;. * * If the flag is true, delimiter characters are considered to be tokens. For * example, if string is &quot;hello geeks&quot; and delimiter is &quot; * &quot;, then tokens are &quot;hello&quot;, &quot; &quot; and &quot;geeks&quot;. */ StringTokenizer st3 = new StringTokenizer(&quot;JAVA : Code : String&quot;, &quot; :&quot;, true); while (st3.hasMoreTokens()) System.out.println(st3.nextToken()); } } What does the intern() method of String class do? (answer) The intern() method of String class put the String on which it has called into String pool e.g.** str.intern() **will put the String str into the pool. Once the String is the pool it can be reused and improve performance. public class Demo { public static void main(String[] args) { String s = new String(&quot;Satya&quot;); String intern = s.intern(); System.out.println(intern); } } Output --------- Satya How to convert String to Date in Java? (answer) Prior to Java 8, you can use DateFormat or SimpleDateFormat class to convert a String to Date In Java or vice-versa. From Java 8 onwards, when you use the new Date and Time API, you can also use the DateTimeFormatter class to convert String to LocalDate, LocalTime, or LocalDateTime class in Java. String string = &quot;February 6, 2014&quot;; date = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(string); Formatted output in Java Sometimes we need to print the output in a given specified format. For doing that we have printf() method. printf() can take multiple arguments, but System.out.print() and System.out.println() take a single argument. public class Demo { public static void main(String[] args) { int x = 100; System.out.printf(&quot;Printing simple integer: x = %d\n&quot;, x); // this will print it upto 2 decimal places System.out.printf(&quot;Formatted with precison: PI = %.2f\n&quot;, Math.PI); float n = 5.2f; // automatically appends zero to the rightmost part of decimal System.out.printf(&quot;Formatted to specific width: n = %.4f\n&quot;, n); n = 2324435.3f; // here number is formatted from right margin and occupies a width of 20 characters System.out.printf(&quot;Formatted to right margin: n = %20.4f\n&quot;, n); } } Printing simple integer: x = 100 Formatted with precison: PI = 3.14 Formatted to specific width: n = 5.2000 Formatted to right margin: n = 2324435.2500 We have The java.lang.String.format(String format, Object... args) method returns a formatted string using the specified format string and arguments. public class Demo { public static void main(String[] args) { double pi = Math.PI; // returns a formatted string using the specified format string, and arguments System.out.format(&quot;%f\n&quot;, pi); float f = 246.83278387f; String s = String.format(&quot;%.2f\n&quot;,f); System.out.println(s); } } 3.141593 246.83 Difference between format() and printf() method in Java? (answer) Even though both methods can be used to format String and they have same rules the key difference is that format() method returns a formatted String printf() method print formatted String to console. So, if you need a formatted String, use format method and if you want to print, then use the printf() method. How do you append leading zero to a numeric String? (answer) You can use the format() method of String to append leading zeros to a numeric String in Java. String str = String.format(&quot;%04d&quot;, 9); // 0009 System.out.printf(&quot;original number %d, numeric string with padding : %s&quot;, 9, str); original number 9, numeric string with padding : 0009 we can also use DecimalFormat class with passing format DecimalFormat df = new DecimalFormat(&quot;0000&quot;); String a = df.format(9); // 0009 String b = df.format(99); // 0099 String c = df.format(999); // 0999 System.out.println(&quot;\n&quot;+a+&quot; \n&quot;+b+&quot; \n&quot;+c+&quot; \n&quot;); 0009 0099 0999 Enum Enumeration in Java is supported by keyword enum. enums are a special type of class that always extends java.lang.Enum.enums are Compile time Constants, because they are -public static final Logically, each enum is an instance of enum type itself. So given enum can be seen as below declaration. JVM internally adds ordinal and value methods to this class which we can call while working with enum. public enum Direction { EAST, WEST, NORTH, SOUTH; } final class Direction extends Enum&lt;Direction&gt; { public final static Direction EAST = new Direction(); public final static Direction WEST = new Direction(); public final static Direction NORTH = new Direction(); public final static Direction SOUTH = new Direction(); } The ordinal() method returns the order of an enum instance. It represents the sequence in the enum declaration, where the initial constant is assigned an ordinal of &#39;0&#39;. It is very much like array indexes. Direction.EAST.ordinal(); //0 Direction.NORTH.ordinal(); //2 The enum values() method returns all the enum values in an enum array. Direction[] directions = Direction.values(); By default, enums don’t require constructor definitions and their default values are always the string used in the declaration. you can give define your own values by constructors to initialize. public enum Direction { // enum fields EAST(0), WEST(180), NORTH(90), SOUTH(270); // internal state private int angle; // constructor private Direction(final int angle) { this.angle = angle; } public int getAngle() { return angle; } Public Static void Main(){ Direction north = Direction.NORTH; System.out.println( north ); //NORTH System.out.println( north.getAngle() ); //90 System.out.println( Direction.NORTH.getAngle() ); //90 } } Remember that enum is basically a special class type, and it can have methods and fields just like any other class. You can add methods which are abstract as well as concrete methods as well. Both methods are allowed in enum. Two classes have been added to java.util package in support of enums – EnumSet and EnumMap public class Test { public static void main(String[] args) { Set enumSet = EnumSet.of( Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH ); Map enumMap = new EnumMap(Direction.class); //Populate the Map enumMap.put(Direction.EAST, Direction.EAST.getAngle()); enumMap.put(Direction.WEST, Direction.WEST.getAngle()); enumMap.put(Direction.NORTH, Direction.NORTH.getAngle()); enumMap.put(Direction.SOUTH, Direction.SOUTH.getAngle()); } } 1) Can Enum implement interface in Java? Yes, Enum can implement interface in Java. Since enum is a type, similar to class and interface, it can implement interface. This gives a lot of flexibility to use Enum as specialized implementation in some cases Can Enum extends class in Java? No, Enum can not extend class in Java. Because all Enum by default extend abstract base class java.lang.Enum, obviously they cannot extend another class, because Java doesn’t support multiple inheritance for classes. Because of extending java.lang.Enum class, all enum gets methods like ordinal(), values() or valueOf(). Can we create instance of Enum outside of Enum itself? If Not, Why? No, you cannot create enum instances outside of Enum boundary, because Enum doesn’t have any **public constructor, and compiler doesn’t allow you to provide any public constructor in Enum. But we can write private/protected Constructor.** Since compiler generates lot of code in response to enum type declaration, it doesn’t allow public constructors inside Enum, which enforces declaring enum instances inside Enum itself. Can we declare Constructor inside Enum in Java? Yes, you can, but remember you can only declare either private or package-private constructor inside enum. public and protected constructors are not permitted inside enum. See here for a code example. Exception Handling 1.Checked Exceptions: They Checked by Compiler, the given resource is existed or not, They are usually occur interacting with outside resources/ network resources e.g. database problems, network connection errors, missing files etc. Java forces you to handle these error scenarios in some manner in your application code 2.Unchecked Exceptions: occurrences of which are not checked by the compiler like coding, initialization, Primitive data errors. They usually result of bad code in your system. 3.Error : JVM +Memory+ OS level issues . OutofMemory, StatckOverFlow What will happen if you put System.exit(0) on try or catch block? In normal Finally block will always execute. The only case finally block is not executed is System.exit(0). In advanced case it will execute in following case. By Calling System.exit(0) in try or catch block, its stops execution &amp; throws SecurityException few times only. If System.exit(0) NOT throws security exception, then finally block Won’t be executed ```java public class Demo { public static void main(String[] args) { try { System.out.println(“try”); System.exit(0); }catch (Exception e) { System.out.println(“catch”); } finally { System.out.println(“finally”); } } } try - (Security Exception not thrown) - But, if **System.exit(0) throws security exception then finally block will be executed**. **java.lang.System.exit()** will terminates the currently executing program by JVM. - **exit(0)** : Generally used to indicate successful termination. - **exit(1) or exit(-1) or any other non-zero value** –indicates unsuccessful termination. ## What happens if we put return statement on try/catch? Will finally block execute? Yes, finally block will execute even if you put a return statement in the try block or catch block. ```java try { //try block ... return success; } catch (Exception ex) { //catch block ..... return failure; } finally { System.out.println(&quot;Inside finally&quot;); } The answer is yes. finally block will execute. The only case where it will not execute is when it encounters System.exit(). What happens when a finally block has a return statement? Finally block overrides the value returned by try and catch blocks. public static int myTestingFuncn(){ try{ .... return 5; } finally { .... return 19; } } This program would return value 19 since the value returned by try has been overridden by finally. Remember, if a method return any thing in try, we must place return in catch as well. public class Test { public int number() { try { int c = 10 / 0; return 100; } catch (Exception e) { return 200; } finally { return 300; } } public static void main(String args[]) { System.out.println(new Test().number()); } } 0/p: 300 Why do you think Checked Exception exists in Java, since we can also convey error using RuntimeException? Most of checked exceptions are in java.io package, which make sense because if you request any system resource and its not available, than a robust program must be able to handle that situation gracefully. By declaring IOException as checked Exception, Java ensures that yours provide that gracefully exception handling. Another possible reason could be to ensuring that system resources like file descriptors, which are limited in numbers, should be released as soon as you are done with that using catch or finally block Have you faced OutOfMemoryError in Java? How did you solved that? OutOfMemoryError in Java is a subclass of java.lang.VirtualMachineError and JVM throws java.lang.OutOfMemoryError when it ran out of memory in the heap. An easy way to solve OutOfMemoryError in java is to increase the maximum heap size by using JVM options “-Xmx512M”, this will immediately solve your OutOfMemoryError. java –Xmx512m myprogram -Xms512m -Xmx1152m -XX:MaxPermSize=256m -XX:MaxNewSize=256m I/O Streams 1.ByteStreams(1 byte at a time) : read image, audio, video etc FileOutputStream outputStream = new FileOutputStream(&quot;c:\a.txt&quot;); for (int i = 0; i &lt; 10; i++) { outputStream.write(i); } FileInputStream inputStream = new FileInputStream(&quot;c:\a.txt&quot;); int i; while ((i = inputStream.read()) != -1) { System.out.println(&quot;I : &quot; + i); } 2.CharacterStreams(2 Bytes at a time) : Character file data char[] ch ={ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; }; FileWriter w = new FileWriter(filepath); w.write(ch); w.close(); FileReader r = new FileReader(filepath); int i; while ((i = r.read()) != -1) { System.out.println(i + &quot;:&quot; + (char) i); } 3.Buffered Streams(1024 bytes at a time): Rather than read one byte at a time, it reads a larger block at a time into an internal buffer // 1.Create Stream Object FileOutputStream fos = new FileOutputStream(filepath); // 2.pass Stream object to BufferStream constructor BufferedOutputStream bos = new BufferedOutputStream(fos); String s = &quot;SmlCodes.com -Programmimg Simplified&quot;; byte[] b = s.getBytes(); bos.write(b); bos.flush(); // 1.Create Stream Object FileInputStream fis = new FileInputStream(filepath); // 2.pass Stream object to BufferStream constructor BufferedInputStream bis = new BufferedInputStream(fis); int i; while((i=bis.read())!=-1){ System.out.println((char)i); } 4.Data streams: above we have only Char &amp; Byte types. I/O of primitive data type values (int, long, float, and double) DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;sml.bin&quot;)); dos.writeInt(10); dos.writeUTF(&quot;Satya&quot;); DataInputStream dis = new DataInputStream(new FileInputStream(&quot;sml.bin&quot;)); System.out.println(&quot;Int : &quot; + dis.readInt()); System.out.println(&quot;String : &quot; + dis.readUTF()); 5.Object Streams : object streams support I/O of objects. Serialization. • Choose the appropriate class name whose object is participating in serialization. • This class must implement java.io.Serializable interface class Student implements Serializable { // Exception in thread &quot;main&quot; java.io.NotSerializableException: io.Student private int sno; private String name; private String addr; } public class Serialization { public static void main(String[] args) throws Exception { Student student = new Student(); student.setSno(101); student.setName(&quot;Satya Kaveti&quot;); student.setAddr(&quot;VIJAYAWADA&quot;); FileOutputStream fos = new FileOutputStream(&quot;student.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(student); FileInputStream fis = new FileInputStream(&quot;student.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student st = (Student)ois.readObject(); System.out.println(st.getSno()); System.out.println(st.getName()); System.out.println(st.getAddr()); } } Can a Serializable class contain a non-serializable field in Java? (answer) Yes, but you need to make it either static or transient. A static variable cannot be serialized. Static variables belong to a class and not to any individual instance. The concept of serialization is concerned with the object’s current state. Only data associated with a specific instance of a class is serialized, therefore static member fields are ignored during serialization class Student implements Serializable { // Exception in thread &quot;main&quot; java.io.NotSerializableException: io.Student private int sno; private static String name; //Setters &amp; Getters } public class Demo { public static void main(String[] args) throws Exception { Student student = new Student(); student.setSno(101); student.setName(&quot;Satya Kaveti&quot;); FileOutputStream fos = new FileOutputStream(&quot;student.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(student); FileInputStream fis = new FileInputStream(&quot;student.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student st = (Student)ois.readObject(); System.out.println(st.getSno()); System.out.println(st.getName()); } } 101 Satya Kaveti (Static serliaze ?) //Confused? Let’s stop the program, and remove writing part &amp; re-run it! public class Demo { public static void main(String[] args) throws Exception { FileInputStream fis = new FileInputStream(&quot;student.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student st = (Student)ois.readObject(); System.out.println(st.getSno()); System.out.println(st.getName()); } } 101 null This clearly indicates that static variable is not stored in the file, but the value of the static variable that is currently loaded into memory is being picked up, when you use st.getName()); Threads What happens if we starts same Thread(ob) Twice? public class ThreadDemo extends Thread { @Override public void run() { System.out.println(&quot;Iam Running&quot;); } public static void main(String[] args) { ThreadDemo ob = new ThreadDemo(); ob.start(); ob.start(); } } Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException at java.lang.Thread.start(Thread.java:705) at threads.ThreadDemo.main(ThreadDemo.java:11) Iam Running What guarantee volatile variable provides? volatile provides the guarantee, changes made in one thread is visible to others. What is busy spin? We have T1, T2, T3 tasks which are executed by the threads t1,t2,t3. But T2, T3 Should execute after T1 completes its execution. for that they must communicate via signaling. We can achieve this singling process in following ways 1.Busy Wait 1. here we have FLAG variable which in initialized to NO. t2, t3 threads will check for FLAG = Yes or not for every 30 seconds via loop, util FLAG = yes. This is called Busy Spin / Busy wait. 2.After some time, t1 changes status to YES, so that t2, t3 can proceed its execution. Busy spinning or busy wait in a multi-threaded environment is a technique where other threads loop continuously waiting for a thread to complete its task and signal them to start. while(spinningFlag){ System.out.println(&quot;Waiting busy spinning&quot;); } import org.omg.Messaging.SyncScopeHelper; public class BusySpin { private static boolean flag =false; public synchronized boolean checkFlag() { return flag; } public synchronized boolean changeFlag() { flag=true; return flag; } public static void main(String[] args) throws Exception { BusySpin ob = new BusySpin(); Thread t1 = new Thread() { @Override public void run() { System.out.println(&quot;T1 Running&quot;); try { Thread.sleep(5000); System.out.println(&quot;============ SET FLAG TRUE===&quot;); ob.changeFlag(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }; t1.start(); Thread t2 = new Thread() { @Override public void run() { System.out.println(&quot;T2 Checking ........&quot;); while (ob.checkFlag()) { System.out.println(&quot;T2 Running.....&quot;); } try { wait(300); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }; t2.start(); Thread t3 = new Thread() { @Override public void run() { System.out.println(&quot;T3 Checking ........&quot;); while (ob.checkFlag()) { System.out.println(&quot;T3 Running.....&quot;); } try { wait(300); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }; t3.start(); } } What is race condition in Java? Given one example? (answer) -Race condition occurs when two or more threads try to read &amp; write a shared variable at the same time” Because the thread scheduling algorithm can swap between threads at any time, you don’t know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are “racing” to access/change the data. class Counter implements Runnable { private int count; @Override public void run() { for (int i = 1; i &lt;= 100; i++) { try { Thread.sleep(100); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } count++; } } public int getCount() { return this.count; } } public class RaceCondition{ public static void main(String[] args) throws InterruptedException { Counter c = new Counter(); Thread t1 = new Thread(c); t1.start(); Thread t2 = new Thread(c); t2.start(); // wait for threads to finish processing t1.join(); t2.join(); System.out.println(&quot;Excepting =200, Actual is =&quot; + c.getCount()); } } Excepting =200, Actual is =141 -1st Run Excepting =200, Actual is =157 -2nd Run What is Thread Dump? How do you take thread dump in Java? Process has multiple Threads. Thread dump is a summary of the state of all threads of the process ‘jstack’ is an effective command line tool to capture thread dumps Java VisualVM is a GUI tool that provides detailed information about the applications Why Swing is not thread-safe in Java? Since GUI screens are mostly updated in response of user action e.g. when user click a button, and since events are handled in the same Event dispatcher thread, it’s easy to update GUI on that thread. What is a ThreadLocal variable in Java? Thread-local variables are variables restricted to a thread, it’s like thread’s own copy which is not shared between multiple threads. Java provides a ThreadLocal class to support thread-local variables, It extends Object class. Basically it is an another way to achieve thread safety apart from writing immutable classes. Since Object is no more shared there is no requirement of Synchronization which can improve scalability and performance of application. ThreadLocal provides thread restriction which is extension of local variable. ThreadLocal are visible only in single thread. No two thread can see each other’s thread local variable. These variable are generally private static field in classes and maintain its state inside thread. void set(Object value), Object get(), void remove() methods are available public class ThreadLocalExample { public static class MyRunnable implements Runnable { private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;(); public void run() { threadLocal.set((int) (Math.random() * 100D)); System.out.println(threadLocal.get()); } } public static void main(String[] args) throws InterruptedException { MyRunnable sharedRunnableInstance = new MyRunnable(); Thread thread1 = new Thread(sharedRunnableInstance); Thread thread2 = new Thread(sharedRunnableInstance); thread1.start(); thread2.start(); thread1.join(); // wait for thread 1 to terminate thread2.join(); // wait for thread 2 to terminate } } ----------- 36 16 This example This example creates a single MyRunnable instance which is passed to two different threads. Both threads execute the run() method, and thus sets different values on the ThreadLocal instance. If the access to the set() call had been synchronized, and it had not been a ThreadLocal object, the second thread would have overridden the value set by the first thread Write code for thread-safe Singleton in Java? When we say thread-safe, which means Singleton should remain singleton even if initialization occurs in the case of multiple threads. public class DoubleCheckedLockingSingleton { private volatile DoubleCheckedLockingSingleton INSTANCE; private DoubleCheckedLockingSingleton() { } public DoubleCheckedLockingSingleton getInstance(){ if(INSTANCE == null){ synchronized(DoubleCheckedLockingSingleton.class){ //double checking Singleton instance if(INSTANCE == null){ INSTANCE = new DoubleCheckedLockingSingleton(); } } } return INSTANCE; } } When to use Runnable vs Thread in Java? (Think Inheritance) it’s better to implement Runnable then extends Thread if you also want to extend another class Difference between Runnable and Callable in Java? Callable was added on JDK 1.5. Main difference between these two is that Callable’s call() method can return value and throw Exception, which was not possible with Runnable’s run() method. Callable return Future object, which can hold the result of computation. class SumTask implements Callable&lt;Integer&gt; { private int num = 0; public SumTask(int num){ this.num = num; } @Override public Integer call() throws Exception { int result = 0; for(int i=1;i&lt;=num;i++){ result+=i; } return result; } } public class CallableDemo { public static void main(String[] args) throws Exception { ExecutorService service = Executors.newSingleThreadExecutor(); SumTask sumTask = new SumTask(20); Future&lt;Integer&gt; future = service.submit(sumTask); Integer result = future.get(); System.out.println(result); } } How to stop a thread in Java? There was some control methods in JDK 1.0 e.g. stop(), suspend() and resume() which are deprecated. We can do it in Two ways 1.Using interrupt() public class Demo { public static void main(String[] args) throws Exception { Runnable runnable = ()-&gt;{ System.out.println(&quot;Running...&quot;); try { Thread.sleep(5000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(&quot;I have Completed ...&quot;); }; Thread t1 = new Thread(runnable); t1.start(); t1.interrupt(); } } Running... I have Completed ... java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at Demo.lambda$0(Demo.java:16) at java.lang.Thread.run(Thread.java:748) In this case we can only stop Sleeping thread. 2.volatile boolean variable In this case we need to use volatile boolean variable, &amp; we need to change value to TRUE if we want to stop a thread. I have a server; I need it to Stop class Server implements Runnable { private volatile boolean stop = false; public void run() { while (!stop) { System.out.println(&quot;Server is running.....&quot;); } System.out.println(&quot;Server is stopped....&quot;); } public void stop() { stop = true; } } public class Demo { public static void main(String[] args) throws Exception { Server myServer = new Server(); Thread t1 = new Thread(myServer, &quot;T1&quot;); t1.start(); // Now, let&#39;s stop our Server thread System.out.println(Thread.currentThread().getName() + &quot; is stopping Server thread&quot;); TimeUnit.MILLISECONDS.sleep(8); myServer.stop(); // Let&#39;s wait to see server thread stopped System.out.println(Thread.currentThread().getName() + &quot; is finished now&quot;); } } Actually we are not stoping the Thread, we just coming out of the run(). Why wait, notify and notifyAll are not inside thread class? Java provides lock at object level not at thread level. Every object has lock, which is acquired by thread. Now if thread needs to wait for certain lock it make sense to call wait() on that object rather than on that thread. Had wait() method declared on Thread class, it was not clear that for which lock thread was waiting. In short, since wait, notify and notifyAll operate at lock level, it make sense to defined it on object class because lock belongs to object. What is the difference between Deadlock, Starvation, and Livelock? Deadlock: is a situation where two more threads are blocked because of waiting for each other forever.one of the possible situation is nested Synchronized blocks. To create simple deadlock situation for a servlet, just place doPost() method inside doGet() and doGet()method inside doPost(). public class Business { private Object lock1 = new Object(); private Object lock2 = new Object(); public void foo() { synchronized (lock1) { synchronized (lock2) { System.out.println(&quot;foo&quot;); } } } public void bar() { synchronized (lock2) { synchronized (lock1) { System.out.println(&quot;bar&quot;); } } } public static void main(String[] args) { Business business = new Business(); Thread t1 = new Thread(new Runnable() { public void run() { business.foo(); } }); t1.start(); Thread t2 = new Thread(new Runnable() { public void run() { business.bar(); } }); t2.start(); } } how to avoid deadlock Avoid acquiring more than one lock at a time. If not, make sure that you acquire multiple locks in consistent order. In the above example, you can avoid deadlock by synchronize two locks in the same order in both methods. public void foo() { synchronized (lock1) { synchronized (lock2) { System.out.println(&quot;foo&quot;); } } } public void bar() { synchronized (lock1) { synchronized (lock2) { System.out.println(&quot;bar&quot;); } } } 2.LiveLock :A real-world example of livelock occurs when two people meet in a narrow corridor (తాడిమట్ట), and each tries to be polite by moving aside to let the other pass, but they end up swaying from side to side without making any progress because they both repeatedly move the same way at the same time. Livelock occurs when two or more processes continually repeat the same interaction in response to changes in the other processes without doing any useful work. These processes are not in the waiting state, and they are running concurrently. This is different from a deadlock because in a deadlock all processes are in the waiting state. public class Test { boolean selected=false; public boolean isSelected() { return selected; } public void setSelected(boolean selected) { this.selected = selected; } public static void main(String args[]) { Test itemOne = new Test(); Test itemTwo = new Test(); Thread tOne = new Thread(new Runnable() { @Override public void run() { while(!itemOne.isSelected()) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } itemTwo.setSelected(true); } }); Thread tTwo = new Thread(new Runnable() { @Override public void run() { while(!itemTwo.isSelected()) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } itemOne.setSelected(true); } }); tOne.start(); tTwo.start(); } } 3. Starvation: describes a situation where a thread holds a resource for a long time so other threads are blocked forever. The blocked threads are waiting to acquire the resource but they never get a chance. Thus they starve to death.BTW, Starvation means suffering or death caused by lack of food. Starvation can occur due to the following reasons: - Threads are blocked infinitely because a thread takes long time to execute some synchronized code (e.g. heavy I/O operations or infinite loop). - A thread doesn’t get CPU’s time for execution because it has low priority as compared to other threads which have higher priority. - Threads are waiting on a resource forever but they remain waiting forever because other threads are constantly notified instead of the hungry ones. When a starvation situation occurs, the program is still running but doesn’t run to completion because some threads are not executed. public class Worker { public synchronized void work() { String name = Thread.currentThread().getName(); String fileName = name + &quot;.txt&quot;; try ( BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)); ) { writer.write(&quot;Thread &quot; + name + &quot; wrote this mesasge&quot;); } catch (IOException ex) { ex.printStackTrace(); } while (true) { System.out.println(name + &quot; is working&quot;); } } public static void main(String[] args) { Worker worker = new Worker(); for (int i = 0; i &lt; 10; i++) { new Thread(new Runnable() { public void run() { worker.work(); } }).start(); } } } //we created 10 threads but, 1st threads run continuously in infinite loop, remaining will die because they won’t get any chance to execute. Finally, - Deadlock: All threads are blocked, the program hangs forever. - Livelock: No threads blocked but they run into infinite loops. The program is still running but unable to make further progress. - Starvation: Only one thread is running, and other threads are waiting forever https://www.codejava.net/java-core/concurrency/understanding-deadlock-livelock-and-starvation-with-code-examples-in-java How do you check if a Thread holds a lock or not? There is a method called holdsLock() on java.lang.Thread, it returns true if and only if the current thread holds the monitor lock on the specified object. Thread t = Thread.currentThread(); System.out.println(Thread.holdsLock(t));//true or flase -checked What is Semaphore in Java? Semaphore in Java is a new kind of synchronizer. It’s a counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphore is used to protect an expensive resource which is available in fixed number e.g. database connection in the pool. What is the difference between the submit() and execute() method thread poolin Java? execute(Runnable command) is defined in Executor interface and executes given task in future, but more importantly, it does not return anything. submit() is an overloaded method, it can take either Runnable or Callable task and can return Future object which can hold the pending result of computation. This method is defined on ExecutorService interface, which extends Executor interface, and every other thread pool class e.g. ThreadPoolExecutor or ScheduledThreadPoolExecutor gets these methods. Which method of Swing API are thread-safe in Java? I know about repaint(), and revalidate() being thread-safe but there are other methods on different swing components e.g. setText() method of JTextComponent, insert() and append() method of JTextArea class. What is the difference between the volatile and atomic variable in Java? For example count++ operation will not become atomic just by declaring count variable as volatile. On the other hand AtomicInteger class provides atomic method to perform such compound operation atomically e.g. getAndIncrement() is atomic replacement of increment operator. It can be used to atomically increment current value by one. Similarly, you have atomic version for other data type and reference variable as well. What happens if a thread throws an Exception inside synchronized block? To answer this question, no matter how you exist synchronized block, either normally by finishing execution or abruptly by throwing exception, thread releases the lock it acquired while entering that synchronized block. How do you ensure that N thread can access N resources without deadlock? Key point here is order, if you acquire resources in a particular order and release resources in reverse order you can prevent deadlock. What’s the difference between Callable and Runnable? Both of these are interfaces used to carry out task to be executed by a thread. The main difference between the two interfaces is that Callable can return a value, while Runnable cannot. Callable can throw a checked exception, while Runnable cannot. Runnable has been around since Java 1.0, while Callable was introduced as part of Java 1.5. The Callable interface is a generic interface containing a single call() method – which returns a generic value V: public interface Callable&lt;V&gt; { V call() throws Exception; } class CallableExample implements Callable { public Object call() throws Exception { Random generator = new Random(); Integer randomNumber = generator.nextInt(5); Thread.sleep(randomNumber * 1000); return randomNumber; } } What is false sharing in the context of multi-threading? false sharing is one of the well-known performance issues on multi-core systems, where each process has its local cache. False sharing is very hard to detect because the thread may be accessing completely different global variables that happen to be relatively close together in memory. Like many concurrency issues, the primary way to avoid false sharing is careful code review and aligning your data structure with the size of a cache line Object level and Class level locks in Java Object level lock - Every object in java has a unique lock. Whenever we are using synchronized keyword on instance methods, then only lock concept will come in the picture. If a thread wants to execute synchronized method on the given object. First, it has to get lock of that object. Once thread got the lock then it is allowed to execute any synchronized method on that object. Once method execution completes automatically thread releases the lock. Acquiring and release lock internally is taken care by JVM and programmer is not responsible for these activities. Lets have a look on the below program to understand the object level lock: class Geek implements Runnable { public void run() { Lock(); } public void Lock() { System.out.println(Thread.currentThread().getName()); synchronized(this) { System.out.println(&quot;in block &quot; + Thread.currentThread().getName()); System.out.println(&quot;in block &quot; + Thread.currentThread().getName() + &quot; end&quot;); } } public static void main(String[] args) { Geek g = new Geek(); Thread t1 = new Thread(g); Thread t2 = new Thread(g); Geek g1 = new Geek(); Thread t3 = new Thread(g1); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t3.setName(&quot;t3&quot;); t1.start(); t2.start(); t3.start(); } } Run on IDE Output: t1 in block t1 in block t1 end t2 in block t2 in block t2 end t3 in block t3 in block t3 end //only one thread is running Class level lock - Every class in java has a unique lock which is nothing but class level lock. If a thread wants to execute a static synchronized method, then thread requires class level lock. Once a thread got the class level lock, then it is allowed to execute any static synchronized method of that class. Once method execution completes automatically thread releases the lock. Lets look on the below program for better understanding: // Java program to illustrate class level lock class Geek implements Runnable { public void run() { Lock(); } public void Lock() { System.out.println(Thread.currentThread().getName()); synchronized(Geek.class) { System.out.println(&quot;in block &quot; + Thread.currentThread().getName()); System.out.println(&quot;in block &quot; + Thread.currentThread().getName() + &quot; end&quot;); } } public static void main(String[] args) { Geek g1 = new Geek(); Thread t1 = new Thread(g1); Thread t2 = new Thread(g1); Geek g2 = new Geek(); Thread t3 = new Thread(g2); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t3.setName(&quot;t3&quot;); t1.start(); t2.start(); t3.start(); } } Producer-Consumer solution using threads in Java The producer’s job is to generate data, put it into the buffer, and start again. same time, the consumer is consuming the data (i.e. removing it from the buffer), one piece at a time. producer won’t try to add data into the buffer if it’s full &amp; consumer won’t try to remove data from an empty buffer class Producer extends Thread { List buffer; int maxsize; public Producer(List buffer, int maxsize) { this.buffer = buffer; this.maxsize = maxsize; } @Override public void run() { int i = 1; while (true) { synchronized (buffer) { try { if (buffer.size() == maxsize) { System.out.println(&quot;Maximum Size Reached, wait until consume&quot;); buffer.wait(); } else { buffer.add(i++); System.out.println(i + &quot; : Produced, notify wating COnsumer Thread&quot;); buffer.notifyAll(); } } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } class Consumer extends Thread { List buffer; int maxsize; public Consumer(List buffer, int maxsize) { this.buffer = buffer; this.maxsize = maxsize; } @Override public void run() { while (true) { try { synchronized (buffer) { if (buffer.isEmpty()) { System.out.println(&quot;Consumer : Buffer Empty, wait untill produce&quot;); buffer.wait(); } else { Object ob = buffer.remove(0); System.out.println(ob + &quot; : Removed, notify Producer waiting for Removing for maxsize&quot;); buffer.notifyAll(); } } } catch (Exception e) { // TODO: handle exception } } } } public class ProducerConsumer { public static void main(String[] args) { List buffer = new LinkedList&lt;&gt;(); Producer producer = new Producer(buffer, 10); Consumer consumer = new Consumer(buffer, 10); producer.start(); consumer.start(); } } 28054 : Produced, notify wating COnsumer Thread 28055 : Produced, notify wating COnsumer Thread 28056 : Produced, notify wating COnsumer Thread 28057 : Produced, notify wating COnsumer Thread 28058 : Produced, notify wating COnsumer Thread 28059 : Produced, notify wating COnsumer Thread 28060 : Produced, notify wating COnsumer Thread Maximum Size Reached, wait until consume 28050 : Removed, notify Producer waiting for Removing for maxsize 28051 : Removed, notify Producer waiting for Removing for maxsize 28052 : Removed, notify Producer waiting for Removing for maxsize 28053 : Removed, notify Producer waiting for Removing for maxsize 28054 : Removed, notify Producer waiting for Removing for maxsize 28055 : Removed, notify Producer waiting for Removing for maxsize 28056 : Removed, notify Producer waiting for Removing for maxsize 28057 : Removed, notify Producer waiting for Removing for maxsize 28058 : Removed, notify Producer waiting for Removing for maxsize 28059 : Removed, notify Producer waiting for Removing for maxsize Consumer : Buffer Empty, wait untill produce What is BlockingQueue? implement Producer-Consumer using Blocking Queue? A BlockingQueue is typically used when one thread will produce objects, another thread consumes those Objects. A BlockingQueue with one thread putting into it, and another thread taking from it.   Throws Exception Special Value Blocks Times Out Insert add(o) offer(o) put(o) offer(o, timeout, timeunit) Remove remove(o) poll() take() poll(timeout, timeunit) Examine element() peek()     BlockingQueue in Java doesn’t allow null elements, various implementations like ArrayBlockingQueue, LinkedBlockingQueue throws NullPointerException when you try to add null on queue two types of BlockingQueue: ```java a. Bounded queue – with maximal capacity defined BlockingQueue blockingQueue = new LinkedBlockingDeque&lt;&gt;(10); b. UnBounded queue –no maximum capacity, can grow almost indefinitely BlockingQueue blockingQueue = new LinkedBlockingDeque&lt;&gt;(); &lt;u&gt;Producer-Consumer Example&lt;/u&gt; BlockingQueue provides a **put()** method to store the element and **take()** method to retrieve the element. Both are blocking method, which means **put()** will block if the queue has reached its capacity and there is no place to add a new element. Similarly **, take()** method will block if blocking queue is empty. So, you can see that critical requirement of the producer-consumer pattern is met right there, you don&#39;t need to put any thread synchronization code. ```java class Producer extends Thread { private BlockingQueue&lt;Integer&gt; sharedQueue; public Producer(BlockingQueue&lt;Integer&gt; aQueue) { super(&quot;PRODUCER&quot;); this.sharedQueue = aQueue; } public void run() { // no synchronization needed for (int i = 0; i &lt; 10; i++) { try { System.out.println(getName() + &quot; produced &quot; + i); sharedQueue.put(i); Thread.sleep(200); // if we remove sleep, put will execute 10 times, then take will execute } catch (InterruptedException e) { e.printStackTrace(); } } } } class Consumer extends Thread { private BlockingQueue&lt;Integer&gt; sharedQueue; public Consumer(BlockingQueue&lt;Integer&gt; aQueue) { super(&quot;CONSUMER&quot;); this.sharedQueue = aQueue; } public void run() { try { while (true) { Integer item = sharedQueue.take(); System.out.println(getName() + &quot; consumed &quot; + item); } } catch (InterruptedException e) { e.printStackTrace(); } } } public class BlockingQueueDemo { public static void main(String[] args) { BlockingQueue&lt;Integer&gt; sharedQ = new LinkedBlockingQueue&lt;Integer&gt;(); Producer p = new Producer(sharedQ); Consumer c = new Consumer(sharedQ); p.start(); c.start(); } } ArrayBlockingQueue – a blocking queue class based on bounded Java Array. Once instantiated, cannot be resized. PriorityBlockingQueue – a priority queue based blocking queue. It is an unbounded concurrent collection. LinkedBlockingQueue – an optionally bounded Java concurrent collection. Orders elements based on FIFO order. Thread. yield () yield() method: Theoretically, to ‘yield’ means to let go, to give up, to surrender. A yielding thread tells the virtual machine that it’s willing to let other threads be scheduled in its place. This indicates that it’s not doing something too critical. Note that it’s only a hint, though, and not guaranteed to have any effect at all. Yield is a Static method and Native too. Yield tells the currently executing thread to give a chance to the threads that have equal priority in the Thread Pool. There is no guarantee that Yield will make the currently executing thread to runnable state immediately. It can only make a thread from Running State to Runnable State, not in wait or blocked state. What do you understand about Thread Priority? Every thread has a priority; usually higher priority thread gets precedence in execution but it depends on Thread Scheduler implementation that is OS dependent. We can specify the priority of thread but it doesn’t guarantee that higher priority thread will get executed before lower priority thread. How can we make sure main() is the last thread to finish in Java Program? We can use Thread join() method to make sure all the threads created by the program is dead before finishing the main function. Why wait(), notify() and notifyAll() methods have to be called from synchronized method or block? When a Thread calls wait() on any Object, it must have the monitor on the Object that it will leave and goes in wait state until any other thread call notify() on this Object. Similarly when a thread calls notify() on any Object, it leaves the monitor on the Object and other waiting threads can get the monitor on the Object. Since all these methods require Thread to have the Object monitor, that can be achieved only by synchronization, they need to be called from synchronized method or block. How can we achieve thread safety in Java? There are several ways to achieve thread safety in java – synchronization, atomic concurrent classes, implementing concurrent Lock interface, using volatile keyword, using immutable classes and Thread safe classes. What is volatile keyword in Java When we use volatile keyword with a variable, all the threads read it’s value directly from the memory and don’t cache it. This makes sure that the value read is the same as in the memory. What is ThreadLocal? Java ThreadLocal is used to create thread-local variables. We know that all threads of an Object share it’s variables, so if the variable is not thread safe, we can use synchronization but if we want to avoid synchronization, we can use ThreadLocal variables. Every thread has it’s own ThreadLocal variable and they can use it’s get() and set() methods to get the default value or change it’s value local to Thread. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread What is Java Thread Dump, How can we get Java Thread dump of a Program? Thread dump is list of all the threads active in the JVM, thread dumps are very helpful in analyzing bottlenecks in the application and analyzing deadlock situations. There are many ways using which we can generate Thread dump – Using Profiler, Kill -3 command, jstack tool etc. I prefer jstack tool to generate thread dump of a program because it’s easy to use and comes with JDK installation What is atomic operation? What are atomic classes in Java Concurrency API? Atomic operations are performed in a single unit of task .int++ is not an atomic operation. So by the time one threads read it’s value and increment it by one, other thread has read the older value leading to wrong result. To solve this issue, we will have to make sure that increment operation on count is atomic, we can do that using Synchronization but Java 5 java.util.concurrent.atomic provides wrapper classes for int and long that can be used to achieve this atomically without usage of Synchronization What is Executors Class? Executors class provide utility methods for Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, and Callable classes. Executors class can be used to easily create Thread Pool in java, also this is the only class supporting execution of Callable implementations. What happens when an Exception occurs in a thread? Thread.UncaughtExceptionHandler is an interface, defined as nested interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception. When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler’s uncaughtException() method, passing the thread and the exception as arguments. Why wait, notify and notifyAll are not inside thread class? One reason which is obvious is that Java provides lock at object level not at thread level. How do you check if a Thread holds a lock or not? Boolean Thread.holdsLock(Obj) What is FutureTask in Java? (answer) This class provides a base implementation of Future, it retrieve the result of the computation. It will get the results from Feature Object. What is the concurrency level of ConcurrentHashMap in Java? (answer) ConcurrentHashMap achieves it’s scalability and thread-safety by partitioning actual map into a number of sections. This partitioning is achieved using concurrency level. Its optional parameter of ConcurrentHashMap constructor and it’s default value is 16. The table is internally partitioned to try to permit the indicated number of concurrent updates without contention. To learn more about concurrency level and internal resizing What happens if a thread throws an Exception inside synchronized block? To answer this question, no matter how you exist synchronized block, either normally by finishing execution or abruptly by throwing exception, thread releases the lock it acquired while entering that synchronized block. This is actually one of the reasons I like synchronized block over lock interface, which requires explicit attention to release lock, generally this is achieved by releasing the lock in a finally block." />
<meta property="og:description" content="Strings 1.What is immutable object? Can you write immutable object? Class –Final, Private Variables –Final, Public params Constructor, Only getters Immutable classes are Java classes whose objects cannot be modified once created. Declare the class as final so it can’t be extended. Make all fields private &amp; final so that direct access is not allowed &amp; it’s values can be assigned only once. Initialize all the fields via a constructor Write getters only, not setters. // An immutable class public final class Student { final String name; final int regNo; public Student(String name, int regNo) { this.name = name; this.regNo = regNo; } public String getName() { return name; } public int getRegNo() { return regNo; } } // Driver class class Test { public static void main(String args[]) { Student s = new Student(&quot;ABC&quot;, 101); System.out.println(s.name); System.out.println(s.regNo); // Uncommenting below line causes error // s.regNo = 102; Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: The final field Student.regNo cannot be assigned } } 2.What is Singleton? Can you write critical section code for singleton? A Singleton class is one which allows us to create only one object for JVM. Private Constructor, Private Object, Public Static Factory Method Rules: Create Singleton class Object make it as PRIVATE Create PRIVATE constructor Every Singleton class contains at least one factory method ```java class Student { private static Student st; private Student() { System.out.println(“OBJECET Created FIRST TIME”); } public static Student getObject() { if (st == null) { st = new Student(); } else { System.out.println(“OBJECET ALREDAY CREATED”); } return st; } } public class Singleton { public static void main(String[] args) { Student s1 = Student.getObject(); Student s2 = Student.getObject(); System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); } } In above code, it will create multiple instances of Singleton class if called by more than one thread parallel `Double checked locking of Singleton` is a way to ensure only one instance of Singleton class is created through application life cycle. This will bring us to **double checked locking pattern**, where only critical section of code is locked. Programmer call it double checked locking because **there are two checks** - **for \_instance == null, one without locking and** - **other with locking (inside synchronized) block.** Here is how double checked locking looks like in Java ```java public static Singleton getInstanceDC() { if (_instance == null) { // Single Checked synchronized (Singleton.class) { if (_instance == null) { // Double checked _instance = new Singleton(); } } } return _instance; } For Cloning – we need to Ovveride clone() method &amp; Should throw CloneNotSupportException For Reflection - we need to throw RuntimeException(unchekd) in private Constructor Clone() will create new Object of Singleton Class? Cloning is a concept to create duplicate objects. Using clone we can create copy of object. Suppose, we ceate clone of a singleton object, then it wil create a copy that is there are two instances of a singleton class, hence the class is no more singleton. public static void main(String args[]) throws CloneNotSupportedException { Student s1 = Student.getObject(); Student s2 = Student.getObject(); Student s3 = (Student) s1.clone(); System.out.println(s1); System.out.println(s1); System.out.println(s3); } Student@15db9742 Student@15db9742 Student@6d06d69c // Creates new Object, our singleton failed. To overcome this, we should override clone() method, it should throw Exception, anyone tries to do clone class Student implements Cloneable{ ………. @Override protected Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(); } public static void main(String args[]) throws CloneNotSupportedException { Student s1 = Student.getObject(); Student s2 = Student.getObject(); Student s3 = (Student) s1.clone(); System.out.println(s1); System.out.println(s1); System.out.println(s3); } } Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException //We are GOOD now at Student.clone(Student.java:25) at Student.main(Student.java:33) Reflection: You can make the new instance of the Singleton class by changing the constructor visibility as public in run-time and create new instance using that constructor . public static void main(String args[]) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { Student s1 = Student.getObject(); Student s2 = null; //1.Making Construtor visible Constructor&lt;Student&gt;[] constructors = (Constructor&lt;Student&gt;[]) Student.class.getDeclaredConstructors(); for (Constructor constructor : constructors) { // Below code will destroy the singleton pattern constructor.setAccessible(true); s2 = (Student) constructor.newInstance(); } System.out.println(s1); System.out.println(s2); //Using Class of newInstance() Class c = Student.class; Student s1 = Student.getObject(); Student s2 = (Student) c.newInstance(); System.out.println(s1); // Student@15db9742 System.out.println(s2); // Student@6d06d69c -Failed again  } Student@15db9742 Student@6d06d69c //Failed again  To prevent Singleton failure while due to reflection you have to throw a run-time exception in constructor, if the constructor is already initialized . class Student implements Cloneable{ private static Student st; private Student() { if(st!=null) throw new RuntimeException(&quot;Go Fucker.....&quot;); } Exception in thread &quot;main&quot; java.lang.RuntimeException: Go Fucker..... at Student.&lt;init&gt;(Student.java:15) at sun.reflect.NativeConstructorAccessor How do you reverse a String in Java without using StringBuffer? The Java library provides String Buffer and StringBuilder class with reverse() method, which can be used to reverse String in Java. String reverse = &quot;&quot;; String source= &quot;My Name is Khan&quot;; for(int i = source.length() -1; i&gt;=0; i--){ reverse = reverse + source.charAt(i); } How to Print duplicate characters from String? public class RepreatedChar { public static void main(String[] args) { String a = &quot;success&quot;; // 1.convert into char array char[] c = a.toCharArray(); // 2.create Hashmap store key as character, count as value HashMap map = new HashMap&lt;&gt;(); for (char ch : c) { // 3.Check if Map contains given Char as &lt;key&gt; or not if (map.containsKey(ch)) { // if their, get the value &amp; increment it int i = (int) map.get(ch); i++; // add updated value to it map.put(ch, i); } else { // if not their , add key &amp; value as 1 map.put(ch, 1); } } Set set = map.entrySet(); Iterator iterator = set.iterator() ; while (iterator.hasNext()) { Map.Entry entry = (Entry) iterator.next(); System.out.println(entry.getKey()+&quot; : &quot;+entry.getValue()); } } } s : 3 c : 2 u : 1 e : 1 Reverse String in Java Get String length Iterate by using charAt() in reverse &amp; append to new String ```java public class ReverseString { public static void main(String[] args) { String s = “satyam”; String rev=””; int len = s.length(); for(int i=(len-1);i&gt;=0;i–){ rev = rev+s.charAt(i); } System.out.println(rev); } } ``` Is String contains Number or not public class RegEx { public static void main(String[] args) { // Regular expression in Java to check if String is number or not Pattern pattern = Pattern.compile(&quot;.*[^0-9].*&quot;); String[] inputs = { &quot;123&quot;, &quot;-123&quot;, &quot;123.12&quot;, &quot;abcd123&quot; }; /* Matches m = pattern.match(input); * boolean ch = m.match(); */ for (String input : inputs) { System.out.println(&quot;does &quot; + input + &quot; is number : &quot; + !pattern.matcher(input).matches()); } // Regular expression in java to check if String is 6 digit number or not String[] numbers = { &quot;123&quot;, &quot;1234&quot;, &quot;123.12&quot;, &quot;abcd123&quot;, &quot;123456&quot; }; Pattern digitPattern = Pattern.compile(&quot;\\d{6}&quot;); // Pattern digitPattern = Pattern.compile(&quot;\\d\\d\\d\\d\\d\\d&quot;); for (String number : numbers) { System.out.println(&quot;does &quot; + number + &quot; is 6 digit number : &quot; + digitPattern.matcher(number).matches()); } } } Java StringTokenizer With Multiple De-limiters? The java.util.StringTokenizer class allows an application to break a string into tokens. StringTokenizer(String str) This constructor a string tokenizer for the specified string. StringTokenizer(String str, String delim) This constructor constructs string tokenizer for the specified string. The 6 useful methods of StringTokenizer class are as follows: Public method Description boolean hasMoreTokens() checks if there is more tokens available. String nextToken() returns the next token from the StringTokenizer object. String nextToken(String delim) returns the next token based on the delimeter. boolean hasMoreElements() same as hasMoreTokens() method. Object nextElement() same as nextToken() but its return type is Object. int countTokens() returns the total number of tokens. Normal Example public class Simple{ public static void main(String args[]){ StringTokenizer st = new StringTokenizer(&quot;my name is khan&quot;,&quot; &quot;); //space while (st.hasMoreTokens()) { System.out.println(st.nextToken()); } } } ============================== Output:my name is khan Java StringTokenizer with Multiple De-limiters for this we have to specify the Delimiters , separated by //. for Example StringTokenizer tokenizer = new StringTokenizer(s, &quot;// //!//,//?//.//_//&#39;//@)&quot;); public class Singleton { public static void main(String[] args) { String s = &quot;He is a very very good boy, isn&#39;t he?&quot;; StringTokenizer tokenizer = new StringTokenizer(s, &quot;// //!//,//?//.//_//&#39;//@)&quot;); System.out.println(tokenizer.countTokens()); while (tokenizer.hasMoreTokens()) { System.out.println(tokenizer.nextToken()); } } } ==================== 10 He is a very very good boy isn t he Reverse Words in a String public class RevWords { public static void main(String[] args) { // using s.split(&quot;\\s&quot;); String s = &quot;My name is Satya&quot;; String words[] = s.split(&quot;\\s&quot;); String rev = &quot;&quot;; int len = words.length; for (int i = (len - 1); i &gt;= 0; i--) { rev = rev + words[i]; } System.out.println(rev); // using Collections.reverse(str) List&lt;String&gt; word = Arrays.asList(s.split(&quot;\\s&quot;)); Collections.reverse(word); System.out.println(word); } } Using String Tokenizer public class Test { public static void main(String args[]) { System.out.println(&quot;Using Constructor 1 -By Space &quot;); StringTokenizer st1 = new StringTokenizer(&quot;Hello Geeks How are you&quot;, &quot; &quot;); System.out.println(&quot;Get TokensCount in case of revers: &quot;+st1.countTokens()); while (st1.hasMoreTokens()) System.out.println(st1.nextToken()); System.out.println(&quot;Using Constructor 2 - By Given Symol&quot;); StringTokenizer st2 = new StringTokenizer(&quot;JAVA : Code : String&quot;, &quot; :&quot;); while (st2.hasMoreTokens()) System.out.println(st2.nextToken()); System.out.println(&quot;Using Constructor 3 - Using Flag&quot;); /* * If the flag is false, delimiter characters serve to separate tokens. For * example, if string is &quot;hello geeks&quot; and delimiter is &quot; &quot;, then tokens are * &quot;hello&quot; and &quot;geeks&quot;. * * If the flag is true, delimiter characters are considered to be tokens. For * example, if string is &quot;hello geeks&quot; and delimiter is &quot; * &quot;, then tokens are &quot;hello&quot;, &quot; &quot; and &quot;geeks&quot;. */ StringTokenizer st3 = new StringTokenizer(&quot;JAVA : Code : String&quot;, &quot; :&quot;, true); while (st3.hasMoreTokens()) System.out.println(st3.nextToken()); } } What does the intern() method of String class do? (answer) The intern() method of String class put the String on which it has called into String pool e.g.** str.intern() **will put the String str into the pool. Once the String is the pool it can be reused and improve performance. public class Demo { public static void main(String[] args) { String s = new String(&quot;Satya&quot;); String intern = s.intern(); System.out.println(intern); } } Output --------- Satya How to convert String to Date in Java? (answer) Prior to Java 8, you can use DateFormat or SimpleDateFormat class to convert a String to Date In Java or vice-versa. From Java 8 onwards, when you use the new Date and Time API, you can also use the DateTimeFormatter class to convert String to LocalDate, LocalTime, or LocalDateTime class in Java. String string = &quot;February 6, 2014&quot;; date = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(string); Formatted output in Java Sometimes we need to print the output in a given specified format. For doing that we have printf() method. printf() can take multiple arguments, but System.out.print() and System.out.println() take a single argument. public class Demo { public static void main(String[] args) { int x = 100; System.out.printf(&quot;Printing simple integer: x = %d\n&quot;, x); // this will print it upto 2 decimal places System.out.printf(&quot;Formatted with precison: PI = %.2f\n&quot;, Math.PI); float n = 5.2f; // automatically appends zero to the rightmost part of decimal System.out.printf(&quot;Formatted to specific width: n = %.4f\n&quot;, n); n = 2324435.3f; // here number is formatted from right margin and occupies a width of 20 characters System.out.printf(&quot;Formatted to right margin: n = %20.4f\n&quot;, n); } } Printing simple integer: x = 100 Formatted with precison: PI = 3.14 Formatted to specific width: n = 5.2000 Formatted to right margin: n = 2324435.2500 We have The java.lang.String.format(String format, Object... args) method returns a formatted string using the specified format string and arguments. public class Demo { public static void main(String[] args) { double pi = Math.PI; // returns a formatted string using the specified format string, and arguments System.out.format(&quot;%f\n&quot;, pi); float f = 246.83278387f; String s = String.format(&quot;%.2f\n&quot;,f); System.out.println(s); } } 3.141593 246.83 Difference between format() and printf() method in Java? (answer) Even though both methods can be used to format String and they have same rules the key difference is that format() method returns a formatted String printf() method print formatted String to console. So, if you need a formatted String, use format method and if you want to print, then use the printf() method. How do you append leading zero to a numeric String? (answer) You can use the format() method of String to append leading zeros to a numeric String in Java. String str = String.format(&quot;%04d&quot;, 9); // 0009 System.out.printf(&quot;original number %d, numeric string with padding : %s&quot;, 9, str); original number 9, numeric string with padding : 0009 we can also use DecimalFormat class with passing format DecimalFormat df = new DecimalFormat(&quot;0000&quot;); String a = df.format(9); // 0009 String b = df.format(99); // 0099 String c = df.format(999); // 0999 System.out.println(&quot;\n&quot;+a+&quot; \n&quot;+b+&quot; \n&quot;+c+&quot; \n&quot;); 0009 0099 0999 Enum Enumeration in Java is supported by keyword enum. enums are a special type of class that always extends java.lang.Enum.enums are Compile time Constants, because they are -public static final Logically, each enum is an instance of enum type itself. So given enum can be seen as below declaration. JVM internally adds ordinal and value methods to this class which we can call while working with enum. public enum Direction { EAST, WEST, NORTH, SOUTH; } final class Direction extends Enum&lt;Direction&gt; { public final static Direction EAST = new Direction(); public final static Direction WEST = new Direction(); public final static Direction NORTH = new Direction(); public final static Direction SOUTH = new Direction(); } The ordinal() method returns the order of an enum instance. It represents the sequence in the enum declaration, where the initial constant is assigned an ordinal of &#39;0&#39;. It is very much like array indexes. Direction.EAST.ordinal(); //0 Direction.NORTH.ordinal(); //2 The enum values() method returns all the enum values in an enum array. Direction[] directions = Direction.values(); By default, enums don’t require constructor definitions and their default values are always the string used in the declaration. you can give define your own values by constructors to initialize. public enum Direction { // enum fields EAST(0), WEST(180), NORTH(90), SOUTH(270); // internal state private int angle; // constructor private Direction(final int angle) { this.angle = angle; } public int getAngle() { return angle; } Public Static void Main(){ Direction north = Direction.NORTH; System.out.println( north ); //NORTH System.out.println( north.getAngle() ); //90 System.out.println( Direction.NORTH.getAngle() ); //90 } } Remember that enum is basically a special class type, and it can have methods and fields just like any other class. You can add methods which are abstract as well as concrete methods as well. Both methods are allowed in enum. Two classes have been added to java.util package in support of enums – EnumSet and EnumMap public class Test { public static void main(String[] args) { Set enumSet = EnumSet.of( Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH ); Map enumMap = new EnumMap(Direction.class); //Populate the Map enumMap.put(Direction.EAST, Direction.EAST.getAngle()); enumMap.put(Direction.WEST, Direction.WEST.getAngle()); enumMap.put(Direction.NORTH, Direction.NORTH.getAngle()); enumMap.put(Direction.SOUTH, Direction.SOUTH.getAngle()); } } 1) Can Enum implement interface in Java? Yes, Enum can implement interface in Java. Since enum is a type, similar to class and interface, it can implement interface. This gives a lot of flexibility to use Enum as specialized implementation in some cases Can Enum extends class in Java? No, Enum can not extend class in Java. Because all Enum by default extend abstract base class java.lang.Enum, obviously they cannot extend another class, because Java doesn’t support multiple inheritance for classes. Because of extending java.lang.Enum class, all enum gets methods like ordinal(), values() or valueOf(). Can we create instance of Enum outside of Enum itself? If Not, Why? No, you cannot create enum instances outside of Enum boundary, because Enum doesn’t have any **public constructor, and compiler doesn’t allow you to provide any public constructor in Enum. But we can write private/protected Constructor.** Since compiler generates lot of code in response to enum type declaration, it doesn’t allow public constructors inside Enum, which enforces declaring enum instances inside Enum itself. Can we declare Constructor inside Enum in Java? Yes, you can, but remember you can only declare either private or package-private constructor inside enum. public and protected constructors are not permitted inside enum. See here for a code example. Exception Handling 1.Checked Exceptions: They Checked by Compiler, the given resource is existed or not, They are usually occur interacting with outside resources/ network resources e.g. database problems, network connection errors, missing files etc. Java forces you to handle these error scenarios in some manner in your application code 2.Unchecked Exceptions: occurrences of which are not checked by the compiler like coding, initialization, Primitive data errors. They usually result of bad code in your system. 3.Error : JVM +Memory+ OS level issues . OutofMemory, StatckOverFlow What will happen if you put System.exit(0) on try or catch block? In normal Finally block will always execute. The only case finally block is not executed is System.exit(0). In advanced case it will execute in following case. By Calling System.exit(0) in try or catch block, its stops execution &amp; throws SecurityException few times only. If System.exit(0) NOT throws security exception, then finally block Won’t be executed ```java public class Demo { public static void main(String[] args) { try { System.out.println(“try”); System.exit(0); }catch (Exception e) { System.out.println(“catch”); } finally { System.out.println(“finally”); } } } try - (Security Exception not thrown) - But, if **System.exit(0) throws security exception then finally block will be executed**. **java.lang.System.exit()** will terminates the currently executing program by JVM. - **exit(0)** : Generally used to indicate successful termination. - **exit(1) or exit(-1) or any other non-zero value** –indicates unsuccessful termination. ## What happens if we put return statement on try/catch? Will finally block execute? Yes, finally block will execute even if you put a return statement in the try block or catch block. ```java try { //try block ... return success; } catch (Exception ex) { //catch block ..... return failure; } finally { System.out.println(&quot;Inside finally&quot;); } The answer is yes. finally block will execute. The only case where it will not execute is when it encounters System.exit(). What happens when a finally block has a return statement? Finally block overrides the value returned by try and catch blocks. public static int myTestingFuncn(){ try{ .... return 5; } finally { .... return 19; } } This program would return value 19 since the value returned by try has been overridden by finally. Remember, if a method return any thing in try, we must place return in catch as well. public class Test { public int number() { try { int c = 10 / 0; return 100; } catch (Exception e) { return 200; } finally { return 300; } } public static void main(String args[]) { System.out.println(new Test().number()); } } 0/p: 300 Why do you think Checked Exception exists in Java, since we can also convey error using RuntimeException? Most of checked exceptions are in java.io package, which make sense because if you request any system resource and its not available, than a robust program must be able to handle that situation gracefully. By declaring IOException as checked Exception, Java ensures that yours provide that gracefully exception handling. Another possible reason could be to ensuring that system resources like file descriptors, which are limited in numbers, should be released as soon as you are done with that using catch or finally block Have you faced OutOfMemoryError in Java? How did you solved that? OutOfMemoryError in Java is a subclass of java.lang.VirtualMachineError and JVM throws java.lang.OutOfMemoryError when it ran out of memory in the heap. An easy way to solve OutOfMemoryError in java is to increase the maximum heap size by using JVM options “-Xmx512M”, this will immediately solve your OutOfMemoryError. java –Xmx512m myprogram -Xms512m -Xmx1152m -XX:MaxPermSize=256m -XX:MaxNewSize=256m I/O Streams 1.ByteStreams(1 byte at a time) : read image, audio, video etc FileOutputStream outputStream = new FileOutputStream(&quot;c:\a.txt&quot;); for (int i = 0; i &lt; 10; i++) { outputStream.write(i); } FileInputStream inputStream = new FileInputStream(&quot;c:\a.txt&quot;); int i; while ((i = inputStream.read()) != -1) { System.out.println(&quot;I : &quot; + i); } 2.CharacterStreams(2 Bytes at a time) : Character file data char[] ch ={ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; }; FileWriter w = new FileWriter(filepath); w.write(ch); w.close(); FileReader r = new FileReader(filepath); int i; while ((i = r.read()) != -1) { System.out.println(i + &quot;:&quot; + (char) i); } 3.Buffered Streams(1024 bytes at a time): Rather than read one byte at a time, it reads a larger block at a time into an internal buffer // 1.Create Stream Object FileOutputStream fos = new FileOutputStream(filepath); // 2.pass Stream object to BufferStream constructor BufferedOutputStream bos = new BufferedOutputStream(fos); String s = &quot;SmlCodes.com -Programmimg Simplified&quot;; byte[] b = s.getBytes(); bos.write(b); bos.flush(); // 1.Create Stream Object FileInputStream fis = new FileInputStream(filepath); // 2.pass Stream object to BufferStream constructor BufferedInputStream bis = new BufferedInputStream(fis); int i; while((i=bis.read())!=-1){ System.out.println((char)i); } 4.Data streams: above we have only Char &amp; Byte types. I/O of primitive data type values (int, long, float, and double) DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;sml.bin&quot;)); dos.writeInt(10); dos.writeUTF(&quot;Satya&quot;); DataInputStream dis = new DataInputStream(new FileInputStream(&quot;sml.bin&quot;)); System.out.println(&quot;Int : &quot; + dis.readInt()); System.out.println(&quot;String : &quot; + dis.readUTF()); 5.Object Streams : object streams support I/O of objects. Serialization. • Choose the appropriate class name whose object is participating in serialization. • This class must implement java.io.Serializable interface class Student implements Serializable { // Exception in thread &quot;main&quot; java.io.NotSerializableException: io.Student private int sno; private String name; private String addr; } public class Serialization { public static void main(String[] args) throws Exception { Student student = new Student(); student.setSno(101); student.setName(&quot;Satya Kaveti&quot;); student.setAddr(&quot;VIJAYAWADA&quot;); FileOutputStream fos = new FileOutputStream(&quot;student.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(student); FileInputStream fis = new FileInputStream(&quot;student.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student st = (Student)ois.readObject(); System.out.println(st.getSno()); System.out.println(st.getName()); System.out.println(st.getAddr()); } } Can a Serializable class contain a non-serializable field in Java? (answer) Yes, but you need to make it either static or transient. A static variable cannot be serialized. Static variables belong to a class and not to any individual instance. The concept of serialization is concerned with the object’s current state. Only data associated with a specific instance of a class is serialized, therefore static member fields are ignored during serialization class Student implements Serializable { // Exception in thread &quot;main&quot; java.io.NotSerializableException: io.Student private int sno; private static String name; //Setters &amp; Getters } public class Demo { public static void main(String[] args) throws Exception { Student student = new Student(); student.setSno(101); student.setName(&quot;Satya Kaveti&quot;); FileOutputStream fos = new FileOutputStream(&quot;student.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(student); FileInputStream fis = new FileInputStream(&quot;student.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student st = (Student)ois.readObject(); System.out.println(st.getSno()); System.out.println(st.getName()); } } 101 Satya Kaveti (Static serliaze ?) //Confused? Let’s stop the program, and remove writing part &amp; re-run it! public class Demo { public static void main(String[] args) throws Exception { FileInputStream fis = new FileInputStream(&quot;student.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student st = (Student)ois.readObject(); System.out.println(st.getSno()); System.out.println(st.getName()); } } 101 null This clearly indicates that static variable is not stored in the file, but the value of the static variable that is currently loaded into memory is being picked up, when you use st.getName()); Threads What happens if we starts same Thread(ob) Twice? public class ThreadDemo extends Thread { @Override public void run() { System.out.println(&quot;Iam Running&quot;); } public static void main(String[] args) { ThreadDemo ob = new ThreadDemo(); ob.start(); ob.start(); } } Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException at java.lang.Thread.start(Thread.java:705) at threads.ThreadDemo.main(ThreadDemo.java:11) Iam Running What guarantee volatile variable provides? volatile provides the guarantee, changes made in one thread is visible to others. What is busy spin? We have T1, T2, T3 tasks which are executed by the threads t1,t2,t3. But T2, T3 Should execute after T1 completes its execution. for that they must communicate via signaling. We can achieve this singling process in following ways 1.Busy Wait 1. here we have FLAG variable which in initialized to NO. t2, t3 threads will check for FLAG = Yes or not for every 30 seconds via loop, util FLAG = yes. This is called Busy Spin / Busy wait. 2.After some time, t1 changes status to YES, so that t2, t3 can proceed its execution. Busy spinning or busy wait in a multi-threaded environment is a technique where other threads loop continuously waiting for a thread to complete its task and signal them to start. while(spinningFlag){ System.out.println(&quot;Waiting busy spinning&quot;); } import org.omg.Messaging.SyncScopeHelper; public class BusySpin { private static boolean flag =false; public synchronized boolean checkFlag() { return flag; } public synchronized boolean changeFlag() { flag=true; return flag; } public static void main(String[] args) throws Exception { BusySpin ob = new BusySpin(); Thread t1 = new Thread() { @Override public void run() { System.out.println(&quot;T1 Running&quot;); try { Thread.sleep(5000); System.out.println(&quot;============ SET FLAG TRUE===&quot;); ob.changeFlag(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }; t1.start(); Thread t2 = new Thread() { @Override public void run() { System.out.println(&quot;T2 Checking ........&quot;); while (ob.checkFlag()) { System.out.println(&quot;T2 Running.....&quot;); } try { wait(300); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }; t2.start(); Thread t3 = new Thread() { @Override public void run() { System.out.println(&quot;T3 Checking ........&quot;); while (ob.checkFlag()) { System.out.println(&quot;T3 Running.....&quot;); } try { wait(300); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }; t3.start(); } } What is race condition in Java? Given one example? (answer) -Race condition occurs when two or more threads try to read &amp; write a shared variable at the same time” Because the thread scheduling algorithm can swap between threads at any time, you don’t know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are “racing” to access/change the data. class Counter implements Runnable { private int count; @Override public void run() { for (int i = 1; i &lt;= 100; i++) { try { Thread.sleep(100); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } count++; } } public int getCount() { return this.count; } } public class RaceCondition{ public static void main(String[] args) throws InterruptedException { Counter c = new Counter(); Thread t1 = new Thread(c); t1.start(); Thread t2 = new Thread(c); t2.start(); // wait for threads to finish processing t1.join(); t2.join(); System.out.println(&quot;Excepting =200, Actual is =&quot; + c.getCount()); } } Excepting =200, Actual is =141 -1st Run Excepting =200, Actual is =157 -2nd Run What is Thread Dump? How do you take thread dump in Java? Process has multiple Threads. Thread dump is a summary of the state of all threads of the process ‘jstack’ is an effective command line tool to capture thread dumps Java VisualVM is a GUI tool that provides detailed information about the applications Why Swing is not thread-safe in Java? Since GUI screens are mostly updated in response of user action e.g. when user click a button, and since events are handled in the same Event dispatcher thread, it’s easy to update GUI on that thread. What is a ThreadLocal variable in Java? Thread-local variables are variables restricted to a thread, it’s like thread’s own copy which is not shared between multiple threads. Java provides a ThreadLocal class to support thread-local variables, It extends Object class. Basically it is an another way to achieve thread safety apart from writing immutable classes. Since Object is no more shared there is no requirement of Synchronization which can improve scalability and performance of application. ThreadLocal provides thread restriction which is extension of local variable. ThreadLocal are visible only in single thread. No two thread can see each other’s thread local variable. These variable are generally private static field in classes and maintain its state inside thread. void set(Object value), Object get(), void remove() methods are available public class ThreadLocalExample { public static class MyRunnable implements Runnable { private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;(); public void run() { threadLocal.set((int) (Math.random() * 100D)); System.out.println(threadLocal.get()); } } public static void main(String[] args) throws InterruptedException { MyRunnable sharedRunnableInstance = new MyRunnable(); Thread thread1 = new Thread(sharedRunnableInstance); Thread thread2 = new Thread(sharedRunnableInstance); thread1.start(); thread2.start(); thread1.join(); // wait for thread 1 to terminate thread2.join(); // wait for thread 2 to terminate } } ----------- 36 16 This example This example creates a single MyRunnable instance which is passed to two different threads. Both threads execute the run() method, and thus sets different values on the ThreadLocal instance. If the access to the set() call had been synchronized, and it had not been a ThreadLocal object, the second thread would have overridden the value set by the first thread Write code for thread-safe Singleton in Java? When we say thread-safe, which means Singleton should remain singleton even if initialization occurs in the case of multiple threads. public class DoubleCheckedLockingSingleton { private volatile DoubleCheckedLockingSingleton INSTANCE; private DoubleCheckedLockingSingleton() { } public DoubleCheckedLockingSingleton getInstance(){ if(INSTANCE == null){ synchronized(DoubleCheckedLockingSingleton.class){ //double checking Singleton instance if(INSTANCE == null){ INSTANCE = new DoubleCheckedLockingSingleton(); } } } return INSTANCE; } } When to use Runnable vs Thread in Java? (Think Inheritance) it’s better to implement Runnable then extends Thread if you also want to extend another class Difference between Runnable and Callable in Java? Callable was added on JDK 1.5. Main difference between these two is that Callable’s call() method can return value and throw Exception, which was not possible with Runnable’s run() method. Callable return Future object, which can hold the result of computation. class SumTask implements Callable&lt;Integer&gt; { private int num = 0; public SumTask(int num){ this.num = num; } @Override public Integer call() throws Exception { int result = 0; for(int i=1;i&lt;=num;i++){ result+=i; } return result; } } public class CallableDemo { public static void main(String[] args) throws Exception { ExecutorService service = Executors.newSingleThreadExecutor(); SumTask sumTask = new SumTask(20); Future&lt;Integer&gt; future = service.submit(sumTask); Integer result = future.get(); System.out.println(result); } } How to stop a thread in Java? There was some control methods in JDK 1.0 e.g. stop(), suspend() and resume() which are deprecated. We can do it in Two ways 1.Using interrupt() public class Demo { public static void main(String[] args) throws Exception { Runnable runnable = ()-&gt;{ System.out.println(&quot;Running...&quot;); try { Thread.sleep(5000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(&quot;I have Completed ...&quot;); }; Thread t1 = new Thread(runnable); t1.start(); t1.interrupt(); } } Running... I have Completed ... java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at Demo.lambda$0(Demo.java:16) at java.lang.Thread.run(Thread.java:748) In this case we can only stop Sleeping thread. 2.volatile boolean variable In this case we need to use volatile boolean variable, &amp; we need to change value to TRUE if we want to stop a thread. I have a server; I need it to Stop class Server implements Runnable { private volatile boolean stop = false; public void run() { while (!stop) { System.out.println(&quot;Server is running.....&quot;); } System.out.println(&quot;Server is stopped....&quot;); } public void stop() { stop = true; } } public class Demo { public static void main(String[] args) throws Exception { Server myServer = new Server(); Thread t1 = new Thread(myServer, &quot;T1&quot;); t1.start(); // Now, let&#39;s stop our Server thread System.out.println(Thread.currentThread().getName() + &quot; is stopping Server thread&quot;); TimeUnit.MILLISECONDS.sleep(8); myServer.stop(); // Let&#39;s wait to see server thread stopped System.out.println(Thread.currentThread().getName() + &quot; is finished now&quot;); } } Actually we are not stoping the Thread, we just coming out of the run(). Why wait, notify and notifyAll are not inside thread class? Java provides lock at object level not at thread level. Every object has lock, which is acquired by thread. Now if thread needs to wait for certain lock it make sense to call wait() on that object rather than on that thread. Had wait() method declared on Thread class, it was not clear that for which lock thread was waiting. In short, since wait, notify and notifyAll operate at lock level, it make sense to defined it on object class because lock belongs to object. What is the difference between Deadlock, Starvation, and Livelock? Deadlock: is a situation where two more threads are blocked because of waiting for each other forever.one of the possible situation is nested Synchronized blocks. To create simple deadlock situation for a servlet, just place doPost() method inside doGet() and doGet()method inside doPost(). public class Business { private Object lock1 = new Object(); private Object lock2 = new Object(); public void foo() { synchronized (lock1) { synchronized (lock2) { System.out.println(&quot;foo&quot;); } } } public void bar() { synchronized (lock2) { synchronized (lock1) { System.out.println(&quot;bar&quot;); } } } public static void main(String[] args) { Business business = new Business(); Thread t1 = new Thread(new Runnable() { public void run() { business.foo(); } }); t1.start(); Thread t2 = new Thread(new Runnable() { public void run() { business.bar(); } }); t2.start(); } } how to avoid deadlock Avoid acquiring more than one lock at a time. If not, make sure that you acquire multiple locks in consistent order. In the above example, you can avoid deadlock by synchronize two locks in the same order in both methods. public void foo() { synchronized (lock1) { synchronized (lock2) { System.out.println(&quot;foo&quot;); } } } public void bar() { synchronized (lock1) { synchronized (lock2) { System.out.println(&quot;bar&quot;); } } } 2.LiveLock :A real-world example of livelock occurs when two people meet in a narrow corridor (తాడిమట్ట), and each tries to be polite by moving aside to let the other pass, but they end up swaying from side to side without making any progress because they both repeatedly move the same way at the same time. Livelock occurs when two or more processes continually repeat the same interaction in response to changes in the other processes without doing any useful work. These processes are not in the waiting state, and they are running concurrently. This is different from a deadlock because in a deadlock all processes are in the waiting state. public class Test { boolean selected=false; public boolean isSelected() { return selected; } public void setSelected(boolean selected) { this.selected = selected; } public static void main(String args[]) { Test itemOne = new Test(); Test itemTwo = new Test(); Thread tOne = new Thread(new Runnable() { @Override public void run() { while(!itemOne.isSelected()) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } itemTwo.setSelected(true); } }); Thread tTwo = new Thread(new Runnable() { @Override public void run() { while(!itemTwo.isSelected()) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } itemOne.setSelected(true); } }); tOne.start(); tTwo.start(); } } 3. Starvation: describes a situation where a thread holds a resource for a long time so other threads are blocked forever. The blocked threads are waiting to acquire the resource but they never get a chance. Thus they starve to death.BTW, Starvation means suffering or death caused by lack of food. Starvation can occur due to the following reasons: - Threads are blocked infinitely because a thread takes long time to execute some synchronized code (e.g. heavy I/O operations or infinite loop). - A thread doesn’t get CPU’s time for execution because it has low priority as compared to other threads which have higher priority. - Threads are waiting on a resource forever but they remain waiting forever because other threads are constantly notified instead of the hungry ones. When a starvation situation occurs, the program is still running but doesn’t run to completion because some threads are not executed. public class Worker { public synchronized void work() { String name = Thread.currentThread().getName(); String fileName = name + &quot;.txt&quot;; try ( BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)); ) { writer.write(&quot;Thread &quot; + name + &quot; wrote this mesasge&quot;); } catch (IOException ex) { ex.printStackTrace(); } while (true) { System.out.println(name + &quot; is working&quot;); } } public static void main(String[] args) { Worker worker = new Worker(); for (int i = 0; i &lt; 10; i++) { new Thread(new Runnable() { public void run() { worker.work(); } }).start(); } } } //we created 10 threads but, 1st threads run continuously in infinite loop, remaining will die because they won’t get any chance to execute. Finally, - Deadlock: All threads are blocked, the program hangs forever. - Livelock: No threads blocked but they run into infinite loops. The program is still running but unable to make further progress. - Starvation: Only one thread is running, and other threads are waiting forever https://www.codejava.net/java-core/concurrency/understanding-deadlock-livelock-and-starvation-with-code-examples-in-java How do you check if a Thread holds a lock or not? There is a method called holdsLock() on java.lang.Thread, it returns true if and only if the current thread holds the monitor lock on the specified object. Thread t = Thread.currentThread(); System.out.println(Thread.holdsLock(t));//true or flase -checked What is Semaphore in Java? Semaphore in Java is a new kind of synchronizer. It’s a counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphore is used to protect an expensive resource which is available in fixed number e.g. database connection in the pool. What is the difference between the submit() and execute() method thread poolin Java? execute(Runnable command) is defined in Executor interface and executes given task in future, but more importantly, it does not return anything. submit() is an overloaded method, it can take either Runnable or Callable task and can return Future object which can hold the pending result of computation. This method is defined on ExecutorService interface, which extends Executor interface, and every other thread pool class e.g. ThreadPoolExecutor or ScheduledThreadPoolExecutor gets these methods. Which method of Swing API are thread-safe in Java? I know about repaint(), and revalidate() being thread-safe but there are other methods on different swing components e.g. setText() method of JTextComponent, insert() and append() method of JTextArea class. What is the difference between the volatile and atomic variable in Java? For example count++ operation will not become atomic just by declaring count variable as volatile. On the other hand AtomicInteger class provides atomic method to perform such compound operation atomically e.g. getAndIncrement() is atomic replacement of increment operator. It can be used to atomically increment current value by one. Similarly, you have atomic version for other data type and reference variable as well. What happens if a thread throws an Exception inside synchronized block? To answer this question, no matter how you exist synchronized block, either normally by finishing execution or abruptly by throwing exception, thread releases the lock it acquired while entering that synchronized block. How do you ensure that N thread can access N resources without deadlock? Key point here is order, if you acquire resources in a particular order and release resources in reverse order you can prevent deadlock. What’s the difference between Callable and Runnable? Both of these are interfaces used to carry out task to be executed by a thread. The main difference between the two interfaces is that Callable can return a value, while Runnable cannot. Callable can throw a checked exception, while Runnable cannot. Runnable has been around since Java 1.0, while Callable was introduced as part of Java 1.5. The Callable interface is a generic interface containing a single call() method – which returns a generic value V: public interface Callable&lt;V&gt; { V call() throws Exception; } class CallableExample implements Callable { public Object call() throws Exception { Random generator = new Random(); Integer randomNumber = generator.nextInt(5); Thread.sleep(randomNumber * 1000); return randomNumber; } } What is false sharing in the context of multi-threading? false sharing is one of the well-known performance issues on multi-core systems, where each process has its local cache. False sharing is very hard to detect because the thread may be accessing completely different global variables that happen to be relatively close together in memory. Like many concurrency issues, the primary way to avoid false sharing is careful code review and aligning your data structure with the size of a cache line Object level and Class level locks in Java Object level lock - Every object in java has a unique lock. Whenever we are using synchronized keyword on instance methods, then only lock concept will come in the picture. If a thread wants to execute synchronized method on the given object. First, it has to get lock of that object. Once thread got the lock then it is allowed to execute any synchronized method on that object. Once method execution completes automatically thread releases the lock. Acquiring and release lock internally is taken care by JVM and programmer is not responsible for these activities. Lets have a look on the below program to understand the object level lock: class Geek implements Runnable { public void run() { Lock(); } public void Lock() { System.out.println(Thread.currentThread().getName()); synchronized(this) { System.out.println(&quot;in block &quot; + Thread.currentThread().getName()); System.out.println(&quot;in block &quot; + Thread.currentThread().getName() + &quot; end&quot;); } } public static void main(String[] args) { Geek g = new Geek(); Thread t1 = new Thread(g); Thread t2 = new Thread(g); Geek g1 = new Geek(); Thread t3 = new Thread(g1); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t3.setName(&quot;t3&quot;); t1.start(); t2.start(); t3.start(); } } Run on IDE Output: t1 in block t1 in block t1 end t2 in block t2 in block t2 end t3 in block t3 in block t3 end //only one thread is running Class level lock - Every class in java has a unique lock which is nothing but class level lock. If a thread wants to execute a static synchronized method, then thread requires class level lock. Once a thread got the class level lock, then it is allowed to execute any static synchronized method of that class. Once method execution completes automatically thread releases the lock. Lets look on the below program for better understanding: // Java program to illustrate class level lock class Geek implements Runnable { public void run() { Lock(); } public void Lock() { System.out.println(Thread.currentThread().getName()); synchronized(Geek.class) { System.out.println(&quot;in block &quot; + Thread.currentThread().getName()); System.out.println(&quot;in block &quot; + Thread.currentThread().getName() + &quot; end&quot;); } } public static void main(String[] args) { Geek g1 = new Geek(); Thread t1 = new Thread(g1); Thread t2 = new Thread(g1); Geek g2 = new Geek(); Thread t3 = new Thread(g2); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t3.setName(&quot;t3&quot;); t1.start(); t2.start(); t3.start(); } } Producer-Consumer solution using threads in Java The producer’s job is to generate data, put it into the buffer, and start again. same time, the consumer is consuming the data (i.e. removing it from the buffer), one piece at a time. producer won’t try to add data into the buffer if it’s full &amp; consumer won’t try to remove data from an empty buffer class Producer extends Thread { List buffer; int maxsize; public Producer(List buffer, int maxsize) { this.buffer = buffer; this.maxsize = maxsize; } @Override public void run() { int i = 1; while (true) { synchronized (buffer) { try { if (buffer.size() == maxsize) { System.out.println(&quot;Maximum Size Reached, wait until consume&quot;); buffer.wait(); } else { buffer.add(i++); System.out.println(i + &quot; : Produced, notify wating COnsumer Thread&quot;); buffer.notifyAll(); } } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } class Consumer extends Thread { List buffer; int maxsize; public Consumer(List buffer, int maxsize) { this.buffer = buffer; this.maxsize = maxsize; } @Override public void run() { while (true) { try { synchronized (buffer) { if (buffer.isEmpty()) { System.out.println(&quot;Consumer : Buffer Empty, wait untill produce&quot;); buffer.wait(); } else { Object ob = buffer.remove(0); System.out.println(ob + &quot; : Removed, notify Producer waiting for Removing for maxsize&quot;); buffer.notifyAll(); } } } catch (Exception e) { // TODO: handle exception } } } } public class ProducerConsumer { public static void main(String[] args) { List buffer = new LinkedList&lt;&gt;(); Producer producer = new Producer(buffer, 10); Consumer consumer = new Consumer(buffer, 10); producer.start(); consumer.start(); } } 28054 : Produced, notify wating COnsumer Thread 28055 : Produced, notify wating COnsumer Thread 28056 : Produced, notify wating COnsumer Thread 28057 : Produced, notify wating COnsumer Thread 28058 : Produced, notify wating COnsumer Thread 28059 : Produced, notify wating COnsumer Thread 28060 : Produced, notify wating COnsumer Thread Maximum Size Reached, wait until consume 28050 : Removed, notify Producer waiting for Removing for maxsize 28051 : Removed, notify Producer waiting for Removing for maxsize 28052 : Removed, notify Producer waiting for Removing for maxsize 28053 : Removed, notify Producer waiting for Removing for maxsize 28054 : Removed, notify Producer waiting for Removing for maxsize 28055 : Removed, notify Producer waiting for Removing for maxsize 28056 : Removed, notify Producer waiting for Removing for maxsize 28057 : Removed, notify Producer waiting for Removing for maxsize 28058 : Removed, notify Producer waiting for Removing for maxsize 28059 : Removed, notify Producer waiting for Removing for maxsize Consumer : Buffer Empty, wait untill produce What is BlockingQueue? implement Producer-Consumer using Blocking Queue? A BlockingQueue is typically used when one thread will produce objects, another thread consumes those Objects. A BlockingQueue with one thread putting into it, and another thread taking from it.   Throws Exception Special Value Blocks Times Out Insert add(o) offer(o) put(o) offer(o, timeout, timeunit) Remove remove(o) poll() take() poll(timeout, timeunit) Examine element() peek()     BlockingQueue in Java doesn’t allow null elements, various implementations like ArrayBlockingQueue, LinkedBlockingQueue throws NullPointerException when you try to add null on queue two types of BlockingQueue: ```java a. Bounded queue – with maximal capacity defined BlockingQueue blockingQueue = new LinkedBlockingDeque&lt;&gt;(10); b. UnBounded queue –no maximum capacity, can grow almost indefinitely BlockingQueue blockingQueue = new LinkedBlockingDeque&lt;&gt;(); &lt;u&gt;Producer-Consumer Example&lt;/u&gt; BlockingQueue provides a **put()** method to store the element and **take()** method to retrieve the element. Both are blocking method, which means **put()** will block if the queue has reached its capacity and there is no place to add a new element. Similarly **, take()** method will block if blocking queue is empty. So, you can see that critical requirement of the producer-consumer pattern is met right there, you don&#39;t need to put any thread synchronization code. ```java class Producer extends Thread { private BlockingQueue&lt;Integer&gt; sharedQueue; public Producer(BlockingQueue&lt;Integer&gt; aQueue) { super(&quot;PRODUCER&quot;); this.sharedQueue = aQueue; } public void run() { // no synchronization needed for (int i = 0; i &lt; 10; i++) { try { System.out.println(getName() + &quot; produced &quot; + i); sharedQueue.put(i); Thread.sleep(200); // if we remove sleep, put will execute 10 times, then take will execute } catch (InterruptedException e) { e.printStackTrace(); } } } } class Consumer extends Thread { private BlockingQueue&lt;Integer&gt; sharedQueue; public Consumer(BlockingQueue&lt;Integer&gt; aQueue) { super(&quot;CONSUMER&quot;); this.sharedQueue = aQueue; } public void run() { try { while (true) { Integer item = sharedQueue.take(); System.out.println(getName() + &quot; consumed &quot; + item); } } catch (InterruptedException e) { e.printStackTrace(); } } } public class BlockingQueueDemo { public static void main(String[] args) { BlockingQueue&lt;Integer&gt; sharedQ = new LinkedBlockingQueue&lt;Integer&gt;(); Producer p = new Producer(sharedQ); Consumer c = new Consumer(sharedQ); p.start(); c.start(); } } ArrayBlockingQueue – a blocking queue class based on bounded Java Array. Once instantiated, cannot be resized. PriorityBlockingQueue – a priority queue based blocking queue. It is an unbounded concurrent collection. LinkedBlockingQueue – an optionally bounded Java concurrent collection. Orders elements based on FIFO order. Thread. yield () yield() method: Theoretically, to ‘yield’ means to let go, to give up, to surrender. A yielding thread tells the virtual machine that it’s willing to let other threads be scheduled in its place. This indicates that it’s not doing something too critical. Note that it’s only a hint, though, and not guaranteed to have any effect at all. Yield is a Static method and Native too. Yield tells the currently executing thread to give a chance to the threads that have equal priority in the Thread Pool. There is no guarantee that Yield will make the currently executing thread to runnable state immediately. It can only make a thread from Running State to Runnable State, not in wait or blocked state. What do you understand about Thread Priority? Every thread has a priority; usually higher priority thread gets precedence in execution but it depends on Thread Scheduler implementation that is OS dependent. We can specify the priority of thread but it doesn’t guarantee that higher priority thread will get executed before lower priority thread. How can we make sure main() is the last thread to finish in Java Program? We can use Thread join() method to make sure all the threads created by the program is dead before finishing the main function. Why wait(), notify() and notifyAll() methods have to be called from synchronized method or block? When a Thread calls wait() on any Object, it must have the monitor on the Object that it will leave and goes in wait state until any other thread call notify() on this Object. Similarly when a thread calls notify() on any Object, it leaves the monitor on the Object and other waiting threads can get the monitor on the Object. Since all these methods require Thread to have the Object monitor, that can be achieved only by synchronization, they need to be called from synchronized method or block. How can we achieve thread safety in Java? There are several ways to achieve thread safety in java – synchronization, atomic concurrent classes, implementing concurrent Lock interface, using volatile keyword, using immutable classes and Thread safe classes. What is volatile keyword in Java When we use volatile keyword with a variable, all the threads read it’s value directly from the memory and don’t cache it. This makes sure that the value read is the same as in the memory. What is ThreadLocal? Java ThreadLocal is used to create thread-local variables. We know that all threads of an Object share it’s variables, so if the variable is not thread safe, we can use synchronization but if we want to avoid synchronization, we can use ThreadLocal variables. Every thread has it’s own ThreadLocal variable and they can use it’s get() and set() methods to get the default value or change it’s value local to Thread. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread What is Java Thread Dump, How can we get Java Thread dump of a Program? Thread dump is list of all the threads active in the JVM, thread dumps are very helpful in analyzing bottlenecks in the application and analyzing deadlock situations. There are many ways using which we can generate Thread dump – Using Profiler, Kill -3 command, jstack tool etc. I prefer jstack tool to generate thread dump of a program because it’s easy to use and comes with JDK installation What is atomic operation? What are atomic classes in Java Concurrency API? Atomic operations are performed in a single unit of task .int++ is not an atomic operation. So by the time one threads read it’s value and increment it by one, other thread has read the older value leading to wrong result. To solve this issue, we will have to make sure that increment operation on count is atomic, we can do that using Synchronization but Java 5 java.util.concurrent.atomic provides wrapper classes for int and long that can be used to achieve this atomically without usage of Synchronization What is Executors Class? Executors class provide utility methods for Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, and Callable classes. Executors class can be used to easily create Thread Pool in java, also this is the only class supporting execution of Callable implementations. What happens when an Exception occurs in a thread? Thread.UncaughtExceptionHandler is an interface, defined as nested interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception. When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler’s uncaughtException() method, passing the thread and the exception as arguments. Why wait, notify and notifyAll are not inside thread class? One reason which is obvious is that Java provides lock at object level not at thread level. How do you check if a Thread holds a lock or not? Boolean Thread.holdsLock(Obj) What is FutureTask in Java? (answer) This class provides a base implementation of Future, it retrieve the result of the computation. It will get the results from Feature Object. What is the concurrency level of ConcurrentHashMap in Java? (answer) ConcurrentHashMap achieves it’s scalability and thread-safety by partitioning actual map into a number of sections. This partitioning is achieved using concurrency level. Its optional parameter of ConcurrentHashMap constructor and it’s default value is 16. The table is internally partitioned to try to permit the indicated number of concurrent updates without contention. To learn more about concurrency level and internal resizing What happens if a thread throws an Exception inside synchronized block? To answer this question, no matter how you exist synchronized block, either normally by finishing execution or abruptly by throwing exception, thread releases the lock it acquired while entering that synchronized block. This is actually one of the reasons I like synchronized block over lock interface, which requires explicit attention to release lock, generally this is achieved by releasing the lock in a finally block." />
<meta property="og:site_name" content="SatyaCodes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-11T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Java - Interview Questions PART-2" />
<script type="application/ld+json">
{"datePublished":"2017-11-11T00:00:00+00:00","dateModified":"2017-11-11T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/Java-Interview-Questions-2.html"},"author":{"@type":"Person","name":"Satya Kaveti"},"@type":"BlogPosting","description":"Strings 1.What is immutable object? Can you write immutable object? Class –Final, Private Variables –Final, Public params Constructor, Only getters Immutable classes are Java classes whose objects cannot be modified once created. Declare the class as final so it can’t be extended. Make all fields private &amp; final so that direct access is not allowed &amp; it’s values can be assigned only once. Initialize all the fields via a constructor Write getters only, not setters. // An immutable class public final class Student { final String name; final int regNo; public Student(String name, int regNo) { this.name = name; this.regNo = regNo; } public String getName() { return name; } public int getRegNo() { return regNo; } } // Driver class class Test { public static void main(String args[]) { Student s = new Student(&quot;ABC&quot;, 101); System.out.println(s.name); System.out.println(s.regNo); // Uncommenting below line causes error // s.regNo = 102; Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: The final field Student.regNo cannot be assigned } } 2.What is Singleton? Can you write critical section code for singleton? A Singleton class is one which allows us to create only one object for JVM. Private Constructor, Private Object, Public Static Factory Method Rules: Create Singleton class Object make it as PRIVATE Create PRIVATE constructor Every Singleton class contains at least one factory method ```java class Student { private static Student st; private Student() { System.out.println(“OBJECET Created FIRST TIME”); } public static Student getObject() { if (st == null) { st = new Student(); } else { System.out.println(“OBJECET ALREDAY CREATED”); } return st; } } public class Singleton { public static void main(String[] args) { Student s1 = Student.getObject(); Student s2 = Student.getObject(); System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); } } In above code, it will create multiple instances of Singleton class if called by more than one thread parallel `Double checked locking of Singleton` is a way to ensure only one instance of Singleton class is created through application life cycle. This will bring us to **double checked locking pattern**, where only critical section of code is locked. Programmer call it double checked locking because **there are two checks** - **for \\_instance == null, one without locking and** - **other with locking (inside synchronized) block.** Here is how double checked locking looks like in Java ```java public static Singleton getInstanceDC() { if (_instance == null) { // Single Checked synchronized (Singleton.class) { if (_instance == null) { // Double checked _instance = new Singleton(); } } } return _instance; } For Cloning – we need to Ovveride clone() method &amp; Should throw CloneNotSupportException For Reflection - we need to throw RuntimeException(unchekd) in private Constructor Clone() will create new Object of Singleton Class? Cloning is a concept to create duplicate objects. Using clone we can create copy of object. Suppose, we ceate clone of a singleton object, then it wil create a copy that is there are two instances of a singleton class, hence the class is no more singleton. public static void main(String args[]) throws CloneNotSupportedException { Student s1 = Student.getObject(); Student s2 = Student.getObject(); Student s3 = (Student) s1.clone(); System.out.println(s1); System.out.println(s1); System.out.println(s3); } Student@15db9742 Student@15db9742 Student@6d06d69c // Creates new Object, our singleton failed. To overcome this, we should override clone() method, it should throw Exception, anyone tries to do clone class Student implements Cloneable{ ………. @Override protected Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(); } public static void main(String args[]) throws CloneNotSupportedException { Student s1 = Student.getObject(); Student s2 = Student.getObject(); Student s3 = (Student) s1.clone(); System.out.println(s1); System.out.println(s1); System.out.println(s3); } } Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException //We are GOOD now at Student.clone(Student.java:25) at Student.main(Student.java:33) Reflection: You can make the new instance of the Singleton class by changing the constructor visibility as public in run-time and create new instance using that constructor . public static void main(String args[]) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { Student s1 = Student.getObject(); Student s2 = null; //1.Making Construtor visible Constructor&lt;Student&gt;[] constructors = (Constructor&lt;Student&gt;[]) Student.class.getDeclaredConstructors(); for (Constructor constructor : constructors) { // Below code will destroy the singleton pattern constructor.setAccessible(true); s2 = (Student) constructor.newInstance(); } System.out.println(s1); System.out.println(s2); //Using Class of newInstance() Class c = Student.class; Student s1 = Student.getObject(); Student s2 = (Student) c.newInstance(); System.out.println(s1); // Student@15db9742 System.out.println(s2); // Student@6d06d69c -Failed again  } Student@15db9742 Student@6d06d69c //Failed again  To prevent Singleton failure while due to reflection you have to throw a run-time exception in constructor, if the constructor is already initialized . class Student implements Cloneable{ private static Student st; private Student() { if(st!=null) throw new RuntimeException(&quot;Go Fucker.....&quot;); } Exception in thread &quot;main&quot; java.lang.RuntimeException: Go Fucker..... at Student.&lt;init&gt;(Student.java:15) at sun.reflect.NativeConstructorAccessor How do you reverse a String in Java without using StringBuffer? The Java library provides String Buffer and StringBuilder class with reverse() method, which can be used to reverse String in Java. String reverse = &quot;&quot;; String source= &quot;My Name is Khan&quot;; for(int i = source.length() -1; i&gt;=0; i--){ reverse = reverse + source.charAt(i); } How to Print duplicate characters from String? public class RepreatedChar { public static void main(String[] args) { String a = &quot;success&quot;; // 1.convert into char array char[] c = a.toCharArray(); // 2.create Hashmap store key as character, count as value HashMap map = new HashMap&lt;&gt;(); for (char ch : c) { // 3.Check if Map contains given Char as &lt;key&gt; or not if (map.containsKey(ch)) { // if their, get the value &amp; increment it int i = (int) map.get(ch); i++; // add updated value to it map.put(ch, i); } else { // if not their , add key &amp; value as 1 map.put(ch, 1); } } Set set = map.entrySet(); Iterator iterator = set.iterator() ; while (iterator.hasNext()) { Map.Entry entry = (Entry) iterator.next(); System.out.println(entry.getKey()+&quot; : &quot;+entry.getValue()); } } } s : 3 c : 2 u : 1 e : 1 Reverse String in Java Get String length Iterate by using charAt() in reverse &amp; append to new String ```java public class ReverseString { public static void main(String[] args) { String s = “satyam”; String rev=””; int len = s.length(); for(int i=(len-1);i&gt;=0;i–){ rev = rev+s.charAt(i); } System.out.println(rev); } } ``` Is String contains Number or not public class RegEx { public static void main(String[] args) { // Regular expression in Java to check if String is number or not Pattern pattern = Pattern.compile(&quot;.*[^0-9].*&quot;); String[] inputs = { &quot;123&quot;, &quot;-123&quot;, &quot;123.12&quot;, &quot;abcd123&quot; }; /* Matches m = pattern.match(input); * boolean ch = m.match(); */ for (String input : inputs) { System.out.println(&quot;does &quot; + input + &quot; is number : &quot; + !pattern.matcher(input).matches()); } // Regular expression in java to check if String is 6 digit number or not String[] numbers = { &quot;123&quot;, &quot;1234&quot;, &quot;123.12&quot;, &quot;abcd123&quot;, &quot;123456&quot; }; Pattern digitPattern = Pattern.compile(&quot;\\\\d{6}&quot;); // Pattern digitPattern = Pattern.compile(&quot;\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d&quot;); for (String number : numbers) { System.out.println(&quot;does &quot; + number + &quot; is 6 digit number : &quot; + digitPattern.matcher(number).matches()); } } } Java StringTokenizer With Multiple De-limiters? The java.util.StringTokenizer class allows an application to break a string into tokens. StringTokenizer(String str) This constructor a string tokenizer for the specified string. StringTokenizer(String str, String delim) This constructor constructs string tokenizer for the specified string. The 6 useful methods of StringTokenizer class are as follows: Public method Description boolean hasMoreTokens() checks if there is more tokens available. String nextToken() returns the next token from the StringTokenizer object. String nextToken(String delim) returns the next token based on the delimeter. boolean hasMoreElements() same as hasMoreTokens() method. Object nextElement() same as nextToken() but its return type is Object. int countTokens() returns the total number of tokens. Normal Example public class Simple{ public static void main(String args[]){ StringTokenizer st = new StringTokenizer(&quot;my name is khan&quot;,&quot; &quot;); //space while (st.hasMoreTokens()) { System.out.println(st.nextToken()); } } } ============================== Output:my name is khan Java StringTokenizer with Multiple De-limiters for this we have to specify the Delimiters , separated by //. for Example StringTokenizer tokenizer = new StringTokenizer(s, &quot;// //!//,//?//.//_//&#39;//@)&quot;); public class Singleton { public static void main(String[] args) { String s = &quot;He is a very very good boy, isn&#39;t he?&quot;; StringTokenizer tokenizer = new StringTokenizer(s, &quot;// //!//,//?//.//_//&#39;//@)&quot;); System.out.println(tokenizer.countTokens()); while (tokenizer.hasMoreTokens()) { System.out.println(tokenizer.nextToken()); } } } ==================== 10 He is a very very good boy isn t he Reverse Words in a String public class RevWords { public static void main(String[] args) { // using s.split(&quot;\\\\s&quot;); String s = &quot;My name is Satya&quot;; String words[] = s.split(&quot;\\\\s&quot;); String rev = &quot;&quot;; int len = words.length; for (int i = (len - 1); i &gt;= 0; i--) { rev = rev + words[i]; } System.out.println(rev); // using Collections.reverse(str) List&lt;String&gt; word = Arrays.asList(s.split(&quot;\\\\s&quot;)); Collections.reverse(word); System.out.println(word); } } Using String Tokenizer public class Test { public static void main(String args[]) { System.out.println(&quot;Using Constructor 1 -By Space &quot;); StringTokenizer st1 = new StringTokenizer(&quot;Hello Geeks How are you&quot;, &quot; &quot;); System.out.println(&quot;Get TokensCount in case of revers: &quot;+st1.countTokens()); while (st1.hasMoreTokens()) System.out.println(st1.nextToken()); System.out.println(&quot;Using Constructor 2 - By Given Symol&quot;); StringTokenizer st2 = new StringTokenizer(&quot;JAVA : Code : String&quot;, &quot; :&quot;); while (st2.hasMoreTokens()) System.out.println(st2.nextToken()); System.out.println(&quot;Using Constructor 3 - Using Flag&quot;); /* * If the flag is false, delimiter characters serve to separate tokens. For * example, if string is &quot;hello geeks&quot; and delimiter is &quot; &quot;, then tokens are * &quot;hello&quot; and &quot;geeks&quot;. * * If the flag is true, delimiter characters are considered to be tokens. For * example, if string is &quot;hello geeks&quot; and delimiter is &quot; * &quot;, then tokens are &quot;hello&quot;, &quot; &quot; and &quot;geeks&quot;. */ StringTokenizer st3 = new StringTokenizer(&quot;JAVA : Code : String&quot;, &quot; :&quot;, true); while (st3.hasMoreTokens()) System.out.println(st3.nextToken()); } } What does the intern() method of String class do? (answer) The intern() method of String class put the String on which it has called into String pool e.g.** str.intern() **will put the String str into the pool. Once the String is the pool it can be reused and improve performance. public class Demo { public static void main(String[] args) { String s = new String(&quot;Satya&quot;); String intern = s.intern(); System.out.println(intern); } } Output --------- Satya How to convert String to Date in Java? (answer) Prior to Java 8, you can use DateFormat or SimpleDateFormat class to convert a String to Date In Java or vice-versa. From Java 8 onwards, when you use the new Date and Time API, you can also use the DateTimeFormatter class to convert String to LocalDate, LocalTime, or LocalDateTime class in Java. String string = &quot;February 6, 2014&quot;; date = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(string); Formatted output in Java Sometimes we need to print the output in a given specified format. For doing that we have printf() method. printf() can take multiple arguments, but System.out.print() and System.out.println() take a single argument. public class Demo { public static void main(String[] args) { int x = 100; System.out.printf(&quot;Printing simple integer: x = %d\\n&quot;, x); // this will print it upto 2 decimal places System.out.printf(&quot;Formatted with precison: PI = %.2f\\n&quot;, Math.PI); float n = 5.2f; // automatically appends zero to the rightmost part of decimal System.out.printf(&quot;Formatted to specific width: n = %.4f\\n&quot;, n); n = 2324435.3f; // here number is formatted from right margin and occupies a width of 20 characters System.out.printf(&quot;Formatted to right margin: n = %20.4f\\n&quot;, n); } } Printing simple integer: x = 100 Formatted with precison: PI = 3.14 Formatted to specific width: n = 5.2000 Formatted to right margin: n = 2324435.2500 We have The java.lang.String.format(String format, Object... args) method returns a formatted string using the specified format string and arguments. public class Demo { public static void main(String[] args) { double pi = Math.PI; // returns a formatted string using the specified format string, and arguments System.out.format(&quot;%f\\n&quot;, pi); float f = 246.83278387f; String s = String.format(&quot;%.2f\\n&quot;,f); System.out.println(s); } } 3.141593 246.83 Difference between format() and printf() method in Java? (answer) Even though both methods can be used to format String and they have same rules the key difference is that format() method returns a formatted String printf() method print formatted String to console. So, if you need a formatted String, use format method and if you want to print, then use the printf() method. How do you append leading zero to a numeric String? (answer) You can use the format() method of String to append leading zeros to a numeric String in Java. String str = String.format(&quot;%04d&quot;, 9); // 0009 System.out.printf(&quot;original number %d, numeric string with padding : %s&quot;, 9, str); original number 9, numeric string with padding : 0009 we can also use DecimalFormat class with passing format DecimalFormat df = new DecimalFormat(&quot;0000&quot;); String a = df.format(9); // 0009 String b = df.format(99); // 0099 String c = df.format(999); // 0999 System.out.println(&quot;\\n&quot;+a+&quot; \\n&quot;+b+&quot; \\n&quot;+c+&quot; \\n&quot;); 0009 0099 0999 Enum Enumeration in Java is supported by keyword enum. enums are a special type of class that always extends java.lang.Enum.enums are Compile time Constants, because they are -public static final Logically, each enum is an instance of enum type itself. So given enum can be seen as below declaration. JVM internally adds ordinal and value methods to this class which we can call while working with enum. public enum Direction { EAST, WEST, NORTH, SOUTH; } final class Direction extends Enum&lt;Direction&gt; { public final static Direction EAST = new Direction(); public final static Direction WEST = new Direction(); public final static Direction NORTH = new Direction(); public final static Direction SOUTH = new Direction(); } The ordinal() method returns the order of an enum instance. It represents the sequence in the enum declaration, where the initial constant is assigned an ordinal of &#39;0&#39;. It is very much like array indexes. Direction.EAST.ordinal(); //0 Direction.NORTH.ordinal(); //2 The enum values() method returns all the enum values in an enum array. Direction[] directions = Direction.values(); By default, enums don’t require constructor definitions and their default values are always the string used in the declaration. you can give define your own values by constructors to initialize. public enum Direction { // enum fields EAST(0), WEST(180), NORTH(90), SOUTH(270); // internal state private int angle; // constructor private Direction(final int angle) { this.angle = angle; } public int getAngle() { return angle; } Public Static void Main(){ Direction north = Direction.NORTH; System.out.println( north ); //NORTH System.out.println( north.getAngle() ); //90 System.out.println( Direction.NORTH.getAngle() ); //90 } } Remember that enum is basically a special class type, and it can have methods and fields just like any other class. You can add methods which are abstract as well as concrete methods as well. Both methods are allowed in enum. Two classes have been added to java.util package in support of enums – EnumSet and EnumMap public class Test { public static void main(String[] args) { Set enumSet = EnumSet.of( Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH ); Map enumMap = new EnumMap(Direction.class); //Populate the Map enumMap.put(Direction.EAST, Direction.EAST.getAngle()); enumMap.put(Direction.WEST, Direction.WEST.getAngle()); enumMap.put(Direction.NORTH, Direction.NORTH.getAngle()); enumMap.put(Direction.SOUTH, Direction.SOUTH.getAngle()); } } 1) Can Enum implement interface in Java? Yes, Enum can implement interface in Java. Since enum is a type, similar to class and interface, it can implement interface. This gives a lot of flexibility to use Enum as specialized implementation in some cases Can Enum extends class in Java? No, Enum can not extend class in Java. Because all Enum by default extend abstract base class java.lang.Enum, obviously they cannot extend another class, because Java doesn’t support multiple inheritance for classes. Because of extending java.lang.Enum class, all enum gets methods like ordinal(), values() or valueOf(). Can we create instance of Enum outside of Enum itself? If Not, Why? No, you cannot create enum instances outside of Enum boundary, because Enum doesn’t have any **public constructor, and compiler doesn’t allow you to provide any public constructor in Enum. But we can write private/protected Constructor.** Since compiler generates lot of code in response to enum type declaration, it doesn’t allow public constructors inside Enum, which enforces declaring enum instances inside Enum itself. Can we declare Constructor inside Enum in Java? Yes, you can, but remember you can only declare either private or package-private constructor inside enum. public and protected constructors are not permitted inside enum. See here for a code example. Exception Handling 1.Checked Exceptions: They Checked by Compiler, the given resource is existed or not, They are usually occur interacting with outside resources/ network resources e.g. database problems, network connection errors, missing files etc. Java forces you to handle these error scenarios in some manner in your application code 2.Unchecked Exceptions: occurrences of which are not checked by the compiler like coding, initialization, Primitive data errors. They usually result of bad code in your system. 3.Error : JVM +Memory+ OS level issues . OutofMemory, StatckOverFlow What will happen if you put System.exit(0) on try or catch block? In normal Finally block will always execute. The only case finally block is not executed is System.exit(0). In advanced case it will execute in following case. By Calling System.exit(0) in try or catch block, its stops execution &amp; throws SecurityException few times only. If System.exit(0) NOT throws security exception, then finally block Won’t be executed ```java public class Demo { public static void main(String[] args) { try { System.out.println(“try”); System.exit(0); }catch (Exception e) { System.out.println(“catch”); } finally { System.out.println(“finally”); } } } try - (Security Exception not thrown) - But, if **System.exit(0) throws security exception then finally block will be executed**. **java.lang.System.exit()** will terminates the currently executing program by JVM. - **exit(0)** : Generally used to indicate successful termination. - **exit(1) or exit(-1) or any other non-zero value** –indicates unsuccessful termination. ## What happens if we put return statement on try/catch? Will finally block execute? Yes, finally block will execute even if you put a return statement in the try block or catch block. ```java try { //try block ... return success; } catch (Exception ex) { //catch block ..... return failure; } finally { System.out.println(&quot;Inside finally&quot;); } The answer is yes. finally block will execute. The only case where it will not execute is when it encounters System.exit(). What happens when a finally block has a return statement? Finally block overrides the value returned by try and catch blocks. public static int myTestingFuncn(){ try{ .... return 5; } finally { .... return 19; } } This program would return value 19 since the value returned by try has been overridden by finally. Remember, if a method return any thing in try, we must place return in catch as well. public class Test { public int number() { try { int c = 10 / 0; return 100; } catch (Exception e) { return 200; } finally { return 300; } } public static void main(String args[]) { System.out.println(new Test().number()); } } 0/p: 300 Why do you think Checked Exception exists in Java, since we can also convey error using RuntimeException? Most of checked exceptions are in java.io package, which make sense because if you request any system resource and its not available, than a robust program must be able to handle that situation gracefully. By declaring IOException as checked Exception, Java ensures that yours provide that gracefully exception handling. Another possible reason could be to ensuring that system resources like file descriptors, which are limited in numbers, should be released as soon as you are done with that using catch or finally block Have you faced OutOfMemoryError in Java? How did you solved that? OutOfMemoryError in Java is a subclass of java.lang.VirtualMachineError and JVM throws java.lang.OutOfMemoryError when it ran out of memory in the heap. An easy way to solve OutOfMemoryError in java is to increase the maximum heap size by using JVM options “-Xmx512M”, this will immediately solve your OutOfMemoryError. java –Xmx512m myprogram -Xms512m -Xmx1152m -XX:MaxPermSize=256m -XX:MaxNewSize=256m I/O Streams 1.ByteStreams(1 byte at a time) : read image, audio, video etc FileOutputStream outputStream = new FileOutputStream(&quot;c:\\a.txt&quot;); for (int i = 0; i &lt; 10; i++) { outputStream.write(i); } FileInputStream inputStream = new FileInputStream(&quot;c:\\a.txt&quot;); int i; while ((i = inputStream.read()) != -1) { System.out.println(&quot;I : &quot; + i); } 2.CharacterStreams(2 Bytes at a time) : Character file data char[] ch ={ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; }; FileWriter w = new FileWriter(filepath); w.write(ch); w.close(); FileReader r = new FileReader(filepath); int i; while ((i = r.read()) != -1) { System.out.println(i + &quot;:&quot; + (char) i); } 3.Buffered Streams(1024 bytes at a time): Rather than read one byte at a time, it reads a larger block at a time into an internal buffer // 1.Create Stream Object FileOutputStream fos = new FileOutputStream(filepath); // 2.pass Stream object to BufferStream constructor BufferedOutputStream bos = new BufferedOutputStream(fos); String s = &quot;SmlCodes.com -Programmimg Simplified&quot;; byte[] b = s.getBytes(); bos.write(b); bos.flush(); // 1.Create Stream Object FileInputStream fis = new FileInputStream(filepath); // 2.pass Stream object to BufferStream constructor BufferedInputStream bis = new BufferedInputStream(fis); int i; while((i=bis.read())!=-1){ System.out.println((char)i); } 4.Data streams: above we have only Char &amp; Byte types. I/O of primitive data type values (int, long, float, and double) DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;sml.bin&quot;)); dos.writeInt(10); dos.writeUTF(&quot;Satya&quot;); DataInputStream dis = new DataInputStream(new FileInputStream(&quot;sml.bin&quot;)); System.out.println(&quot;Int : &quot; + dis.readInt()); System.out.println(&quot;String : &quot; + dis.readUTF()); 5.Object Streams : object streams support I/O of objects. Serialization. • Choose the appropriate class name whose object is participating in serialization. • This class must implement java.io.Serializable interface class Student implements Serializable { // Exception in thread &quot;main&quot; java.io.NotSerializableException: io.Student private int sno; private String name; private String addr; } public class Serialization { public static void main(String[] args) throws Exception { Student student = new Student(); student.setSno(101); student.setName(&quot;Satya Kaveti&quot;); student.setAddr(&quot;VIJAYAWADA&quot;); FileOutputStream fos = new FileOutputStream(&quot;student.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(student); FileInputStream fis = new FileInputStream(&quot;student.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student st = (Student)ois.readObject(); System.out.println(st.getSno()); System.out.println(st.getName()); System.out.println(st.getAddr()); } } Can a Serializable class contain a non-serializable field in Java? (answer) Yes, but you need to make it either static or transient. A static variable cannot be serialized. Static variables belong to a class and not to any individual instance. The concept of serialization is concerned with the object’s current state. Only data associated with a specific instance of a class is serialized, therefore static member fields are ignored during serialization class Student implements Serializable { // Exception in thread &quot;main&quot; java.io.NotSerializableException: io.Student private int sno; private static String name; //Setters &amp; Getters } public class Demo { public static void main(String[] args) throws Exception { Student student = new Student(); student.setSno(101); student.setName(&quot;Satya Kaveti&quot;); FileOutputStream fos = new FileOutputStream(&quot;student.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(student); FileInputStream fis = new FileInputStream(&quot;student.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student st = (Student)ois.readObject(); System.out.println(st.getSno()); System.out.println(st.getName()); } } 101 Satya Kaveti (Static serliaze ?) //Confused? Let’s stop the program, and remove writing part &amp; re-run it! public class Demo { public static void main(String[] args) throws Exception { FileInputStream fis = new FileInputStream(&quot;student.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student st = (Student)ois.readObject(); System.out.println(st.getSno()); System.out.println(st.getName()); } } 101 null This clearly indicates that static variable is not stored in the file, but the value of the static variable that is currently loaded into memory is being picked up, when you use st.getName()); Threads What happens if we starts same Thread(ob) Twice? public class ThreadDemo extends Thread { @Override public void run() { System.out.println(&quot;Iam Running&quot;); } public static void main(String[] args) { ThreadDemo ob = new ThreadDemo(); ob.start(); ob.start(); } } Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException at java.lang.Thread.start(Thread.java:705) at threads.ThreadDemo.main(ThreadDemo.java:11) Iam Running What guarantee volatile variable provides? volatile provides the guarantee, changes made in one thread is visible to others. What is busy spin? We have T1, T2, T3 tasks which are executed by the threads t1,t2,t3. But T2, T3 Should execute after T1 completes its execution. for that they must communicate via signaling. We can achieve this singling process in following ways 1.Busy Wait 1. here we have FLAG variable which in initialized to NO. t2, t3 threads will check for FLAG = Yes or not for every 30 seconds via loop, util FLAG = yes. This is called Busy Spin / Busy wait. 2.After some time, t1 changes status to YES, so that t2, t3 can proceed its execution. Busy spinning or busy wait in a multi-threaded environment is a technique where other threads loop continuously waiting for a thread to complete its task and signal them to start. while(spinningFlag){ System.out.println(&quot;Waiting busy spinning&quot;); } import org.omg.Messaging.SyncScopeHelper; public class BusySpin { private static boolean flag =false; public synchronized boolean checkFlag() { return flag; } public synchronized boolean changeFlag() { flag=true; return flag; } public static void main(String[] args) throws Exception { BusySpin ob = new BusySpin(); Thread t1 = new Thread() { @Override public void run() { System.out.println(&quot;T1 Running&quot;); try { Thread.sleep(5000); System.out.println(&quot;============ SET FLAG TRUE===&quot;); ob.changeFlag(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }; t1.start(); Thread t2 = new Thread() { @Override public void run() { System.out.println(&quot;T2 Checking ........&quot;); while (ob.checkFlag()) { System.out.println(&quot;T2 Running.....&quot;); } try { wait(300); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }; t2.start(); Thread t3 = new Thread() { @Override public void run() { System.out.println(&quot;T3 Checking ........&quot;); while (ob.checkFlag()) { System.out.println(&quot;T3 Running.....&quot;); } try { wait(300); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }; t3.start(); } } What is race condition in Java? Given one example? (answer) -Race condition occurs when two or more threads try to read &amp; write a shared variable at the same time” Because the thread scheduling algorithm can swap between threads at any time, you don’t know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are “racing” to access/change the data. class Counter implements Runnable { private int count; @Override public void run() { for (int i = 1; i &lt;= 100; i++) { try { Thread.sleep(100); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } count++; } } public int getCount() { return this.count; } } public class RaceCondition{ public static void main(String[] args) throws InterruptedException { Counter c = new Counter(); Thread t1 = new Thread(c); t1.start(); Thread t2 = new Thread(c); t2.start(); // wait for threads to finish processing t1.join(); t2.join(); System.out.println(&quot;Excepting =200, Actual is =&quot; + c.getCount()); } } Excepting =200, Actual is =141 -1st Run Excepting =200, Actual is =157 -2nd Run What is Thread Dump? How do you take thread dump in Java? Process has multiple Threads. Thread dump is a summary of the state of all threads of the process ‘jstack’ is an effective command line tool to capture thread dumps Java VisualVM is a GUI tool that provides detailed information about the applications Why Swing is not thread-safe in Java? Since GUI screens are mostly updated in response of user action e.g. when user click a button, and since events are handled in the same Event dispatcher thread, it’s easy to update GUI on that thread. What is a ThreadLocal variable in Java? Thread-local variables are variables restricted to a thread, it’s like thread’s own copy which is not shared between multiple threads. Java provides a ThreadLocal class to support thread-local variables, It extends Object class. Basically it is an another way to achieve thread safety apart from writing immutable classes. Since Object is no more shared there is no requirement of Synchronization which can improve scalability and performance of application. ThreadLocal provides thread restriction which is extension of local variable. ThreadLocal are visible only in single thread. No two thread can see each other’s thread local variable. These variable are generally private static field in classes and maintain its state inside thread. void set(Object value), Object get(), void remove() methods are available public class ThreadLocalExample { public static class MyRunnable implements Runnable { private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;(); public void run() { threadLocal.set((int) (Math.random() * 100D)); System.out.println(threadLocal.get()); } } public static void main(String[] args) throws InterruptedException { MyRunnable sharedRunnableInstance = new MyRunnable(); Thread thread1 = new Thread(sharedRunnableInstance); Thread thread2 = new Thread(sharedRunnableInstance); thread1.start(); thread2.start(); thread1.join(); // wait for thread 1 to terminate thread2.join(); // wait for thread 2 to terminate } } ----------- 36 16 This example This example creates a single MyRunnable instance which is passed to two different threads. Both threads execute the run() method, and thus sets different values on the ThreadLocal instance. If the access to the set() call had been synchronized, and it had not been a ThreadLocal object, the second thread would have overridden the value set by the first thread Write code for thread-safe Singleton in Java? When we say thread-safe, which means Singleton should remain singleton even if initialization occurs in the case of multiple threads. public class DoubleCheckedLockingSingleton { private volatile DoubleCheckedLockingSingleton INSTANCE; private DoubleCheckedLockingSingleton() { } public DoubleCheckedLockingSingleton getInstance(){ if(INSTANCE == null){ synchronized(DoubleCheckedLockingSingleton.class){ //double checking Singleton instance if(INSTANCE == null){ INSTANCE = new DoubleCheckedLockingSingleton(); } } } return INSTANCE; } } When to use Runnable vs Thread in Java? (Think Inheritance) it’s better to implement Runnable then extends Thread if you also want to extend another class Difference between Runnable and Callable in Java? Callable was added on JDK 1.5. Main difference between these two is that Callable’s call() method can return value and throw Exception, which was not possible with Runnable’s run() method. Callable return Future object, which can hold the result of computation. class SumTask implements Callable&lt;Integer&gt; { private int num = 0; public SumTask(int num){ this.num = num; } @Override public Integer call() throws Exception { int result = 0; for(int i=1;i&lt;=num;i++){ result+=i; } return result; } } public class CallableDemo { public static void main(String[] args) throws Exception { ExecutorService service = Executors.newSingleThreadExecutor(); SumTask sumTask = new SumTask(20); Future&lt;Integer&gt; future = service.submit(sumTask); Integer result = future.get(); System.out.println(result); } } How to stop a thread in Java? There was some control methods in JDK 1.0 e.g. stop(), suspend() and resume() which are deprecated. We can do it in Two ways 1.Using interrupt() public class Demo { public static void main(String[] args) throws Exception { Runnable runnable = ()-&gt;{ System.out.println(&quot;Running...&quot;); try { Thread.sleep(5000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(&quot;I have Completed ...&quot;); }; Thread t1 = new Thread(runnable); t1.start(); t1.interrupt(); } } Running... I have Completed ... java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at Demo.lambda$0(Demo.java:16) at java.lang.Thread.run(Thread.java:748) In this case we can only stop Sleeping thread. 2.volatile boolean variable In this case we need to use volatile boolean variable, &amp; we need to change value to TRUE if we want to stop a thread. I have a server; I need it to Stop class Server implements Runnable { private volatile boolean stop = false; public void run() { while (!stop) { System.out.println(&quot;Server is running.....&quot;); } System.out.println(&quot;Server is stopped....&quot;); } public void stop() { stop = true; } } public class Demo { public static void main(String[] args) throws Exception { Server myServer = new Server(); Thread t1 = new Thread(myServer, &quot;T1&quot;); t1.start(); // Now, let&#39;s stop our Server thread System.out.println(Thread.currentThread().getName() + &quot; is stopping Server thread&quot;); TimeUnit.MILLISECONDS.sleep(8); myServer.stop(); // Let&#39;s wait to see server thread stopped System.out.println(Thread.currentThread().getName() + &quot; is finished now&quot;); } } Actually we are not stoping the Thread, we just coming out of the run(). Why wait, notify and notifyAll are not inside thread class? Java provides lock at object level not at thread level. Every object has lock, which is acquired by thread. Now if thread needs to wait for certain lock it make sense to call wait() on that object rather than on that thread. Had wait() method declared on Thread class, it was not clear that for which lock thread was waiting. In short, since wait, notify and notifyAll operate at lock level, it make sense to defined it on object class because lock belongs to object. What is the difference between Deadlock, Starvation, and Livelock? Deadlock: is a situation where two more threads are blocked because of waiting for each other forever.one of the possible situation is nested Synchronized blocks. To create simple deadlock situation for a servlet, just place doPost() method inside doGet() and doGet()method inside doPost(). public class Business { private Object lock1 = new Object(); private Object lock2 = new Object(); public void foo() { synchronized (lock1) { synchronized (lock2) { System.out.println(&quot;foo&quot;); } } } public void bar() { synchronized (lock2) { synchronized (lock1) { System.out.println(&quot;bar&quot;); } } } public static void main(String[] args) { Business business = new Business(); Thread t1 = new Thread(new Runnable() { public void run() { business.foo(); } }); t1.start(); Thread t2 = new Thread(new Runnable() { public void run() { business.bar(); } }); t2.start(); } } how to avoid deadlock Avoid acquiring more than one lock at a time. If not, make sure that you acquire multiple locks in consistent order. In the above example, you can avoid deadlock by synchronize two locks in the same order in both methods. public void foo() { synchronized (lock1) { synchronized (lock2) { System.out.println(&quot;foo&quot;); } } } public void bar() { synchronized (lock1) { synchronized (lock2) { System.out.println(&quot;bar&quot;); } } } 2.LiveLock :A real-world example of livelock occurs when two people meet in a narrow corridor (తాడిమట్ట), and each tries to be polite by moving aside to let the other pass, but they end up swaying from side to side without making any progress because they both repeatedly move the same way at the same time. Livelock occurs when two or more processes continually repeat the same interaction in response to changes in the other processes without doing any useful work. These processes are not in the waiting state, and they are running concurrently. This is different from a deadlock because in a deadlock all processes are in the waiting state. public class Test { boolean selected=false; public boolean isSelected() { return selected; } public void setSelected(boolean selected) { this.selected = selected; } public static void main(String args[]) { Test itemOne = new Test(); Test itemTwo = new Test(); Thread tOne = new Thread(new Runnable() { @Override public void run() { while(!itemOne.isSelected()) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } itemTwo.setSelected(true); } }); Thread tTwo = new Thread(new Runnable() { @Override public void run() { while(!itemTwo.isSelected()) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } itemOne.setSelected(true); } }); tOne.start(); tTwo.start(); } } 3. Starvation: describes a situation where a thread holds a resource for a long time so other threads are blocked forever. The blocked threads are waiting to acquire the resource but they never get a chance. Thus they starve to death.BTW, Starvation means suffering or death caused by lack of food. Starvation can occur due to the following reasons: - Threads are blocked infinitely because a thread takes long time to execute some synchronized code (e.g. heavy I/O operations or infinite loop). - A thread doesn’t get CPU’s time for execution because it has low priority as compared to other threads which have higher priority. - Threads are waiting on a resource forever but they remain waiting forever because other threads are constantly notified instead of the hungry ones. When a starvation situation occurs, the program is still running but doesn’t run to completion because some threads are not executed. public class Worker { public synchronized void work() { String name = Thread.currentThread().getName(); String fileName = name + &quot;.txt&quot;; try ( BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)); ) { writer.write(&quot;Thread &quot; + name + &quot; wrote this mesasge&quot;); } catch (IOException ex) { ex.printStackTrace(); } while (true) { System.out.println(name + &quot; is working&quot;); } } public static void main(String[] args) { Worker worker = new Worker(); for (int i = 0; i &lt; 10; i++) { new Thread(new Runnable() { public void run() { worker.work(); } }).start(); } } } //we created 10 threads but, 1st threads run continuously in infinite loop, remaining will die because they won’t get any chance to execute. Finally, - Deadlock: All threads are blocked, the program hangs forever. - Livelock: No threads blocked but they run into infinite loops. The program is still running but unable to make further progress. - Starvation: Only one thread is running, and other threads are waiting forever https://www.codejava.net/java-core/concurrency/understanding-deadlock-livelock-and-starvation-with-code-examples-in-java How do you check if a Thread holds a lock or not? There is a method called holdsLock() on java.lang.Thread, it returns true if and only if the current thread holds the monitor lock on the specified object. Thread t = Thread.currentThread(); System.out.println(Thread.holdsLock(t));//true or flase -checked What is Semaphore in Java? Semaphore in Java is a new kind of synchronizer. It’s a counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphore is used to protect an expensive resource which is available in fixed number e.g. database connection in the pool. What is the difference between the submit() and execute() method thread poolin Java? execute(Runnable command) is defined in Executor interface and executes given task in future, but more importantly, it does not return anything. submit() is an overloaded method, it can take either Runnable or Callable task and can return Future object which can hold the pending result of computation. This method is defined on ExecutorService interface, which extends Executor interface, and every other thread pool class e.g. ThreadPoolExecutor or ScheduledThreadPoolExecutor gets these methods. Which method of Swing API are thread-safe in Java? I know about repaint(), and revalidate() being thread-safe but there are other methods on different swing components e.g. setText() method of JTextComponent, insert() and append() method of JTextArea class. What is the difference between the volatile and atomic variable in Java? For example count++ operation will not become atomic just by declaring count variable as volatile. On the other hand AtomicInteger class provides atomic method to perform such compound operation atomically e.g. getAndIncrement() is atomic replacement of increment operator. It can be used to atomically increment current value by one. Similarly, you have atomic version for other data type and reference variable as well. What happens if a thread throws an Exception inside synchronized block? To answer this question, no matter how you exist synchronized block, either normally by finishing execution or abruptly by throwing exception, thread releases the lock it acquired while entering that synchronized block. How do you ensure that N thread can access N resources without deadlock? Key point here is order, if you acquire resources in a particular order and release resources in reverse order you can prevent deadlock. What’s the difference between Callable and Runnable? Both of these are interfaces used to carry out task to be executed by a thread. The main difference between the two interfaces is that Callable can return a value, while Runnable cannot. Callable can throw a checked exception, while Runnable cannot. Runnable has been around since Java 1.0, while Callable was introduced as part of Java 1.5. The Callable interface is a generic interface containing a single call() method – which returns a generic value V: public interface Callable&lt;V&gt; { V call() throws Exception; } class CallableExample implements Callable { public Object call() throws Exception { Random generator = new Random(); Integer randomNumber = generator.nextInt(5); Thread.sleep(randomNumber * 1000); return randomNumber; } } What is false sharing in the context of multi-threading? false sharing is one of the well-known performance issues on multi-core systems, where each process has its local cache. False sharing is very hard to detect because the thread may be accessing completely different global variables that happen to be relatively close together in memory. Like many concurrency issues, the primary way to avoid false sharing is careful code review and aligning your data structure with the size of a cache line Object level and Class level locks in Java Object level lock - Every object in java has a unique lock. Whenever we are using synchronized keyword on instance methods, then only lock concept will come in the picture. If a thread wants to execute synchronized method on the given object. First, it has to get lock of that object. Once thread got the lock then it is allowed to execute any synchronized method on that object. Once method execution completes automatically thread releases the lock. Acquiring and release lock internally is taken care by JVM and programmer is not responsible for these activities. Lets have a look on the below program to understand the object level lock: class Geek implements Runnable { public void run() { Lock(); } public void Lock() { System.out.println(Thread.currentThread().getName()); synchronized(this) { System.out.println(&quot;in block &quot; + Thread.currentThread().getName()); System.out.println(&quot;in block &quot; + Thread.currentThread().getName() + &quot; end&quot;); } } public static void main(String[] args) { Geek g = new Geek(); Thread t1 = new Thread(g); Thread t2 = new Thread(g); Geek g1 = new Geek(); Thread t3 = new Thread(g1); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t3.setName(&quot;t3&quot;); t1.start(); t2.start(); t3.start(); } } Run on IDE Output: t1 in block t1 in block t1 end t2 in block t2 in block t2 end t3 in block t3 in block t3 end //only one thread is running Class level lock - Every class in java has a unique lock which is nothing but class level lock. If a thread wants to execute a static synchronized method, then thread requires class level lock. Once a thread got the class level lock, then it is allowed to execute any static synchronized method of that class. Once method execution completes automatically thread releases the lock. Lets look on the below program for better understanding: // Java program to illustrate class level lock class Geek implements Runnable { public void run() { Lock(); } public void Lock() { System.out.println(Thread.currentThread().getName()); synchronized(Geek.class) { System.out.println(&quot;in block &quot; + Thread.currentThread().getName()); System.out.println(&quot;in block &quot; + Thread.currentThread().getName() + &quot; end&quot;); } } public static void main(String[] args) { Geek g1 = new Geek(); Thread t1 = new Thread(g1); Thread t2 = new Thread(g1); Geek g2 = new Geek(); Thread t3 = new Thread(g2); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t3.setName(&quot;t3&quot;); t1.start(); t2.start(); t3.start(); } } Producer-Consumer solution using threads in Java The producer’s job is to generate data, put it into the buffer, and start again. same time, the consumer is consuming the data (i.e. removing it from the buffer), one piece at a time. producer won’t try to add data into the buffer if it’s full &amp; consumer won’t try to remove data from an empty buffer class Producer extends Thread { List buffer; int maxsize; public Producer(List buffer, int maxsize) { this.buffer = buffer; this.maxsize = maxsize; } @Override public void run() { int i = 1; while (true) { synchronized (buffer) { try { if (buffer.size() == maxsize) { System.out.println(&quot;Maximum Size Reached, wait until consume&quot;); buffer.wait(); } else { buffer.add(i++); System.out.println(i + &quot; : Produced, notify wating COnsumer Thread&quot;); buffer.notifyAll(); } } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } class Consumer extends Thread { List buffer; int maxsize; public Consumer(List buffer, int maxsize) { this.buffer = buffer; this.maxsize = maxsize; } @Override public void run() { while (true) { try { synchronized (buffer) { if (buffer.isEmpty()) { System.out.println(&quot;Consumer : Buffer Empty, wait untill produce&quot;); buffer.wait(); } else { Object ob = buffer.remove(0); System.out.println(ob + &quot; : Removed, notify Producer waiting for Removing for maxsize&quot;); buffer.notifyAll(); } } } catch (Exception e) { // TODO: handle exception } } } } public class ProducerConsumer { public static void main(String[] args) { List buffer = new LinkedList&lt;&gt;(); Producer producer = new Producer(buffer, 10); Consumer consumer = new Consumer(buffer, 10); producer.start(); consumer.start(); } } 28054 : Produced, notify wating COnsumer Thread 28055 : Produced, notify wating COnsumer Thread 28056 : Produced, notify wating COnsumer Thread 28057 : Produced, notify wating COnsumer Thread 28058 : Produced, notify wating COnsumer Thread 28059 : Produced, notify wating COnsumer Thread 28060 : Produced, notify wating COnsumer Thread Maximum Size Reached, wait until consume 28050 : Removed, notify Producer waiting for Removing for maxsize 28051 : Removed, notify Producer waiting for Removing for maxsize 28052 : Removed, notify Producer waiting for Removing for maxsize 28053 : Removed, notify Producer waiting for Removing for maxsize 28054 : Removed, notify Producer waiting for Removing for maxsize 28055 : Removed, notify Producer waiting for Removing for maxsize 28056 : Removed, notify Producer waiting for Removing for maxsize 28057 : Removed, notify Producer waiting for Removing for maxsize 28058 : Removed, notify Producer waiting for Removing for maxsize 28059 : Removed, notify Producer waiting for Removing for maxsize Consumer : Buffer Empty, wait untill produce What is BlockingQueue? implement Producer-Consumer using Blocking Queue? A BlockingQueue is typically used when one thread will produce objects, another thread consumes those Objects. A BlockingQueue with one thread putting into it, and another thread taking from it.   Throws Exception Special Value Blocks Times Out Insert add(o) offer(o) put(o) offer(o, timeout, timeunit) Remove remove(o) poll() take() poll(timeout, timeunit) Examine element() peek()     BlockingQueue in Java doesn’t allow null elements, various implementations like ArrayBlockingQueue, LinkedBlockingQueue throws NullPointerException when you try to add null on queue two types of BlockingQueue: ```java a. Bounded queue – with maximal capacity defined BlockingQueue blockingQueue = new LinkedBlockingDeque&lt;&gt;(10); b. UnBounded queue –no maximum capacity, can grow almost indefinitely BlockingQueue blockingQueue = new LinkedBlockingDeque&lt;&gt;(); &lt;u&gt;Producer-Consumer Example&lt;/u&gt; BlockingQueue provides a **put()** method to store the element and **take()** method to retrieve the element. Both are blocking method, which means **put()** will block if the queue has reached its capacity and there is no place to add a new element. Similarly **, take()** method will block if blocking queue is empty. So, you can see that critical requirement of the producer-consumer pattern is met right there, you don&#39;t need to put any thread synchronization code. ```java class Producer extends Thread { private BlockingQueue&lt;Integer&gt; sharedQueue; public Producer(BlockingQueue&lt;Integer&gt; aQueue) { super(&quot;PRODUCER&quot;); this.sharedQueue = aQueue; } public void run() { // no synchronization needed for (int i = 0; i &lt; 10; i++) { try { System.out.println(getName() + &quot; produced &quot; + i); sharedQueue.put(i); Thread.sleep(200); // if we remove sleep, put will execute 10 times, then take will execute } catch (InterruptedException e) { e.printStackTrace(); } } } } class Consumer extends Thread { private BlockingQueue&lt;Integer&gt; sharedQueue; public Consumer(BlockingQueue&lt;Integer&gt; aQueue) { super(&quot;CONSUMER&quot;); this.sharedQueue = aQueue; } public void run() { try { while (true) { Integer item = sharedQueue.take(); System.out.println(getName() + &quot; consumed &quot; + item); } } catch (InterruptedException e) { e.printStackTrace(); } } } public class BlockingQueueDemo { public static void main(String[] args) { BlockingQueue&lt;Integer&gt; sharedQ = new LinkedBlockingQueue&lt;Integer&gt;(); Producer p = new Producer(sharedQ); Consumer c = new Consumer(sharedQ); p.start(); c.start(); } } ArrayBlockingQueue – a blocking queue class based on bounded Java Array. Once instantiated, cannot be resized. PriorityBlockingQueue – a priority queue based blocking queue. It is an unbounded concurrent collection. LinkedBlockingQueue – an optionally bounded Java concurrent collection. Orders elements based on FIFO order. Thread. yield () yield() method: Theoretically, to ‘yield’ means to let go, to give up, to surrender. A yielding thread tells the virtual machine that it’s willing to let other threads be scheduled in its place. This indicates that it’s not doing something too critical. Note that it’s only a hint, though, and not guaranteed to have any effect at all. Yield is a Static method and Native too. Yield tells the currently executing thread to give a chance to the threads that have equal priority in the Thread Pool. There is no guarantee that Yield will make the currently executing thread to runnable state immediately. It can only make a thread from Running State to Runnable State, not in wait or blocked state. What do you understand about Thread Priority? Every thread has a priority; usually higher priority thread gets precedence in execution but it depends on Thread Scheduler implementation that is OS dependent. We can specify the priority of thread but it doesn’t guarantee that higher priority thread will get executed before lower priority thread. How can we make sure main() is the last thread to finish in Java Program? We can use Thread join() method to make sure all the threads created by the program is dead before finishing the main function. Why wait(), notify() and notifyAll() methods have to be called from synchronized method or block? When a Thread calls wait() on any Object, it must have the monitor on the Object that it will leave and goes in wait state until any other thread call notify() on this Object. Similarly when a thread calls notify() on any Object, it leaves the monitor on the Object and other waiting threads can get the monitor on the Object. Since all these methods require Thread to have the Object monitor, that can be achieved only by synchronization, they need to be called from synchronized method or block. How can we achieve thread safety in Java? There are several ways to achieve thread safety in java – synchronization, atomic concurrent classes, implementing concurrent Lock interface, using volatile keyword, using immutable classes and Thread safe classes. What is volatile keyword in Java When we use volatile keyword with a variable, all the threads read it’s value directly from the memory and don’t cache it. This makes sure that the value read is the same as in the memory. What is ThreadLocal? Java ThreadLocal is used to create thread-local variables. We know that all threads of an Object share it’s variables, so if the variable is not thread safe, we can use synchronization but if we want to avoid synchronization, we can use ThreadLocal variables. Every thread has it’s own ThreadLocal variable and they can use it’s get() and set() methods to get the default value or change it’s value local to Thread. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread What is Java Thread Dump, How can we get Java Thread dump of a Program? Thread dump is list of all the threads active in the JVM, thread dumps are very helpful in analyzing bottlenecks in the application and analyzing deadlock situations. There are many ways using which we can generate Thread dump – Using Profiler, Kill -3 command, jstack tool etc. I prefer jstack tool to generate thread dump of a program because it’s easy to use and comes with JDK installation What is atomic operation? What are atomic classes in Java Concurrency API? Atomic operations are performed in a single unit of task .int++ is not an atomic operation. So by the time one threads read it’s value and increment it by one, other thread has read the older value leading to wrong result. To solve this issue, we will have to make sure that increment operation on count is atomic, we can do that using Synchronization but Java 5 java.util.concurrent.atomic provides wrapper classes for int and long that can be used to achieve this atomically without usage of Synchronization What is Executors Class? Executors class provide utility methods for Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, and Callable classes. Executors class can be used to easily create Thread Pool in java, also this is the only class supporting execution of Callable implementations. What happens when an Exception occurs in a thread? Thread.UncaughtExceptionHandler is an interface, defined as nested interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception. When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler’s uncaughtException() method, passing the thread and the exception as arguments. Why wait, notify and notifyAll are not inside thread class? One reason which is obvious is that Java provides lock at object level not at thread level. How do you check if a Thread holds a lock or not? Boolean Thread.holdsLock(Obj) What is FutureTask in Java? (answer) This class provides a base implementation of Future, it retrieve the result of the computation. It will get the results from Feature Object. What is the concurrency level of ConcurrentHashMap in Java? (answer) ConcurrentHashMap achieves it’s scalability and thread-safety by partitioning actual map into a number of sections. This partitioning is achieved using concurrency level. Its optional parameter of ConcurrentHashMap constructor and it’s default value is 16. The table is internally partitioned to try to permit the indicated number of concurrent updates without contention. To learn more about concurrency level and internal resizing What happens if a thread throws an Exception inside synchronized block? To answer this question, no matter how you exist synchronized block, either normally by finishing execution or abruptly by throwing exception, thread releases the lock it acquired while entering that synchronized block. This is actually one of the reasons I like synchronized block over lock interface, which requires explicit attention to release lock, generally this is achieved by releasing the lock in a finally block.","url":"/Java-Interview-Questions-2.html","headline":"Java - Interview Questions PART-2","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- start custom head snippets -->

<!-- end custom head snippets --><script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.isFormElement = function(node) {
    var tagName = node.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i;
      loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cbs[i]();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();
(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();
(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();
</script><script>
  (function() {
    var TEXT_VARIABLES = {
      version: '2.2.4',
      sources: {
        font_awesome: 'https://use.fontawesome.com/releases/v5.0.13/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        valine: 'https://unpkg.com/valine/dist/Valine.min.js',
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3'
        }
      },
      paths: {
        search_js: '/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script></head>
  <body>
    <div class="root" data-is-touch="false">
      <div class="layout--page js-page-root"><div class="page__main js-page-main page__viewport has-aside cell cell--auto">

      <div class="page__main-inner"><div class="page__header d-print-none"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="76px" height="76px" viewBox="0 0 76 76" enable-background="new 0 0 76 76" xml:space="preserve">  <image id="image0" width="76" height="76" x="0" y="0"
    xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEwAAABMCAIAAABI9cZ8AAAAIGNIUk0AAHomAACAhAAA+gAAAIDo
AAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQflBwgJKRMy4DHU
AAAAXnRFWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMACmlwdGMKICAgICAgMjgKMzg0MjQ5NGQwNDA0
MDAwMDAwMDAwMDBmMWMwMjZlMDAwMzUyNDY0NzFjMDIwMDAwMDIwMDA0MDAKYJo9ngAAD4RJREFU
eNrtm2tsE1fax894Lp7xeGzHzgUSbNI0YJJwSQKEWxWlUWkSKEIqq20RsBUrtewXpBatSlu1WvVT
F7XbW1RKqxaqCiEl25KkYUkpYlPEQrkkAsIlgZAEcnOcOAQntseeGXveD09z3sFODLm1+/JyhCxn
PHPm/M7znHOe838OhKqq6FEvut+7AY8hH0M+hnwM+UiWx5CPSqF+rxePGYQQBPEoQEYiEcyjqqqq
qgAWiUTgCkEQcAV/+W+HxOZSVXVkZGR4eJiiKFmWRVHs6upiWTYQCJw6dSonJyc3N1eW5cTERIZh
jEYjEOp0Op1ON3VUYiZiV6gTLCNJksvlunXr1ldffXXlyhWLxRIIBHw+3+DgIMMwCKGBgQGj0ZiW
liaKYkZGhiAI69atKygoyMzMhBtIkpwi6jRDgr8pijI8PNzT09PY2Hjq1KnGxka32+12u8cbh1HX
OY7Lysp6+eWXZ8+evXz5covFQtM0oE6+WdNSIpGIqqqiKN68eXPv3r1lZWVPPvkkwzCTsAD4Ksdx
FoulvLx8YGDA6/WGQqFwODy5tk0DJOD5/f76+vo33ngjMzOT53ltcyfpYwSBEFq4cOHRo0fdbvfw
8LAkSfCu3xQSXhkKhVpbW997772UlBTsUdMyMUIlq1atOnnypNvt9vl8sixPgnOSs6uqqgghWZab
mpoqKirq6upaW1slScJsaszwg5+iroOpteuK9nFVVQmCOHv2bE1Njd1upyiKoqhJTEKTgYQWuFyu
r7/++sCBA52dneFweDwGbYsRQiaTyWq1UhQlCILFYrHZbAzDeDwer9fb3d3d398vy3Is8KVLlzwe
D8Mwer2eoibc5gk/AF56/vz5d999t76+HlsvFu/X8YCQIAjp6enp6enJyclZWVmzZ8+madpoNHIc
R9O0TqeLRCKyLLtcrjt37nR1dd2+ffvMmTP37t3DnFevXm1vb09MTJRlmWGYiRpzYpCqqsqyXFtb
+/bbb7e0tICzafG0fyYkJGRnZ6empi5ZsiQrKyshIYFlWVgM4BMvgPBUWlpafn6+JEmBQKC6uvrz
zz/3er3wqyiKfX19kiTBmJwpS8LwcLvd+/bt++KLL/r6+mLXN+jd5ORkg8HgdDqfeeYZp9MpCALL
sgzDgLMxDANDCwixTcBBwuGwLMuCIGzbto2iqI8//tjn88HC6/V6FUUJh8Mw8Uy/JaHSO3fu7N69
u6qqClwUE+JWkiSZlpa2detWp9OZkpIiCIJer2dZlmVZLZ5OpyNJktAUpFmugZPjuNTUVJZlfT4f
QogkSb1ejwlnxJIEQbS3t7/++uvV1dXhcBhpAjf4TlFUenp6cXHx0qVL582bx/M8x3EcxwEeTdPY
PyEixc9qDfLrdE9RDMNcvXr1o48+8ng8cIOiKD6fDw/y6YdUVdXj8bz11ltVVVVjDr/09PSSkpKV
K1c6HA6e5w0GA3wCHvZMrd3G60pc54ULFzo6OrSdKAgCuPf0Q6qqGgwGP/jgg6qqqthdkiAICxYs
ePHFF3NzczmO43neaDQaDAYYhFq8h28QLJt5eXlz585ta2tDCJEkuXr16kWLFuG5aqKQ8QJ0+Km2
tvaVV15xu924EfC5ePHiDRs25OfnW61WQRCMRiOsCpPGwyUcDkuSVFlZ+emnn4qiuHLlyg0bNjgc
joSEBKvVajAYaJqeWMfF9/L29vatW7f+8ssveEerqqpery8qKtqyZcucOXN4ngdCMCDeLkwlrItE
IpIk+Xy+rq4ur9drNBppmuZ53mQyGY1GvV5PkuSEKhzXXcEhq6qqLly4oCUkSbKsrGzbtm1JSUkm
kwlejP1zeva4BEFRFMdxDocjFAopigKzKwQPk6g/3pj0er11dXWKomjrLSwsfOGFF5KSkhISEiwW
C8/zYEA8tUyRECCBCj6hf/HyM4kxGQ+yt7e3s7MTaUK2RYsWbd68efbs2Waz2WKxwEI/XQaM5QQ2
NDrxTroTx4UkCKK3t3doaAhfYVm2rKwM1okoA6LRgGHaOaelqnhjUhAEjuPwlVAodPjwYbfbvWLF
ihUrVpjNZu2eTbtjQvdvl2dIaJxAf403u4bD4Xv37u3YseP777/X7npIkuR5fsGCBcuWLTMajYsX
LxZFMTk52WazzZkzh2EYHOVoIafibDMLqSjK6dOnd+3a1dTUhCGjolaWZRVFMRgMBoPB4XDQNG02
mzMyMkpKSpJGC1Z6sNCIflvzjgsJu6pAIHDx4sU9e/acOnUqGAyCBKy9Z+xKCQIWT7vdXlRUNGvW
rJycnHnz5hmNRp7nYYbEMfrvDBmJREKhkCiKnZ2dDQ0Np0+fPnnyZHd3t6IoGOaBModOp6MoymKx
2O12q9W6ffv2oqIiQRAgKvptUB8Q1oXD4VAoFAwGRVH0er23bt26fPny7du3m5ub29vbQSkcky0K
G19PS0tzOp2lpaXPP/98cnIyRVEQJM0o5wPCukgkAtqEJEnBYDAUCkmSJIri0NBQd3d3U1PT9evX
dTrd9evXOzo6sIXHfdkorV6vX7t27e7du7OzsyFamlHOByvo4LeRSERRFKAFGUJRFDCyLMs9PT2n
T59uampyuVwDAwMejyeOSIFh1qxZ8/7778+bN4/juElEpNMJiVGxQgEFmPGnoigjIyNer7erq+vK
lStXrly5du2a2+0GIW/MoUsQxGuvvbZz505BEHien5zcPp2QsbS4YGBt8fv9bW1tdXV1J06ccLlc
ODOnhVRVddWqVZ988klaWprZbGZZ9mGMqZVkH7JTJixJ4rUuSqXG5gVgQRBsNltOTs7GjRtramoO
Hz4Mak1UW/v6+vr6+pKSkhRFgY7A+sB4GKqqhhUFEQRomQ+T3pt8flLbAlAowLAYWJZlnufNZvP8
+fMTEhL27t2rKEqs42CHhxYPDg663e6UlBSTyQTLKQQP8GC4rQ1VVKC2NmSxhEpLwwUFJMOQJPmA
TcJUciGxRevAoKAODQ253e6qqqqEhITYt+fl5dXV1bW0tPT399+4ceOzzz4rLS1NS0vbtWvXwMCA
z+eTJAlEurCiSGfPKsXFEZJUEYoQhJyaeu9vf/PcvOn1egOBQJw0yTRnmrUaHLaDXq93uVyBQCAq
JFRV9YknnmBZtr29/eDBgz/88MPNmzeDwSBCqKOjw+v14hoig4NqRQVZXk60tiKEVIJACJG9vaa/
/108c2bk1VelggJQXsYUgWYwnQ6oNE03Nzd/++23OGzAHgTN2r9//5kzZ27fvg1iJ0LIaDSuWbMG
lB69Xk96vcSbb1KHDhGhEOARMPcQBAqFDMePI5dr8B//UPPyQJoZYyRPr7vGeu/du3e3b98+Zi+w
LGu1WnG8jluWlZV1+PDha9eu9fb2BgKB0IEDEZZVCSJCECpC2n8RhCIEEUHo7vr1HU1N/f39fr8f
Rr62zOA5HlVVJUnau3dvZWXlmFNCMBi8e/euOrrbVlWVZdm1a9fu3LkTkkIURSFZ1v3730QwiA14
n7MgRKgqgZCpvp6orfX7/RCcRN02U+4K08+xY8f27dvn9/vHm/cwHk3Ts2bN2rhxY0lJSWJiIoQH
er2ecLmIxkbos3FfRhBkIJB48OCA0xkoKNDpdCzLziAknlcURamsrHznnXe6u7vHi3jAl0iSzMzM
LC4uzs/Ph1S8IAgmk4nneZqmdf/6l66tDXaxcd6KCIJvbibefHPor3/1rVtnsVhmBBJjyLLc2tpa
UVHx5Zdfut3uMQnhfrPZ7HQ6Fy9eXFhY6HA4IH0Ce06Yk3R9fURFBZ5v4r0dIYIgDK2tuj17+m02
NGfOdEJqTdfT03P27NlLly7V1tbeuHEjNmqFPymKMhgMdrt906ZNy5YtM5vNgAdsoJ7AblPp6KBa
WtSxRmNUwfOtvqODPnIEbdo0PZDqaGIrFApdvny5pqbm2LFjzc3NcBYlKj+Lv9vt9qeffnrJkiVz
585NTk7mOA6kE9iIMAxzn4SLD3TFd1ctLUJUe3vUxcmfGUAIBYPBixcvfvfdd1VVVZ2dnVpxJMpF
wTmLi4ufffZZGHjcaNGm97SBaDgcjjid0lNPMUePTmhvEonpjgmn09FoqquhoeHQoUNHjhzp6elB
YykD+IrFYsnKyiotLS0oKDCZTNrcHuBFZZ3/t1itob/8hWxooPr7H9KMCssO5uWlTA4S4w0ODv70
008nTpw4fvx4T0+POqrfjYnHMExubu7GjRsXLlxotVo5joO1AeYVbXYodo2B65GCAmn1aqq6+oEe
CzfcnT/f89RTE7YktD4YDHZ2dv744481NTUNDQ0jIyPxrYcQSkpKWr9+fVlZWUpKCqQu8dSiTTzH
ebVOp2MEQdq8Wf+f/5AezwObqrBsT0kJSokyZFxIaKsoiufOnfvmm28aGxtv3LgBQk6s9bRPWa3W
lStXFhcXL1myBPKWgiDg5OzD4KHRNEE4HEZFRf4//9lYXq4TxXh3q6pr+fJ7q1bx90cC40JC6wOB
wLlz5yorK48cOdLb24t3sbF42IA6nS4zM3Pbtm1Lly4Fz8T+CQvDhJJfvyazDIbAjh1hv9+8f79O
FMf2W1X1Ohydf/wjk5RkNBofDAkM169f//DDD+vq6uAI53iKo3YXn52dXVxcvGzZsvT0dIynTc5O
VGIFCYKmab3NJr766l2WtXz1FeX1otHVBTfLn5TU8qc/STk5VqNREIToesZ0ua6urpdeeunnn39W
788LjGk9juNSUlLy8/Ofe+65jIwMfHgAZ76mmNsDkUEURdHrRdXVln37uNZWYlQNjJDksMNxc8uW
kaIiOMdmNpujNuhju2tbW9v58+dRjEYe9afBYMjNzS0sLMzJyZk1axacGcB4OHCZogYHxoTv/j/8
wb1gAffPfxoaGwm/P2ixDC1aNFBYGMnIsAqC2WyGlGlUDWND2mw2u93e0tIS+5PBYLBYLKmpqVlZ
WdnZ2dnZ2VarFU4kQeCiXR6mJQWAnRaAxdzcQEbGiNsdGh6W9HqJ51mGgc7F5/Wia4h1xXA4HAwG
6+vry8vLL126BHvQ5ORkh8Nht9vT09Ptdjs+cEXTNMuyOHCZ+tGP8QqMfJCOQqEQaPkQP9I0rR8t
2rxwPEjIC4RCoa6uro6OjqGhIVmWbTYbeAKMMYjCgAoHZTinP3OCP9byQSuDKQNySnHePgakqqqg
r0CeJxgMYlEU6sKc+ChgnMBl2kuUtIFFszhvH3ezp9XFIbEBqzNGwt32+2aRH6bEy09iHRXvqqIK
+i84DzAlSIx6393/F5AmDPlolP8X/7XwMeSjUh5DPirlfwA1QTCTlERFOgAAACV0RVh0ZGF0ZTpj
cmVhdGUAMjAyMS0wNy0wOFQxNzo0MDozOCswMzowMN3pZPAAAAAldEVYdGRhdGU6bW9kaWZ5ADIw
MjEtMDctMDhUMTc6NDA6MzgrMDM6MDCstNxMAAAAAElFTkSuQmCC" />
</svg>
<a title="Tutorials, Java Tutorials,DevOps Tutorials,Spring Tutorial,SpringBoot Tutorials, Docker,Chef,Jenkins,Git,BitBucket,Bamboo,AWS,Kubernetes,Puppet,Ansible,Nagios." href="/">SatyaCodes</a></div><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></div><nav class="navigation">
        <ul><li class="navigation__item"><a href="/posts.html">AllPosts</a></li><li class="navigation__item"><a href="/tutorials.html">Tutorials</a></li><li class="navigation__item"><a href="/java.html">Java</a></li><li class="navigation__item"><a href="/devops.html">DevOps</a></li><li class="navigation__item"><a href="/books.html">Books</a></li><li class="navigation__item"><a href="/interview-questions.html">InterviewQ's</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li></ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class ="main"><div class="grid grid--reverse">

              <div class="col-aside d-print-none js-col-aside"><aside class="page__aside js-page-aside"><div class="toc-aside js-toc-root"></div></aside></div>

              <div class="col-main cell cell--auto"><!-- start custom main top snippet -->

<!-- end custom main top snippet --><article itemscope itemtype="http://schema.org/Article"><div class="article__header"><header><h1>Java - Interview Questions PART-2</h1></header></div><meta itemprop="headline" content="Java - Interview Questions PART-2"><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=Interview">Interview</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Nov 11, 2017</span>
            </li></ul></div><meta itemprop="author" content="Satya Kaveti"/><meta itemprop="datePublished" content="2017-11-11T00:00:00+00:00">
    <meta itemprop="keywords" content="Interview"><div class="js-article-content"><div class="layout--article"><!-- start custom article top snippet -->

<!-- end custom article top snippet --><div class="article__content" itemprop="articleBody"><h1 id="strings">Strings</h1>

<h2 id="1what-is-immutable-object-can-you-write-immutable-object">1.What is immutable object? Can you write immutable object?</h2>

<p><strong>Class –<code class="language-plaintext highlighter-rouge">Final</code>, Private Variables –<code class="language-plaintext highlighter-rouge">Final</code>, Public params Constructor, <code class="language-plaintext highlighter-rouge">Only
getters</code></strong></p>

<p>Immutable classes are Java classes whose objects cannot be modified once
created.</p>

<ol>
  <li>
    <p>Declare <strong>the class as final</strong> so it can’t be extended.</p>
  </li>
  <li>
    <p>Make all <strong>fields private &amp; final</strong> so that direct access is not allowed &amp;
it’s values can be assigned only once.</p>
  </li>
  <li>
    <p><strong>Initialize</strong> all the fields via a <strong>constructor</strong></p>
  </li>
  <li>
    <p>Write <strong>getters only, not setters</strong>.</p>
  </li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An immutable class</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
	<span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">final</span> <span class="kt">int</span> <span class="n">regNo</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">regNo</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
 <span class="k">this</span><span class="o">.</span><span class="na">regNo</span> <span class="o">=</span> <span class="n">regNo</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
 <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getRegNo</span><span class="o">()</span> <span class="o">{</span>
 <span class="k">return</span> <span class="n">regNo</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Driver class</span>
<span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
 <span class="nc">Student</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">(</span><span class="s">"ABC"</span><span class="o">,</span> <span class="mi">101</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">regNo</span><span class="o">);</span>

 <span class="c1">// Uncommenting below line causes error</span>
 <span class="c1">// s.regNo = 102;</span>
<span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Error</span><span class="o">:</span> <span class="nc">Unresolved</span> <span class="n">compilation</span> <span class="nl">problem:</span> 
	<span class="nc">The</span> <span class="kd">final</span> <span class="n">field</span> <span class="nc">Student</span><span class="o">.</span><span class="na">regNo</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">assigned</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="2what-is-singleton-can-you-write-critical-section-code-for-singleton">2.What is Singleton? Can you write critical section code for singleton?</h2>

<p><strong>A Singleton class is one which allows us to create only one object for JVM.</strong></p>

<p><strong>Private Constructor, Private Object, Public Static Factory Method</strong></p>

<p><strong>Rules:</strong></p>

<ul>
  <li>
    <p>Create Singleton class <strong>Object make it as PRIVATE</strong></p>
  </li>
  <li>
    <p>Create <strong>PRIVATE constructor</strong></p>
  </li>
  <li>
    <p>Every Singleton class contains <strong>at least one factory method</strong>
```java
class Student {
private static Student st;</p>

    <p>private Student() {
 System.out.println(“OBJECET Created FIRST TIME”);
}</p>

    <p>public static Student getObject() {
 if (st == null) {
 	st = new Student();
 } else {
 	System.out.println(“OBJECET ALREDAY CREATED”);
 }
 return st;
}
}</p>
  </li>
</ul>

<p>public class Singleton {
	public static void main(String[] args) {
 Student s1 = Student.getObject();
 Student s2 = Student.getObject();
 System.out.println(s1.hashCode());
 System.out.println(s2.hashCode());
	}
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
In above code, it will create multiple instances of Singleton class if called by
more than one thread parallel

 `Double checked locking of Singleton` is a way to ensure only one instance of
Singleton class is created through application life cycle.

This will bring us to **double checked locking pattern**, where only critical
section of code is locked. Programmer call it double checked locking because
**there are two checks**

-   **for \_instance == null, one without locking and**

-   **other with locking (inside synchronized) block.**

Here is how double checked locking looks like in Java
```java
public static Singleton getInstanceDC() {
        if (_instance == null) {                // Single Checked
            synchronized (Singleton.class) {
                if (_instance == null) {        // Double checked
                    _instance = new Singleton();
                }
            }
        }
        return _instance;
}
</code></pre></div></div>

<ul>
  <li>
    <p><strong>For Cloning</strong> – we need to Ovveride <strong>clone()</strong> method &amp; Should throw
<strong>CloneNotSupportException</strong></p>
  </li>
  <li>
    <p><strong>For Reflection</strong> - we need to throw <strong>RuntimeException(unchekd)</strong> in
<strong>private Constructor</strong></p>
  </li>
</ul>

<h2 id="clone-will-create-new-object-of-singleton-class">Clone() will create new Object of Singleton Class?</h2>

<p><a href="https://www.geeksforgeeks.org/clone-method-in-java-2/">Cloning</a> is a concept to
create duplicate objects. <strong>Using clone we can create copy of object</strong>. Suppose,
we ceate clone of a singleton object, then it wil create a copy that is there
are two instances of a singleton class, <code class="language-plaintext highlighter-rouge">hence the class is no more
singleton</code>.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="kd">throws</span> <span class="nc">CloneNotSupportedException</span> <span class="o">{</span>
 
 <span class="nc">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Student</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
 <span class="nc">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">Student</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
 
 <span class="nc">Student</span> <span class="n">s3</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Student</span><span class="o">)</span> <span class="n">s1</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s3</span><span class="o">);</span>

	<span class="o">}</span>
<span class="nc">Student</span><span class="err">@</span><span class="mi">15</span><span class="n">db9742</span>
<span class="nc">Student</span><span class="err">@</span><span class="mi">15</span><span class="n">db9742</span>
<span class="nc">Student</span><span class="err">@</span><span class="mi">6</span><span class="n">d06d69c</span> <span class="c1">// Creates new Object, our singleton failed.</span>
</code></pre></div></div>

<p>To overcome this, we should override clone() method, it should throw Exception,
anyone tries to do clone</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="kd">implements</span> <span class="nc">Cloneable</span><span class="o">{</span>
	<span class="err">………</span><span class="o">.</span>
       <span class="nd">@Override</span>
	<span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">CloneNotSupportedException</span> <span class="o">{</span>
 <span class="k">throw</span> <span class="k">new</span> <span class="nf">CloneNotSupportedException</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="kd">throws</span> <span class="nc">CloneNotSupportedException</span> <span class="o">{</span> 
 <span class="nc">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Student</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
 <span class="nc">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">Student</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
 
 <span class="nc">Student</span> <span class="n">s3</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Student</span><span class="o">)</span> <span class="n">s1</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s3</span><span class="o">);</span>

	<span class="o">}</span>
<span class="o">}</span>
<span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">CloneNotSupportedException</span> <span class="c1">//We are GOOD now</span>
	<span class="n">at</span> <span class="nc">Student</span><span class="o">.</span><span class="na">clone</span><span class="o">(</span><span class="nc">Student</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">25</span><span class="o">)</span>
	<span class="n">at</span> <span class="nc">Student</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">Student</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">33</span><span class="o">)</span>
</code></pre></div></div>

<p><strong>Reflection:</strong> You can make the new instance of the Singleton class by changing
the <strong>constructor visibility as public</strong> in run-time and create new instance
using that constructor .</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="kd">throws</span> <span class="nc">InstantiationException</span><span class="o">,</span> <span class="nc">IllegalAccessException</span><span class="o">,</span> <span class="nc">IllegalArgumentException</span><span class="o">,</span> <span class="nc">InvocationTargetException</span> <span class="o">{</span>
 
 <span class="nc">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Student</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
 <span class="nc">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

<span class="c1">//1.Making Construtor visible	</span>
 <span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;[]</span> <span class="n">constructors</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;[])</span> <span class="nc">Student</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructors</span><span class="o">();</span> 
        <span class="k">for</span> <span class="o">(</span><span class="nc">Constructor</span> <span class="n">constructor</span> <span class="o">:</span> <span class="n">constructors</span><span class="o">)</span>  
        <span class="o">{</span> 
            <span class="c1">// Below code will destroy the singleton pattern </span>
            <span class="n">constructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> 
            <span class="n">s2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Student</span><span class="o">)</span> <span class="n">constructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span> 
            
        <span class="o">}</span> 
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>

<span class="c1">//Using Class of newInstance()</span>
             <span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Student</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
 <span class="nc">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Student</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
 <span class="nc">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Student</span><span class="o">)</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
 
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span> <span class="c1">// Student@15db9742</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span> <span class="c1">// Student@6d06d69c -Failed again </span>

	<span class="o">}</span>
<span class="nc">Student</span><span class="err">@</span><span class="mi">15</span><span class="n">db9742</span>
<span class="nc">Student</span><span class="err">@</span><span class="mi">6</span><span class="n">d06d69c</span> <span class="c1">//Failed again </span>
</code></pre></div></div>

<p>To prevent Singleton failure while due to reflection you have to <strong>throw a
run-time exception in constructor</strong>, if the constructor is already initialized .</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="kd">implements</span> <span class="nc">Cloneable</span><span class="o">{</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Student</span> <span class="n">st</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nf">Student</span><span class="o">()</span> <span class="o">{</span>
 <span class="k">if</span><span class="o">(</span><span class="n">st</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span>
 	<span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Go Fucker....."</span><span class="o">);</span>
	<span class="o">}</span>
<span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">RuntimeException</span><span class="o">:</span> <span class="nc">Go</span> <span class="nc">Fucker</span><span class="o">.....</span>
	<span class="n">at</span> <span class="nc">Student</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(</span><span class="nc">Student</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">15</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">sun</span><span class="o">.</span><span class="na">reflect</span><span class="o">.</span><span class="na">NativeConstructorAccessor</span>
</code></pre></div></div>

<h2 id="how-do-you-reverse-a-string-in-java-without-using-stringbuffer">How do you reverse a String in Java without using StringBuffer?</h2>

<p>The Java library provides String Buffer and StringBuilder class with
<strong>reverse()</strong> method, which can be used to reverse String in Java.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">reverse</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">source</span><span class="o">=</span> <span class="s">"My Name is Khan"</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="n">reverse</span> <span class="o">+</span> <span class="n">source</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
</code></pre></div></div>

<h2 id="how-to-print-duplicate-characters-from-string">How to Print duplicate characters from String?</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RepreatedChar</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"success"</span><span class="o">;</span>

 <span class="c1">// 1.convert into char array</span>
 <span class="kt">char</span><span class="o">[]</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>

 <span class="c1">// 2.create Hashmap store key as character, count as value</span>
 <span class="nc">HashMap</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
 <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>

 	<span class="c1">// 3.Check if Map contains given Char as &lt;key&gt; or not</span>
 	<span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>
  <span class="c1">// if their, get the value &amp; increment it</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
  <span class="n">i</span><span class="o">++;</span>
  <span class="c1">// add updated value to it</span>
  <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ch</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
 	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
  <span class="c1">// if not their , add key &amp; value as 1</span>
  <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ch</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
 	<span class="o">}</span>
 <span class="o">}</span>
 	
  <span class="nc">Set</span>  <span class="n">set</span> <span class="o">=</span>  <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">();</span>
  <span class="nc">Iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">iterator</span><span class="o">()</span> <span class="o">;</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
 	<span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Entry</span><span class="o">)</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()+</span><span class="s">" : "</span><span class="o">+</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
 	
 <span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="n">s</span> <span class="o">:</span> <span class="mi">3</span>
<span class="n">c</span> <span class="o">:</span> <span class="mi">2</span>
<span class="n">u</span> <span class="o">:</span> <span class="mi">1</span>
<span class="n">e</span> <span class="o">:</span> <span class="mi">1</span>
</code></pre></div></div>

<h2 id="reverse-string-in-java">Reverse String in Java</h2>

<ol>
  <li>
    <p>Get String length</p>
  </li>
  <li>
    <p>Iterate by using charAt() in reverse &amp; append to new String
```java
public class ReverseString {
public static void main(String[] args) {</p>

    <p>String s = “satyam”;
String rev=””;
int len = s.length();</p>

    <p>for(int i=(len-1);i&gt;=0;i–){</p>
  </li>
</ol>

<p>rev = rev+s.charAt(i);
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.out.println(rev); } } ```
</code></pre></div></div>

<h2 id="is-string-contains-number-or-not">Is String contains Number or not</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegEx</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">// Regular expression in Java to check if String is number or not</span>
 <span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">".*[^0-9].*"</span><span class="o">);</span>  
 <span class="nc">String</span><span class="o">[]</span> <span class="n">inputs</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"123"</span><span class="o">,</span> <span class="s">"-123"</span><span class="o">,</span> <span class="s">"123.12"</span><span class="o">,</span> <span class="s">"abcd123"</span> <span class="o">};</span>
 <span class="cm">/* Matches m = pattern.match(input);
  * boolean ch = m.match();	 */</span> 

 <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">input</span> <span class="o">:</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"does "</span> <span class="o">+</span> <span class="n">input</span> <span class="o">+</span> <span class="s">" is number : "</span> <span class="o">+</span> <span class="o">!</span><span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">input</span><span class="o">).</span><span class="na">matches</span><span class="o">());</span>
 <span class="o">}</span>

	<span class="c1">// Regular expression in java to check if String is 6 digit number or  not</span>
 <span class="nc">String</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"123"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">,</span> <span class="s">"123.12"</span><span class="o">,</span> <span class="s">"abcd123"</span><span class="o">,</span> <span class="s">"123456"</span> <span class="o">};</span>
 <span class="nc">Pattern</span> <span class="n">digitPattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\d{6}"</span><span class="o">);</span>
 <span class="c1">// Pattern digitPattern = Pattern.compile("\\d\\d\\d\\d\\d\\d");</span>

 <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"does "</span> <span class="o">+</span> <span class="n">number</span> <span class="o">+</span> <span class="s">" is 6 digit number : "</span> <span class="o">+</span> <span class="n">digitPattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">number</span><span class="o">).</span><span class="na">matches</span><span class="o">());</span>
 <span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="java-stringtokenizer-with-multiple-de-limiters">Java StringTokenizer With Multiple De-limiters?</h2>

<p>The <strong>java.util.StringTokenizer</strong> class allows an application to break a string
into tokens.</p>

<p><strong>StringTokenizer(String str)</strong></p>

<p>This constructor a string tokenizer for the specified string.</p>

<p><strong>StringTokenizer(String str, String delim)</strong></p>

<p>This constructor constructs string tokenizer for the specified string.</p>

<p>The 6 useful methods of StringTokenizer class are as follows:</p>

<table>
  <thead>
    <tr>
      <th><strong>Public method</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>boolean hasMoreTokens()</td>
      <td>checks if there is more tokens available.</td>
    </tr>
    <tr>
      <td>String nextToken()</td>
      <td>returns the next token from the StringTokenizer object.</td>
    </tr>
    <tr>
      <td>String nextToken(String delim)</td>
      <td>returns the next token based on the delimeter.</td>
    </tr>
    <tr>
      <td>boolean hasMoreElements()</td>
      <td>same as hasMoreTokens() method.</td>
    </tr>
    <tr>
      <td>Object nextElement()</td>
      <td>same as nextToken() but its return type is Object.</td>
    </tr>
    <tr>
      <td>int countTokens()</td>
      <td>returns the total number of tokens.</td>
    </tr>
  </tbody>
</table>

<p><strong>Normal Example</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Simple</span><span class="o">{</span>  
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[]){</span>  
   <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="s">"my name is khan"</span><span class="o">,</span><span class="s">" "</span><span class="o">);</span>  <span class="c1">//space</span>
     <span class="k">while</span> <span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">hasMoreTokens</span><span class="o">())</span> <span class="o">{</span>  
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>  
     <span class="o">}</span>  
   <span class="o">}</span>  
<span class="o">}</span>  
<span class="o">==============================</span>
<span class="nl">Output:</span><span class="n">my</span>
       <span class="n">name</span>
       <span class="n">is</span>
       <span class="n">khan</span>
</code></pre></div></div>

<p><strong>Java StringTokenizer with Multiple De-limiters</strong></p>

<p>for this we have to specify the Delimiters , separated by //. for Example</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringTokenizer</span> <span class="n">tokenizer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="s">"// //!//,//?//.//_//'//@)"</span><span class="o">);</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"He is a very very good boy, isn't he?"</span><span class="o">;</span>
 <span class="nc">StringTokenizer</span> <span class="n">tokenizer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="s">"// //!//,//?//.//_//'//@)"</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="na">countTokens</span><span class="o">());</span>
 <span class="k">while</span> <span class="o">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="na">hasMoreTokens</span><span class="o">())</span> <span class="o">{</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
 <span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="o">====================</span>
<span class="mi">10</span>
<span class="nc">He</span>
<span class="n">is</span>
<span class="n">a</span>
<span class="n">very</span>
<span class="n">very</span>
<span class="n">good</span>
<span class="n">boy</span>
<span class="n">isn</span>
<span class="n">t</span>
<span class="n">he</span>
</code></pre></div></div>

<h2 id="reverse-words-in-a-string">Reverse Words in a String</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RevWords</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">// using s.split("\\s");</span>
 <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"My name is Satya"</span><span class="o">;</span>
 <span class="nc">String</span> <span class="n">words</span><span class="o">[]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\s"</span><span class="o">);</span>
 <span class="nc">String</span> <span class="n">rev</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
 <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
 <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
 	<span class="n">rev</span> <span class="o">=</span> <span class="n">rev</span> <span class="o">+</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
 <span class="o">}</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">rev</span><span class="o">);</span>

 <span class="c1">// using Collections.reverse(str)</span>
 <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">word</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\s"</span><span class="o">));</span>
 <span class="nc">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Using String Tokenizer</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Using Constructor 1 -By Space "</span><span class="o">);</span>
 <span class="nc">StringTokenizer</span> <span class="n">st1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="s">"Hello Geeks How are you"</span><span class="o">,</span> <span class="s">" "</span><span class="o">);</span>
               <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Get TokensCount in case of revers:  "</span><span class="o">+</span><span class="n">st1</span><span class="o">.</span><span class="na">countTokens</span><span class="o">());</span>
 <span class="k">while</span> <span class="o">(</span><span class="n">st1</span><span class="o">.</span><span class="na">hasMoreTokens</span><span class="o">())</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st1</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Using Constructor 2 - By Given Symol"</span><span class="o">);</span>
 <span class="nc">StringTokenizer</span> <span class="n">st2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="s">"JAVA : Code : String"</span><span class="o">,</span> <span class="s">" :"</span><span class="o">);</span>
 <span class="k">while</span> <span class="o">(</span><span class="n">st2</span><span class="o">.</span><span class="na">hasMoreTokens</span><span class="o">())</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st2</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Using Constructor 3 - Using Flag"</span><span class="o">);</span>
 <span class="cm">/*
  * If the flag is false, delimiter characters serve to separate tokens. For
  * example, if string is "hello geeks" and delimiter is " ", then tokens are
  * "hello" and "geeks".
  * 
  * If the flag is true, delimiter characters are considered to be tokens. For
  * example, if string is "hello geeks" and delimiter is "
  * ", then tokens are "hello", " " and "geeks".
  */</span>
 <span class="nc">StringTokenizer</span> <span class="n">st3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="s">"JAVA : Code : String"</span><span class="o">,</span> <span class="s">" :"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
 <span class="k">while</span> <span class="o">(</span><span class="n">st3</span><span class="o">.</span><span class="na">hasMoreTokens</span><span class="o">())</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st3</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h2 id="what-does-the-intern-method-of-string-class-do-answer"><strong>What does the intern() method of String class do? (</strong><a href="http://javarevisited.blogspot.sg/2015/12/when-to-use-intern-method-of-string-in-java.html">answer</a><strong>)</strong></h2>

<p>The <strong>intern()</strong> method of String class put the String on which it has called
into String pool e.g.** str.intern() **will put the String str into the pool.
Once the String is the pool it can be reused and improve performance.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"Satya"</span><span class="o">);</span>
 <span class="nc">String</span> <span class="n">intern</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">intern</span><span class="o">();</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">intern</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="nc">Output</span>
<span class="o">---------</span>
<span class="nc">Satya</span>
</code></pre></div></div>

<h2 id="how-to-convert-string-to-date-in-java-answer">How to convert String to Date in Java? (<a href="http://www.java67.com/2014/12/string-to-date-example-in-java-multithreading.html">answer</a>)</h2>

<p><strong>Prior to Java 8</strong>, you can use <strong>DateFormat</strong> or <strong>SimpleDateFormat</strong> class to
convert a String to Date In Java or vice-versa.</p>

<p><strong>From Java 8 onwards</strong>, when you use the new Date and Time API, you can also
use the <strong>DateTimeFormatter</strong> class to convert String to LocalDate, LocalTime,
or LocalDateTime class in Java.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">string</span> <span class="o">=</span> <span class="s">"February 6, 2014"</span><span class="o">;</span>
<span class="n">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"MM/dd/yyyy"</span><span class="o">).</span><span class="na">parse</span><span class="o">(</span><span class="n">string</span><span class="o">);</span>
</code></pre></div></div>

<h2 id="formatted-output-in-java">Formatted output in Java</h2>

<p>Sometimes we need to print the output in a given specified format. For doing
that we have printf() method.</p>

<p><strong>printf()</strong> can take <strong>multiple arguments</strong>, but System.out.print() and
System.out.println() take a single argument.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span> 
	    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"Printing simple integer: x = %d\n"</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span> 
	  
	    <span class="c1">// this will print it upto 2 decimal places </span>
	    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"Formatted with precison: PI = %.2f\n"</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">PI</span><span class="o">);</span> 
	  
	    <span class="kt">float</span> <span class="n">n</span> <span class="o">=</span> <span class="mf">5.2f</span><span class="o">;</span> 
	  
	    <span class="c1">// automatically appends zero to the rightmost part of decimal </span>
	    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"Formatted to specific width: n = %.4f\n"</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> 
	  
	    <span class="n">n</span> <span class="o">=</span> <span class="mf">2324435.3f</span><span class="o">;</span> 
	  
	    <span class="c1">// here number is formatted from right margin and occupies a width of 20 characters </span>
	    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"Formatted to right margin: n = %20.4f\n"</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> 
	<span class="o">}</span>
<span class="o">}</span>
<span class="nc">Printing</span> <span class="n">simple</span> <span class="nl">integer:</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">100</span>
<span class="nc">Formatted</span> <span class="n">with</span> <span class="nl">precison:</span> <span class="no">PI</span> <span class="o">=</span> <span class="mf">3.14</span>
<span class="nc">Formatted</span> <span class="n">to</span> <span class="n">specific</span> <span class="nl">width:</span> <span class="n">n</span> <span class="o">=</span> <span class="mf">5.2000</span>
<span class="nc">Formatted</span> <span class="n">to</span> <span class="n">right</span> <span class="nl">margin:</span> <span class="n">n</span> <span class="o">=</span>         <span class="mf">2324435.2500</span>
</code></pre></div></div>

<p>We have The <code class="language-plaintext highlighter-rouge">java.lang.String.format(String format, Object... args)</code> method
returns a formatted string using the specified format string and arguments.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">PI</span><span class="o">;</span>
 <span class="c1">// returns a formatted string using the specified format string, and arguments</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%f\n"</span><span class="o">,</span> <span class="n">pi</span><span class="o">);</span>
 
 <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">246.83278387f</span><span class="o">;</span>
 <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%.2f\n"</span><span class="o">,</span><span class="n">f</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span> 
	<span class="o">}</span>
<span class="o">}</span>
<span class="mf">3.141593</span>
<span class="mf">246.83</span>
</code></pre></div></div>

<h2 id="difference-between-format-and-printf-method-in-java-answer">Difference between format() and printf() method in Java? (<a href="http://javarevisited.blogspot.sg/2014/02/how-to-format-and-display-number-to.html#axzz5F18OIWfY">answer</a>)</h2>

<p>Even though both methods can be used to format String and they have same rules
the key difference is that</p>

<ul>
  <li>
    <p>format() method <strong>returns a formatted String</strong></p>
  </li>
  <li>
    <p>printf() method <strong>print formatted String to console</strong>.</p>
  </li>
</ul>

<p>So, if you need a formatted String, use format method and if you want to print,
then use the printf() method.</p>

<h2 id="how-do-you-append-leading-zero-to-a-numeric-string-answer">How do you append leading zero to a numeric String? (<a href="http://www.java67.com/2014/10/how-to-pad-numbers-with-leading-zeroes-in-Java-example.html">answer</a>)</h2>

<p>You can use the <strong>format()</strong> method of String to append leading zeros to a
numeric String in Java.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%04d"</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span> <span class="c1">// 0009 </span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"original number %d, numeric string with padding : %s"</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="n">str</span><span class="o">);</span>

<span class="n">original</span> <span class="n">number</span> <span class="mi">9</span><span class="o">,</span> <span class="n">numeric</span> <span class="n">string</span> <span class="n">with</span> <span class="n">padding</span> <span class="o">:</span> <span class="mo">000</span><span class="mi">9</span>

<span class="n">we</span> <span class="n">can</span> <span class="n">also</span> <span class="n">use</span> <span class="nc">DecimalFormat</span> <span class="kd">class</span> <span class="nc">with</span> <span class="n">passing</span> <span class="n">format</span>
 <span class="nc">DecimalFormat</span> <span class="n">df</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DecimalFormat</span><span class="o">(</span><span class="s">"0000"</span><span class="o">);</span> 
 <span class="nc">String</span> <span class="n">a</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="mi">9</span><span class="o">);</span> <span class="c1">// 0009 </span>
 <span class="nc">String</span> <span class="n">b</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="mi">99</span><span class="o">);</span> <span class="c1">// 0099 </span>
 <span class="nc">String</span> <span class="n">c</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="mi">999</span><span class="o">);</span> <span class="c1">// 0999</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n"</span><span class="o">+</span><span class="n">a</span><span class="o">+</span><span class="s">" \n"</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="s">" \n"</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="s">" \n"</span><span class="o">);</span>
<span class="mo">000</span><span class="mi">9</span> 
<span class="mo">00</span><span class="mi">99</span> 
<span class="mi">0999</span>
</code></pre></div></div>

<h1 id="enum">Enum</h1>

<p><strong>Enumeration in Java</strong> is supported by keyword enum. enums are a special type
of class that always
extends <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Enum.html">java.lang.Enum</a>.enums
are <strong>Compile time Constants, because they are -public static final</strong></p>

<p>Logically, <strong>each enum is an instance of enum type</strong> itself. So given enum can
be seen as below declaration. <strong>JVM internally adds ordinal and value
methods</strong> to this class which we can call while working with enum.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Direction</span>
<span class="o">{</span>
   <span class="no">EAST</span><span class="o">,</span> <span class="no">WEST</span><span class="o">,</span> <span class="no">NORTH</span><span class="o">,</span> <span class="no">SOUTH</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="nc">Direction</span> <span class="kd">extends</span> <span class="nc">Enum</span><span class="o">&lt;</span><span class="nc">Direction</span><span class="o">&gt;</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">Direction</span> <span class="no">EAST</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Direction</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">Direction</span> <span class="no">WEST</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Direction</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">Direction</span> <span class="no">NORTH</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Direction</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">Direction</span> <span class="no">SOUTH</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Direction</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ordinal()</code> method returns the order of an enum instance. It represents
the sequence in the enum declaration, where the initial constant is assigned an
ordinal of <code class="language-plaintext highlighter-rouge">'0'</code>. It is very much like array indexes.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Direction</span><span class="o">.</span><span class="na">EAST</span><span class="o">.</span><span class="na">ordinal</span><span class="o">();</span>     <span class="c1">//0 </span>
<span class="nc">Direction</span><span class="o">.</span><span class="na">NORTH</span><span class="o">.</span><span class="na">ordinal</span><span class="o">();</span>    <span class="c1">//2</span>
</code></pre></div></div>

<p>The <strong>enum values()</strong> method returns all the enum values in an <strong>enum array</strong>.</p>

<p>Direction[] directions = Direction.values();</p>

<p>By default, <strong>enums don’t require constructor</strong> definitions and their default
values are always the string used in the declaration. you can give define your
own values by constructors to initialize.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Direction</span>
<span class="o">{</span>
    <span class="c1">// enum fields</span>
    <span class="no">EAST</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="no">WEST</span><span class="o">(</span><span class="mi">180</span><span class="o">),</span> <span class="no">NORTH</span><span class="o">(</span><span class="mi">90</span><span class="o">),</span> <span class="no">SOUTH</span><span class="o">(</span><span class="mi">270</span><span class="o">);</span>
    <span class="c1">// internal state</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">angle</span><span class="o">;</span>
 
    <span class="c1">// constructor</span>
    <span class="kd">private</span> <span class="nf">Direction</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">angle</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">angle</span> <span class="o">=</span> <span class="n">angle</span><span class="o">;</span>
    <span class="o">}</span> 
 
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAngle</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">angle</span><span class="o">;</span>
    <span class="o">}</span>
<span class="nc">Public</span> <span class="nc">Static</span> <span class="kt">void</span> <span class="nf">Main</span><span class="o">(){</span>
<span class="nc">Direction</span> <span class="n">north</span> <span class="o">=</span> <span class="nc">Direction</span><span class="o">.</span><span class="na">NORTH</span><span class="o">;</span>
         
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="n">north</span> <span class="o">);</span>                      <span class="c1">//NORTH</span>
 
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="n">north</span><span class="o">.</span><span class="na">getAngle</span><span class="o">()</span> <span class="o">);</span>           <span class="c1">//90 </span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="nc">Direction</span><span class="o">.</span><span class="na">NORTH</span><span class="o">.</span><span class="na">getAngle</span><span class="o">()</span> <span class="o">);</span> <span class="c1">//90</span>
<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Remember that enum is basically a special class type, and it can have methods
and fields just like any other class</strong>. You can add methods which
are <strong>abstract</strong> as well as <strong>concrete methods</strong> as well. Both methods are
allowed in enum.</p>

<p>Two classes have been added to java.util package in support of enums
– <a href="https://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html">EnumSet</a> and <a href="https://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html">EnumMap</a></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>
<span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
   <span class="o">{</span>
     <span class="nc">Set</span> <span class="n">enumSet</span> <span class="o">=</span> <span class="nc">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>  <span class="nc">Direction</span><span class="o">.</span><span class="na">EAST</span><span class="o">,</span>
                                <span class="nc">Direction</span><span class="o">.</span><span class="na">WEST</span><span class="o">,</span>
                                <span class="nc">Direction</span><span class="o">.</span><span class="na">NORTH</span><span class="o">,</span>
                                <span class="nc">Direction</span><span class="o">.</span><span class="na">SOUTH</span>
                              <span class="o">);</span>
<span class="nc">Map</span> <span class="n">enumMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EnumMap</span><span class="o">(</span><span class="nc">Direction</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
 
    <span class="c1">//Populate the Map</span>
    <span class="n">enumMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">Direction</span><span class="o">.</span><span class="na">EAST</span><span class="o">,</span> <span class="nc">Direction</span><span class="o">.</span><span class="na">EAST</span><span class="o">.</span><span class="na">getAngle</span><span class="o">());</span>
    <span class="n">enumMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">Direction</span><span class="o">.</span><span class="na">WEST</span><span class="o">,</span> <span class="nc">Direction</span><span class="o">.</span><span class="na">WEST</span><span class="o">.</span><span class="na">getAngle</span><span class="o">());</span>
    <span class="n">enumMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">Direction</span><span class="o">.</span><span class="na">NORTH</span><span class="o">,</span> <span class="nc">Direction</span><span class="o">.</span><span class="na">NORTH</span><span class="o">.</span><span class="na">getAngle</span><span class="o">());</span>
    <span class="n">enumMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">Direction</span><span class="o">.</span><span class="na">SOUTH</span><span class="o">,</span> <span class="nc">Direction</span><span class="o">.</span><span class="na">SOUTH</span><span class="o">.</span><span class="na">getAngle</span><span class="o">());</span>
   <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div></div>

<h2 id="1-can-enum-implement-interface-in-java">1) Can Enum implement interface in Java?</h2>

<p><strong>Yes, Enum can implement interface in Java</strong>. Since enum is a type, similar
to class and interface, it can implement interface. This gives a lot of
flexibility to use Enum as specialized implementation in some cases</p>

<h2 id="can-enum-extends-class-in-java">Can Enum extends class in Java?</h2>

<p><strong>No, Enum can not extend class in Java</strong>. Because all Enum by <strong>default extend
abstract base class java.lang.Enum</strong>, obviously they cannot extend another
class, because <a href="http://javarevisited.blogspot.com/2011/07/why-multiple-inheritances-are-not.html">Java doesn’t support multiple inheritance for
classes</a>.
Because of extending java.lang.Enum class, all enum gets methods
like <strong>ordinal(), values() or valueOf().</strong></p>

<h2 id="can-we-create-instance-of-enum-outside-of-enum-itself-if-not-why"><br />Can we create instance of Enum outside of Enum itself? If Not, Why?</h2>

<p>No, you cannot create enum instances outside of Enum boundary, because <strong>Enum
doesn’t have any **<a href="http://java67.blogspot.sg/2012/12/how-constructor-chaining-works-in-java.html">public
constructor</a></strong>,
and compiler doesn’t allow you to provide any public constructor in Enum. But we
can write private/protected Constructor.**</p>

<p>Since compiler generates lot of code in response to enum type declaration, it
doesn’t allow public constructors inside Enum, which enforces declaring enum
instances inside Enum itself.</p>

<h2 id="can-we-declare-constructor-inside-enum-in-java">Can we declare Constructor inside Enum in Java?</h2>

<p><strong>Yes</strong>, you can, but remember you <strong>can only declare either private or
package-private constructor</strong> inside enum. public and protected constructors are
not permitted inside enum.
See <a href="http://java67.blogspot.sg/2012/11/java-enum-example-with-constructor.html">here</a> for
a code example.</p>

<h1 id="exception-handling">Exception Handling</h1>

<p><img src="media/7f8814dc803c827c717e74db7a394253.png" alt="Image result for java checked and unchecked exceptions" /></p>

<p><strong>1.Checked Exceptions:</strong> They Checked by Compiler, the given resource is
existed or not, They are usually occur interacting with outside resources/
network resources e.g. database problems, network connection errors, missing
files etc. <strong>Java forces you to handle these error scenarios in some manner in
your application code</strong></p>

<p><strong>2.Unchecked Exceptions:</strong> occurrences of which are not checked by the compiler
like <strong>coding, initialization, Primitive data errors. They usually result of bad
code in your system.</strong></p>

<p><strong>3.Error</strong> : JVM +Memory+ OS level issues . OutofMemory, StatckOverFlow</p>

<h2 id="what-will-happen-if-you-put-systemexit0-on-try-or-catch-block">What will happen if you put System.exit(0) on try or catch block?</h2>

<p>In normal Finally block will always execute. The only case finally block is not
executed is <strong>System.exit(0).</strong> In advanced case it will execute in following
case.</p>

<p>By Calling System.exit(0) in try or catch block, its stops execution &amp; throws
<strong>SecurityException few times only</strong>.</p>

<ul>
  <li>If System.exit(0) <strong>NOT throws security exception, then finally block Won’t
be executed</strong>
```java
public class Demo {
public static void main(String[] args) {</li>
</ul>

<p>try {
 	System.out.println(“try”);
 	System.exit(0);
 }catch (Exception e) {
 	System.out.println(“catch”);
 } finally {
 	System.out.println(“finally”);
 }
}
}
try	 - (Security Exception not thrown)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

-   But, if **System.exit(0) throws security exception then finally block will
    be executed**.

**java.lang.System.exit()** will terminates the currently executing program by
JVM.

-   **exit(0)** : Generally used to indicate successful termination.

-   **exit(1) or exit(-1) or any other non-zero value** –indicates unsuccessful
    termination.

##  What happens if we put return statement on try/catch? Will finally block execute?

Yes, finally block will execute even if you put a return statement in the try
block or catch block.

```java
try {
    //try block
    ...
    return success;
}
catch (Exception ex) {
    //catch block
    .....
    return failure;
}
finally {
    System.out.println("Inside finally");
}
</code></pre></div></div>

<p>The answer is yes. <strong>finally</strong> block will execute. The only case where it will
not execute is when it encounters <strong>System.exit().</strong></p>

<h2 id="what-happens-when-a-finally-block-has-a-return-statement">What happens when a finally block has a return statement?</h2>

<p>Finally block overrides the value returned by try and catch blocks.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">myTestingFuncn</span><span class="o">(){</span>
  <span class="k">try</span><span class="o">{</span>
     <span class="o">....</span>
     <span class="k">return</span> <span class="mi">5</span><span class="o">;</span>
  <span class="o">}</span> 
  <span class="k">finally</span> <span class="o">{</span>
     <span class="o">....</span>
     <span class="k">return</span> <span class="mi">19</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This program would return value 19 since the value returned by try has
been overridden by finally.</p>

<p>Remember, if a method return any thing in try, we must place return in catch as
well.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">number</span><span class="o">()</span> <span class="o">{</span>
 <span class="k">try</span> <span class="o">{</span>
 	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">/</span> <span class="mi">0</span><span class="o">;</span>
 	<span class="k">return</span> <span class="mi">100</span><span class="o">;</span>

 <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
 	<span class="k">return</span> <span class="mi">200</span><span class="o">;</span>
 <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">300</span><span class="o">;</span>
 <span class="o">}</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">Test</span><span class="o">().</span><span class="na">number</span><span class="o">());</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="mi">0</span><span class="o">/</span><span class="nl">p:</span> <span class="mi">300</span>
</code></pre></div></div>

<h2 id="why-do-you-think-checked-exception-exists-in-java-since-we-can-also-convey-error-using-runtimeexception">Why do you think Checked Exception exists in Java, since we can also convey error using RuntimeException?</h2>
<p><strong>Most of checked exceptions are in java.io package</strong>, which make sense because
if you request any system resource and its not available, than a robust program
must be able to handle that situation gracefully.</p>

<p>By declaring <strong>IOException</strong> as checked Exception, Java ensures that yours
provide that gracefully exception handling. Another possible reason could be to
ensuring that system resources like file descriptors, which are limited in
numbers, should be released as soon as you are done with that using catch or
finally block</p>

<h2 id="have-you-faced-outofmemoryerror-in-java-how-did-you-solved-that"><strong>Have you faced OutOfMemoryError in Java? How did you solved that?</strong></h2>
<p><strong>OutOfMemoryError in</strong> Java is a subclass of java.lang.VirtualMachineError and
JVM throws java.lang.OutOfMemoryError when it <strong>ran out of memory in the heap.</strong></p>

<p>An easy way to solve OutOfMemoryError in java is to <a href="http://javarevisited.blogspot.com/2011/08/increase-heap-size-maven-ant.html">increase the maximum heap
size</a> by
using JVM options “-Xmx512M”, this will immediately solve your OutOfMemoryError.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span> <span class="err">–</span><span class="nc">Xmx512m</span> <span class="n">myprogram</span>
<span class="o">-</span><span class="nc">Xms512m</span> <span class="o">-</span><span class="nc">Xmx1152m</span> <span class="o">-</span><span class="nl">XX:</span><span class="nc">MaxPermSize</span><span class="o">=</span><span class="mi">256</span><span class="n">m</span> <span class="o">-</span><span class="nl">XX:</span><span class="nc">MaxNewSize</span><span class="o">=</span><span class="mi">256</span><span class="n">m</span>
</code></pre></div></div>

<h1 id="io-streams">I/O Streams</h1>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">.</span><span class="na">ByteStreams</span><span class="o">(</span><span class="mi">1</span> <span class="kt">byte</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span><span class="o">)</span> <span class="o">:</span> <span class="n">read</span> <span class="n">image</span><span class="o">,</span> <span class="n">audio</span><span class="o">,</span> <span class="n">video</span> <span class="n">etc</span> 
	<span class="nc">FileOutputStream</span> <span class="n">outputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"c:\a.txt"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">outputStream</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">FileInputStream</span> <span class="n">inputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"c:\a.txt"</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">inputStream</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"I : "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

 <span class="mi">2</span><span class="o">.</span><span class="na">CharacterStreams</span><span class="o">(</span><span class="mi">2</span> <span class="nc">Bytes</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Character</span> <span class="n">file</span> <span class="n">data</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span> <span class="o">={</span> <span class="sc">'a'</span><span class="o">,</span> <span class="sc">'b'</span><span class="o">,</span> <span class="sc">'c'</span><span class="o">,</span> <span class="sc">'d'</span><span class="o">,</span> <span class="sc">'e'</span> <span class="o">};</span>
 <span class="nc">FileWriter</span> <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="n">filepath</span><span class="o">);</span>
 <span class="n">w</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
 <span class="n">w</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>

 <span class="nc">FileReader</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">filepath</span><span class="o">);</span>
 <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
 <span class="k">while</span> <span class="o">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="n">i</span><span class="o">);</span>
 <span class="o">}</span>
 
<span class="mi">3</span><span class="o">.</span><span class="na">Buffered</span> <span class="nc">Streams</span><span class="o">(</span><span class="mi">1024</span> <span class="n">bytes</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span><span class="o">):</span> <span class="nc">Rather</span> <span class="n">than</span> <span class="n">read</span> <span class="n">one</span> <span class="kt">byte</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span><span class="o">,</span> <span class="n">it</span> <span class="n">reads</span> <span class="n">a</span> <span class="n">larger</span> <span class="n">block</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span> <span class="n">into</span> <span class="n">an</span> <span class="n">internal</span> <span class="n">buffer</span>
  <span class="c1">// 1.Create Stream Object</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">filepath</span><span class="o">);</span>
        <span class="c1">// 2.pass Stream object to BufferStream constructor</span>
        <span class="nc">BufferedOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"SmlCodes.com -Programmimg Simplified"</span><span class="o">;</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
        <span class="n">bos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
        <span class="n">bos</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
 
        <span class="c1">// 1.Create Stream Object</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">filepath</span><span class="o">);</span>
        <span class="c1">// 2.pass Stream object to BufferStream constructor</span>
        <span class="nc">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>  
        <span class="k">while</span><span class="o">((</span><span class="n">i</span><span class="o">=</span><span class="n">bis</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">){</span>  
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">i</span><span class="o">);</span>  
        <span class="o">}</span> 

<span class="mi">4</span><span class="o">.</span><span class="na">Data</span> <span class="nl">streams:</span> <span class="n">above</span> <span class="n">we</span> <span class="n">have</span> <span class="n">only</span> <span class="nc">Char</span> <span class="o">&amp;</span> <span class="nc">Byte</span> <span class="n">types</span><span class="o">.</span> <span class="no">I</span><span class="o">/</span><span class="no">O</span> <span class="n">of</span> <span class="n">primitive</span> <span class="n">data</span> <span class="n">type</span> <span class="nf">values</span> <span class="o">(</span><span class="kt">int</span><span class="o">,</span> <span class="kt">long</span><span class="o">,</span> <span class="kt">float</span><span class="o">,</span> <span class="n">and</span> <span class="kt">double</span><span class="o">)</span> 	
        <span class="nc">DataOutputStream</span> <span class="n">dos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataOutputStream</span><span class="o">(</span><span class="k">new</span>       <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"sml.bin"</span><span class="o">));</span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">"Satya"</span><span class="o">);</span>
        
        <span class="nc">DataInputStream</span> <span class="n">dis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"sml.bin"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Int : "</span> <span class="o">+</span> <span class="n">dis</span><span class="o">.</span><span class="na">readInt</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"String : "</span> <span class="o">+</span> <span class="n">dis</span><span class="o">.</span><span class="na">readUTF</span><span class="o">());</span>
        
<span class="mi">5</span><span class="o">.</span><span class="na">Object</span> <span class="nc">Streams</span> <span class="o">:</span> <span class="n">object</span> <span class="n">streams</span> <span class="n">support</span> <span class="no">I</span><span class="o">/</span><span class="no">O</span> <span class="n">of</span> <span class="n">objects</span><span class="o">.</span> <span class="nc">Serialization</span><span class="o">.</span>
<span class="err">•</span>	<span class="nc">Choose</span> <span class="n">the</span> <span class="n">appropriate</span> <span class="kd">class</span> <span class="nc">name</span> <span class="n">whose</span> <span class="n">object</span> <span class="n">is</span> <span class="n">participating</span> <span class="n">in</span> <span class="n">serialization</span><span class="o">.</span>
<span class="err">•</span>	<span class="nc">This</span> <span class="kd">class</span> <span class="nc">must</span> <span class="n">implement</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="kd">interface</span>         
        <span class="nc">class</span> <span class="nc">Student</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
            <span class="c1">// Exception in thread "main" java.io.NotSerializableException: io.Student</span>
            <span class="kd">private</span> <span class="kt">int</span> <span class="n">sno</span><span class="o">;</span>
            <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
            <span class="kd">private</span> <span class="nc">String</span> <span class="n">addr</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Serialization</span> <span class="o">{</span>
        	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span>  <span class="nc">Exception</span> <span class="o">{</span>
        	    <span class="nc">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        	    <span class="n">student</span><span class="o">.</span><span class="na">setSno</span><span class="o">(</span><span class="mi">101</span><span class="o">);</span>
        	    <span class="n">student</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"Satya Kaveti"</span><span class="o">);</span>
        	    <span class="n">student</span><span class="o">.</span><span class="na">setAddr</span><span class="o">(</span><span class="s">"VIJAYAWADA"</span><span class="o">);</span>
        	    
        	    <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"student.txt"</span><span class="o">);</span>
        	    <span class="nc">ObjectOutputStream</span> <span class="n">oos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span>
        	    <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>   
        	    
        	    <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"student.txt"</span><span class="o">);</span>
                <span class="nc">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
                <span class="nc">Student</span> <span class="n">st</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Student</span><span class="o">)</span><span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">getSno</span><span class="o">());</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">getAddr</span><span class="o">());</span> 
        	<span class="o">}</span>
        	<span class="o">}</span>
</code></pre></div></div>

<h2 id="can-a-serializable-class-contain-a-non-serializable-field-in-java-answer">Can a Serializable class contain a non-serializable field in Java? (answer)</h2>
<p>Yes, but you need to make it either static or transient.</p>

<p>A static variable cannot be serialized.
Static variables belong to a class and not to any individual instance. The concept of serialization is concerned with the object’s current state. Only data associated with a specific instance of a class is serialized, therefore static member fields are ignored during serialization</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="c1">// Exception in thread "main" java.io.NotSerializableException: io.Student</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">sno</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">//Setters &amp; Getters</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span>  <span class="nc">Exception</span> <span class="o">{</span>
	    <span class="nc">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
	    <span class="n">student</span><span class="o">.</span><span class="na">setSno</span><span class="o">(</span><span class="mi">101</span><span class="o">);</span>
	    <span class="n">student</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"Satya Kaveti"</span><span class="o">);</span>
	  
	    
	    <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"student.txt"</span><span class="o">);</span>
	    <span class="nc">ObjectOutputStream</span> <span class="n">oos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span>
	    <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>   
	    
	    <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"student.txt"</span><span class="o">);</span>
        <span class="nc">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
        <span class="nc">Student</span> <span class="n">st</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Student</span><span class="o">)</span><span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">getSno</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
       
	<span class="o">}</span>
	<span class="o">}</span>
<span class="mi">101</span>
<span class="nc">Satya</span> <span class="nf">Kaveti</span>	<span class="o">(</span><span class="nc">Static</span> <span class="n">serliaze</span> <span class="o">?)</span>


<span class="c1">//Confused? Let’s stop the program, and remove writing part &amp; re-run it!</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span>  <span class="nc">Exception</span> <span class="o">{</span>
	    
	    <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"student.txt"</span><span class="o">);</span>
        <span class="nc">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
        <span class="nc">Student</span> <span class="n">st</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Student</span><span class="o">)</span><span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">getSno</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
       
	<span class="o">}</span>
	<span class="o">}</span>
<span class="mi">101</span>
<span class="kc">null</span>
</code></pre></div></div>

<p>This clearly indicates that static variable is not stored in the file, but the
value of the static variable that is currently loaded into memory is being
picked up, when you use <em>st.getName()</em>);</p>

<h1 id="threads">Threads</h1>

<h2 id="what-happens-if-we-starts-same-threadob-twice">What happens if we starts same Thread(ob) Twice?</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadDemo</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Iam Running"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ThreadDemo</span> <span class="n">ob</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadDemo</span><span class="o">();</span>
        <span class="n">ob</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">ob</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Exception in thread "main" java.lang.IllegalThreadStateException 
at java.lang.Thread.start(Thread.java:705) 
at threads.ThreadDemo.main(ThreadDemo.java:11) 
Iam Running</code></p>

<h2 id="what-guarantee-volatile-variable-provides">What guarantee volatile variable provides?</h2>

<p>volatile provides the guarantee, changes made in one thread is visible to
others.</p>

<h2 id="what-is-busy-spin"><a href="https://netjs.blogspot.com/2016/06/busy-spinning-in-multi-threading.html">What is busy spin?</a></h2>

<p>We have T1, T2, T3 tasks which are executed by the threads t1,t2,t3. But T2, T3
Should execute after T1 completes its execution. for that they must communicate
via signaling.</p>

<p><img src="media/523ac468c3d299090bca4f0890473421.png" alt="" /></p>

<p>We can achieve this singling process in following ways</p>

<p><strong>1.Busy Wait</strong></p>

<p><img src="media/1fde9c1cc0c72beaaebfec9a437268c2.png" alt="" /></p>

<p><strong>1.</strong> here we have FLAG variable which in initialized to NO. t2, t3 threads will
check for FLAG = Yes or not for every 30 seconds via loop, util FLAG = yes.</p>

<p>This is called Busy Spin / Busy wait.</p>

<p>2.After some time, t1 changes status to YES, so that t2, t3 can proceed its
execution.</p>

<p>Busy spinning or busy wait in a multi-threaded environment is a technique where
other threads loop continuously waiting for a thread to complete its task and
signal them to start.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="o">(</span><span class="n">spinningFlag</span><span class="o">){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Waiting busy spinning"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.omg.Messaging.SyncScopeHelper</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BusySpin</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span>  <span class="n">flag</span> <span class="o">=</span><span class="kc">false</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">checkFlag</span><span class="o">()</span> <span class="o">{</span>
 <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">changeFlag</span><span class="o">()</span> <span class="o">{</span>
 <span class="n">flag</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
 <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
 
 <span class="nc">BusySpin</span> <span class="n">ob</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BusySpin</span><span class="o">();</span>
 
 <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">()</span> <span class="o">{</span>
 	<span class="nd">@Override</span>
 	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"T1 Running"</span><span class="o">);</span>
  <span class="k">try</span> <span class="o">{</span>
  	<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span>
  	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"============ SET FLAG TRUE==="</span><span class="o">);</span>
  <span class="n">ob</span><span class="o">.</span><span class="na">changeFlag</span><span class="o">();</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  	<span class="c1">// TODO Auto-generated catch block</span>
  	<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
  <span class="o">}</span>
 	<span class="o">}</span>
 	
 <span class="o">};</span>
 <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
 
 
 <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">()</span> <span class="o">{</span>
 	<span class="nd">@Override</span>
 	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"T2 Checking ........"</span><span class="o">);</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">ob</span><span class="o">.</span><span class="na">checkFlag</span><span class="o">())</span> <span class="o">{</span>
  	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"T2 Running....."</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">try</span> <span class="o">{</span>
  	<span class="n">wait</span><span class="o">(</span><span class="mi">300</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  	<span class="c1">// TODO Auto-generated catch block</span>
  	<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
  <span class="o">}</span>
 	<span class="o">}</span>
 	
 <span class="o">};</span>
 <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
 
 <span class="nc">Thread</span> <span class="n">t3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">()</span> <span class="o">{</span>
 	<span class="nd">@Override</span>
 	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"T3 Checking ........"</span><span class="o">);</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">ob</span><span class="o">.</span><span class="na">checkFlag</span><span class="o">())</span> <span class="o">{</span>
  	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"T3 Running....."</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">try</span> <span class="o">{</span>
  	<span class="n">wait</span><span class="o">(</span><span class="mi">300</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  	<span class="c1">// TODO Auto-generated catch block</span>
  	<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
  <span class="o">}</span>
 	<span class="o">}</span>
 	
 <span class="o">};</span>
 <span class="n">t3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
 
	<span class="o">}</span>
	
<span class="o">}</span>
</code></pre></div></div>

<h2 id="what-is-race-condition-in-java-given-one-example--answer">What is race condition in Java? Given one example?  (answer)</h2>

<p>-Race condition occurs when two or more threads try to read &amp; write a shared variable at the same time”</p>

<p>Because the thread scheduling algorithm can swap between threads at any time,
<strong>you don’t know the order in which the threads will attempt to access the
shared data</strong>. Therefore, the result of the change in data is dependent on the
thread scheduling algorithm, i.e. both threads are “racing” to access/change the
data.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Counter</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
 <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
 	<span class="k">try</span> <span class="o">{</span>
  <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
 	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// TODO Auto-generated catch block</span>
  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
 	<span class="o">}</span>
 	<span class="n">count</span><span class="o">++;</span>
 <span class="o">}</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
 <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RaceCondition</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
 <span class="nc">Counter</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Counter</span><span class="o">();</span>
 
 <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
 <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
 
 <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
 <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
 
 <span class="c1">// wait for threads to finish processing</span>
 <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
 <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Excepting =200, Actual is  ="</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="na">getCount</span><span class="o">());</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="nc">Excepting</span> <span class="o">=</span><span class="mi">200</span><span class="o">,</span> <span class="nc">Actual</span> <span class="n">is</span> <span class="o">=</span><span class="mi">141</span>	<span class="o">-</span><span class="mi">1</span><span class="n">st</span> <span class="nc">Run</span>
<span class="nc">Excepting</span> <span class="o">=</span><span class="mi">200</span><span class="o">,</span> <span class="nc">Actual</span> <span class="n">is</span> <span class="o">=</span><span class="mi">157</span>	<span class="o">-</span><span class="mi">2</span><span class="n">nd</span> <span class="nc">Run</span>
</code></pre></div></div>

<h2 id="what-is-thread-dump-how-do-you-take-thread-dump-in-java"><strong>What is Thread Dump? How do you take thread dump in Java?</strong></h2>
<p>Process has multiple Threads. <strong>Thread dump</strong> is a summary of the state of
all <strong>threads</strong> of the process</p>

<ul>
  <li>
    <p>‘<strong>jstack’</strong> is an effective command line tool to capture thread dumps</p>
  </li>
  <li>
    <p><strong>Java VisualVM</strong> is a GUI tool that provides detailed information about the
applications</p>

    <p><img src="media/5c02fa3e4a18f8dd8577680098dee8f1.png" alt="https://tier1app.files.wordpress.com/2014/11/jvisualvm-2.png" /></p>
  </li>
</ul>

<h2 id="why-swing-is-not-thread-safe-in-java">Why Swing is not thread-safe in Java?</h2>

<p>Since GUI screens are mostly updated in response of user action e.g. when user
click a button, and since events are handled in the same Event dispatcher
thread, it’s easy to update GUI on that thread.</p>

<h2 id="what-is-a-threadlocal-variable-in-java">What is a ThreadLocal variable in Java?</h2>

<p>Thread-local variables are variables restricted to a thread, it’s like thread’s
own copy which is not shared between multiple threads. Java provides
a <strong>ThreadLocal</strong> class to support thread-local variables, It extends Object
class.</p>

<ul>
  <li>
    <p>Basically it is an another way to achieve thread safety apart from writing
immutable classes.</p>
  </li>
  <li>
    <p>Since Object is no more shared there is no requirement of Synchronization
which can improve scalability and performance of application.</p>
  </li>
  <li>
    <p>ThreadLocal provides thread restriction which is extension of local
variable. ThreadLocal are visible only in single thread. No two thread can
see each other’s thread local variable.</p>
  </li>
  <li>
    <p>These variable are generally <strong>private static</strong> field in classes and
maintain its state inside thread.</p>
  </li>
  <li>
    <p><strong>void set(Object value), Object get(), void remove()</strong> methods are
available</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadLocalExample</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
 <span class="kd">private</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">threadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
 	<span class="n">threadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="no">D</span><span class="o">));</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
 <span class="o">}</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
 <span class="nc">MyRunnable</span> <span class="n">sharedRunnableInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">();</span>
 <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">sharedRunnableInstance</span><span class="o">);</span>
 <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">sharedRunnableInstance</span><span class="o">);</span>
 <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
 <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

 <span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span> <span class="c1">// wait for thread 1 to terminate</span>
 <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span> <span class="c1">// wait for thread 2 to terminate</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="o">-----------</span>
<span class="mi">36</span>
<span class="mi">16</span>
<span class="nc">This</span> <span class="n">example</span>
</code></pre></div></div>

<p>This example creates a single MyRunnable instance which is passed to two
different threads. Both threads execute the run() method, and thus sets
different values on the ThreadLocal instance. If the access to the set() call
had been synchronized, and it had not been a ThreadLocal object, the second
thread would have overridden the value set by the first thread</p>

<h2 id="write-code-for-thread-safe-singleton-in-java"><strong>Write code for thread-safe Singleton in Java?</strong></h2>

<p>When we say thread-safe, which means Singleton should remain singleton even if
initialization occurs in the case of multiple threads.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DoubleCheckedLockingSingleton</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kd">volatile</span> <span class="nc">DoubleCheckedLockingSingleton</span> <span class="no">INSTANCE</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nf">DoubleCheckedLockingSingleton</span><span class="o">()</span> <span class="o">{</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="nc">DoubleCheckedLockingSingleton</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
           <span class="kd">synchronized</span><span class="o">(</span><span class="nc">DoubleCheckedLockingSingleton</span><span class="o">.</span><span class="na">class</span><span class="o">){</span>
               <span class="c1">//double checking Singleton instance</span>
               <span class="k">if</span><span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                   <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DoubleCheckedLockingSingleton</span><span class="o">();</span>
               <span class="o">}</span>
           <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="when-to-use-runnable-vs-thread-in-java-think-inheritance"><strong>When to use Runnable vs Thread in Java? (Think Inheritance)</strong></h2>
<p>it’s better to implement Runnable then extends Thread if you <strong>also want to
extend another class</strong></p>

<h2 id="difference-between-runnable-and-callable-in-java">Difference between Runnable and Callable in Java?</h2>

<p>Callable was added on JDK 1.5. Main difference between these two is that
Callable’s <strong>call()</strong> method can return value and throw Exception, which was not
possible with Runnable’s run() method. Callable return <strong>Future</strong> object, which
can hold the result of computation.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">SumTask</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">SumTask</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">){</span>
   	        <span class="k">this</span><span class="o">.</span><span class="na">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="o">}</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
 <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
 <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">num</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
 	<span class="n">result</span><span class="o">+=</span><span class="n">i</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CallableDemo</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
	   <span class="nc">ExecutorService</span> <span class="n">service</span> <span class="o">=</span>  <span class="nc">Executors</span><span class="o">.</span><span class="na">newSingleThreadExecutor</span><span class="o">();</span>
	   <span class="nc">SumTask</span> <span class="n">sumTask</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumTask</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
	   <span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">sumTask</span><span class="o">);</span>
	   <span class="nc">Integer</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
	   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="how-to-stop-a-thread-in-java">How to stop a thread in Java?</h2>

<p>There was some control methods in JDK 1.0
e.g<strong>. stop(), suspend() and resume()</strong> which are deprecated.</p>

<p>We can do it in Two ways</p>

<p><em>1.Using interrupt()</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span>  <span class="nc">Exception</span> <span class="o">{</span>
	    
	    <span class="nc">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="o">()-&gt;{</span>
	    	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Running..."</span><span class="o">);</span>
	    	<span class="k">try</span> <span class="o">{</span>
  <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span>
 	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// TODO Auto-generated catch block</span>
  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
 	<span class="o">}</span>
	    	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"I have Completed ..."</span><span class="o">);</span>
	    	
	    <span class="o">};</span>
       
	    <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>
	    <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
	    <span class="n">t1</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
	<span class="o">}</span>
	<span class="o">}</span>
<span class="nc">Running</span><span class="o">...</span>
<span class="no">I</span> <span class="n">have</span> <span class="nc">Completed</span> <span class="o">...</span>
<span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">InterruptedException</span><span class="o">:</span> <span class="n">sleep</span> <span class="n">interrupted</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="nc">Native</span> <span class="nc">Method</span><span class="o">)</span>
	<span class="n">at</span> <span class="nc">Demo</span><span class="o">.</span><span class="na">lambda</span><span class="err">$</span><span class="mi">0</span><span class="o">(</span><span class="nc">Demo</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">16</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Thread</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">748</span><span class="o">)</span>
</code></pre></div></div>

<p><strong>In this case we can only stop Sleeping thread.</strong></p>

<p>2.<strong>volatile boolean variable</strong></p>

<p>In this case we need to use <strong>volatile boolean variable</strong>, &amp; we need to change
value to TRUE if we want to stop a thread.</p>

<p>I have a server; I need it to Stop</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Server</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">stop</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
 <span class="k">while</span> <span class="o">(!</span><span class="n">stop</span><span class="o">)</span> <span class="o">{</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Server is running....."</span><span class="o">);</span>
 <span class="o">}</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Server is stopped...."</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
 <span class="n">stop</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

 <span class="nc">Server</span> <span class="n">myServer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Server</span><span class="o">();</span>
 <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">myServer</span><span class="o">,</span> <span class="s">"T1"</span><span class="o">);</span>
 <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
 <span class="c1">// Now, let's stop our Server thread</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" is stopping Server thread"</span><span class="o">);</span>
 <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
 <span class="n">myServer</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
 <span class="c1">// Let's wait to see server thread stopped</span>

 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" is finished now"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Actually we are not stoping the Thread, we just coming out of the run().</p>

<h2 id="why-wait-notify-and-notifyall-are-not-inside-thread-class"><strong>Why wait, notify and notifyAll are not inside thread class?</strong></h2>
<p>Java provides lock at object level not at thread level. Every object has lock,
which is acquired by thread. Now if thread needs to wait for certain lock it
make sense to call wait() on that object rather than on that thread.</p>

<p>Had wait() method declared on Thread class, it was not clear that for which lock
thread was waiting. In short, since wait, notify and notifyAll operate at lock
level, it make sense to defined it on object class because lock belongs to
object.</p>

<h2 id="what-is-the-difference-between-deadlock-starvation-and-livelock"><strong>What is the difference between Deadlock, Starvation, and Livelock?</strong></h2>

<p><strong>Deadlock</strong>: is a situation where two more threads are blocked because of
waiting for each other forever.one of the possible situation is <strong>nested
Synchronized blocks.</strong></p>

<p>To create simple deadlock situation for a servlet, just place doPost() method
inside doGet() and doGet()method inside doPost().</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Business</span> <span class="o">{</span>
 
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">lock1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">lock2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock2</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"foo"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bar</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock2</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"bar"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Business</span> <span class="n">business</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Business</span><span class="o">();</span>
 
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">business</span><span class="o">.</span><span class="na">foo</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
 
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
 
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">business</span><span class="o">.</span><span class="na">bar</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
 
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p><strong>how to avoid deadlock</strong></p>

<ul>
  <li>
    <p>Avoid acquiring more than one lock at a time.</p>
  </li>
  <li>
    <p>If not, make sure that you acquire multiple locks in consistent order.</p>
  </li>
</ul>

<p>In the above example, you can avoid deadlock by synchronize two locks in the
same order in both methods.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock1</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock2</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"foo"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
 
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">bar</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock1</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock2</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"bar"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>2.LiveLock</strong> :A real-world example of livelock occurs when two people meet in
a narrow corridor <strong>(తాడిమట్ట),</strong> and each tries to be polite by moving aside to let
the other pass, but they end up swaying from side to side without making any
progress because they both repeatedly move the same way at the same time.</p>

<p>Livelock occurs when two or more processes continually repeat the same
interaction in response to changes in the other processes without doing any
useful work. These processes are not in the waiting state, and they are running
concurrently. This is different from a deadlock because in a deadlock all
processes are in the waiting state.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
	
	<span class="kt">boolean</span> <span class="n">selected</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSelected</span><span class="o">()</span> <span class="o">{</span>
 <span class="k">return</span> <span class="n">selected</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSelected</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">selected</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">this</span><span class="o">.</span><span class="na">selected</span> <span class="o">=</span> <span class="n">selected</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
 <span class="nc">Test</span> <span class="n">itemOne</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Test</span><span class="o">();</span>
 <span class="nc">Test</span> <span class="n">itemTwo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Test</span><span class="o">();</span>
 
 <span class="nc">Thread</span> <span class="n">tOne</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
 	<span class="nd">@Override</span>
 	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">while</span><span class="o">(!</span><span class="n">itemOne</span><span class="o">.</span><span class="na">isSelected</span><span class="o">())</span> <span class="o">{</span>
  	<span class="k">try</span> <span class="o">{</span>
   <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
  	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
  	<span class="o">}</span>
  <span class="o">}</span>
  <span class="n">itemTwo</span><span class="o">.</span><span class="na">setSelected</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
 	<span class="o">}</span> 	
 <span class="o">});</span> 
 
 <span class="nc">Thread</span> <span class="n">tTwo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
 	<span class="nd">@Override</span>
 	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">while</span><span class="o">(!</span><span class="n">itemTwo</span><span class="o">.</span><span class="na">isSelected</span><span class="o">())</span> <span class="o">{</span>
  	<span class="k">try</span> <span class="o">{</span>
   <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
  	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
  	<span class="o">}</span>
  <span class="o">}</span>
  <span class="n">itemOne</span><span class="o">.</span><span class="na">setSelected</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
 	<span class="o">}</span> 	
 <span class="o">});</span>	
 
 <span class="n">tOne</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
 <span class="n">tTwo</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>3. Starvation:</strong> describes a situation where a thread holds a resource for a
long time so other threads are blocked forever. The blocked threads are waiting
to acquire the resource but they never get a chance. Thus they starve to
death.BTW, Starvation <em>means suffering or death caused by lack of food</em>.</p>

<p>Starvation can occur due to the following reasons:</p>

<p>- Threads are blocked infinitely because a <strong>thread takes long time to
execute</strong> some synchronized code (e.g. heavy I/O operations or infinite loop).</p>

<p>- A <strong>thread doesn’t get CPU’s time for execution because it has low priority
as compared to other threads which have higher priority</strong>.</p>

<p>- Threads are waiting on a resource forever but they remain waiting forever
because other threads are constantly notified instead of the hungry ones.</p>

<p>When a starvation situation occurs, the program is still running but doesn’t run
to completion because some threads are not executed.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Worker</span> <span class="o">{</span>
 
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">fileName</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s">".txt"</span><span class="o">;</span>
 
        <span class="k">try</span> <span class="o">(</span>
            <span class="nc">BufferedWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="n">fileName</span><span class="o">));</span>
        <span class="o">)</span> <span class="o">{</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"Thread "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">" wrote this mesasge"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ex</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
 
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">" is working"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Worker</span> <span class="n">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Worker</span><span class="o">();</span>
 
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="n">worker</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//we created 10 threads but, 1st threads run continuously in infinite loop, remaining will die because they won’t get any chance to execute.</span>
</code></pre></div></div>

<p>Finally,</p>

<p>- <strong>Deadlock</strong>:  All threads are blocked, the program hangs forever.</p>

<p>- <strong>Livelock</strong>: No threads blocked but they run into infinite loops. The
program is still running but unable to make further progress.</p>

<p>- <strong>Starvation</strong>: Only one thread is running, and other threads are waiting
forever</p>

<p><a href="https://www.codejava.net/java-core/concurrency/understanding-deadlock-livelock-and-starvation-with-code-examples-in-java">https://www.codejava.net/java-core/concurrency/understanding-deadlock-livelock-and-starvation-with-code-examples-in-java</a></p>

<h2 id="how-do-you-check-if-a-thread-holds-a-lock-or-not"><strong>How do you check if a Thread holds a lock or not?</strong></h2>
<p>There is a method called <strong>holdsLock()</strong> on java.lang.Thread, it returns true if
and only if the current thread holds the monitor lock on the specified object.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">holdsLock</span><span class="o">(</span><span class="n">t</span><span class="o">));</span><span class="c1">//true or flase -checked</span>
</code></pre></div></div>

<h2 id="what-is-semaphore-in-java"><strong>What is Semaphore in Java?</strong></h2>
<p>Semaphore in Java is a new kind of synchronizer. It’s a counting semaphore.
Conceptually, a semaphore maintains a set of permits. Each <strong>acquire()</strong> blocks
if necessary until a permit is available, and then takes it. Each <strong>release()</strong>
adds a permit, potentially releasing a blocking acquirer. However, no actual
permit objects are used; the Semaphore just keeps a count of the number
available and acts accordingly. Semaphore is used to protect an expensive
resource which is available in fixed number e.g. database connection in the
pool.</p>

<h2 id="what-is-the-difference-between-the-submit-and-execute-method-thread-poolin-java">What is the difference between the submit() and execute() method thread poolin Java?</h2>

<ul>
  <li>
    <p><strong>execute(Runnable command)</strong> is defined in Executor interface and executes
given task in future, but more importantly, it does not return anything.</p>
  </li>
  <li>
    <p><strong>submit()</strong> is an overloaded method, it can take
either <strong>Runnable or Callable</strong> task and can return Future object which can
hold the pending result of computation. This method is defined
on <strong>ExecutorService</strong> interface, which extends Executor interface, and
every other thread pool class
e.g. ThreadPoolExecutor or ScheduledThreadPoolExecutor gets these methods.</p>
  </li>
</ul>

<h2 id="which-method-of-swing-api-are-thread-safe-in-java"><strong>Which method of Swing API are thread-safe in Java?</strong></h2>
<p>I know about <strong>repaint(),</strong> and revalidate() being thread-safe but there are
other methods on different swing components e.g. <strong>setText() method
of JTextComponent, insert() and append()</strong> method of JTextArea class.</p>

<h2 id="what-is-the-difference-between-the-volatile-and-atomic-variable-in-java"><strong>What is the difference between the volatile and atomic variable in Java?</strong></h2>
<p>For example count++ operation will not become atomic just by declaring count
variable as volatile. On the other hand AtomicInteger class provides atomic
method to perform such compound operation atomically e.g. getAndIncrement() is
atomic replacement of increment operator. It can be used to atomically increment
current value by one. Similarly, you have atomic version for other data type and
reference variable as well.</p>

<h2 id="what-happens-if-a-thread-throws-an-exception-inside-synchronized-block"><strong>What happens if a thread throws an Exception inside synchronized block?</strong></h2>
<p>To answer this question, no matter how you exist synchronized block, either
normally by finishing execution or abruptly by throwing exception, thread
releases the lock it acquired while entering that synchronized block.</p>

<h2 id="how-do-you-ensure-that-n-thread-can-access-n-resources-without-deadlock">How do you ensure that N thread can access N resources without deadlock?</h2>

<p><strong>Key point here is order</strong>, if you acquire resources in a particular order and
release resources in reverse order you can prevent deadlock.</p>

<h2 id="whats-the-difference-between-callable-and-runnable">What’s the difference between Callable and Runnable?</h2>

<p>Both of these are interfaces used to carry out task to be executed by a thread.
The main difference between the two interfaces is that</p>

<ul>
  <li>
    <p>Callable can <strong>return a value</strong>, while Runnable cannot.</p>
  </li>
  <li>
    <p>Callable can throw a checked exception, while Runnable cannot.</p>
  </li>
  <li>
    <p>Runnable has been around since Java 1.0, while Callable was introduced as
part of Java 1.5.</p>
  </li>
</ul>

<p>The <em>Callable</em> interface is a generic interface containing a
single <em>call()</em> method – which returns a generic value <em>V</em>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">V</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">CallableExample</span> <span class="kd">implements</span> <span class="nc">Callable</span>
<span class="o">{</span>
 
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span>
    <span class="o">{</span>
        <span class="nc">Random</span> <span class="n">generator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="nc">Integer</span> <span class="n">randomNumber</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span> 
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">randomNumber</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">);</span>
 
        <span class="k">return</span> <span class="n">randomNumber</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="what-is-false-sharing-in-the-context-of-multi-threading">What is false sharing in the context of multi-threading?</h2>

<p>false sharing is one of the well-known performance issues on multi-core systems,
where each process has its local cache.</p>

<p><img src="media/a9557dcd20f2d034d8f2a28c643e7974.gif" alt="https://2.bp.blogspot.com/-Tze9foqpb74/VepwCzXHGCI/AAAAAAAADtM/i4KQDaefqk4/s1600/False%2BSharing%2Bin%2BMulti-threaded%2Bapplication.gif" /></p>

<p>False sharing is very hard to detect because the thread may be accessing
completely different global variables that happen to be relatively close
together in memory. Like many concurrency issues, the primary way to avoid false
sharing is careful code review and aligning your data structure with the size of
a cache line</p>

<h2 id="object-level-and-class-level-locks-in-java">Object level and Class level locks in Java</h2>

<p><strong>Object level lock -</strong> Every object in java has a unique lock. Whenever we are
using <strong>synchronized keyword on instance methods</strong>, then only lock concept will
come in the picture.</p>

<p>If a thread wants to execute synchronized method on the given object. First, it
has to get lock of that object. Once thread got the lock then it is allowed to
execute any synchronized method on that object.</p>

<p>Once method execution completes automatically thread releases the lock.
Acquiring and release lock internally is taken care by JVM and programmer is not
responsible for these activities. Lets have a look on the below program to
understand the object level lock:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Geek</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="nc">Lock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">Lock</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in block "</span>
                <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in block "</span> <span class="o">+</span> 
                <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" end"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="nc">Geek</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Geek</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">g</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">g</span><span class="o">);</span>
        <span class="nc">Geek</span> <span class="n">g1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Geek</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">t3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">g1</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"t1"</span><span class="o">);</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"t2"</span><span class="o">);</span>
        <span class="n">t3</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"t3"</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">Run</span> <span class="n">on</span> <span class="no">IDE</span>
<span class="nl">Output:</span>
<span class="n">t1</span>
<span class="n">in</span> <span class="n">block</span> <span class="n">t1</span>
<span class="n">in</span> <span class="n">block</span> <span class="n">t1</span> <span class="n">end</span>
<span class="n">t2</span>
<span class="n">in</span> <span class="n">block</span> <span class="n">t2</span>
<span class="n">in</span> <span class="n">block</span> <span class="n">t2</span> <span class="n">end</span>
<span class="n">t3</span>
<span class="n">in</span> <span class="n">block</span> <span class="n">t3</span>
<span class="n">in</span> <span class="n">block</span> <span class="n">t3</span> <span class="n">end</span>
<span class="c1">//only one thread is running</span>
</code></pre></div></div>

<p><strong>Class level lock -</strong> Every class in java has a unique lock which is nothing
but class level lock. If a thread wants to execute a <strong>static synchronized
method</strong>, then thread requires class level lock.</p>

<p>Once a thread got the class level lock, then it is allowed to execute any static
synchronized method of that class.</p>

<p>Once method execution completes automatically thread releases the lock. Lets
look on the below program for better understanding:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Java program to illustrate class level lock</span>
<span class="kd">class</span> <span class="nc">Geek</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="nc">Lock</span><span class="o">();</span>
    <span class="o">}</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">Lock</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="nc">Geek</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in block "</span>
                <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"in block "</span>
                <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" end"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="nc">Geek</span> <span class="n">g1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Geek</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">g1</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">g1</span><span class="o">);</span>
        <span class="nc">Geek</span> <span class="n">g2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Geek</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">t3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">g2</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"t1"</span><span class="o">);</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"t2"</span><span class="o">);</span>
        <span class="n">t3</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"t3"</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="producer-consumer-solution-using-threads-in-java">Producer-Consumer solution using threads in Java</h2>

<ul>
  <li>
    <p>The producer’s job is to generate data, put it into the buffer, and start
again.</p>
  </li>
  <li>
    <p>same time, the consumer is consuming the data (i.e. removing it from the
buffer), one piece at a time.</p>
  </li>
  <li>
    <p>producer won’t try to add data into the buffer if it’s full &amp; consumer won’t
try to remove data from an empty buffer</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Producer</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>

	<span class="nc">List</span> <span class="n">buffer</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">maxsize</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Producer</span><span class="o">(</span><span class="nc">List</span> <span class="n">buffer</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxsize</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">this</span><span class="o">.</span><span class="na">buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">;</span>
 <span class="k">this</span><span class="o">.</span><span class="na">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
	  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
	     <span class="kd">synchronized</span> <span class="o">(</span><span class="n">buffer</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">try</span> <span class="o">{</span>
 	<span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">maxsize</span><span class="o">)</span> <span class="o">{</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Maximum Size Reached, wait until consume"</span><span class="o">);</span>
 	<span class="n">buffer</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
 	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
 	<span class="n">buffer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">++);</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">" : Produced, notify wating COnsumer Thread"</span><span class="o">);</span>
 	<span class="n">buffer</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>

 	<span class="o">}</span>
 <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  	<span class="c1">// TODO Auto-generated catch block</span>
 	<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
 <span class="o">}</span>
 <span class="o">}</span>

 <span class="o">}</span>

	<span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Consumer</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>

	<span class="nc">List</span> <span class="n">buffer</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">maxsize</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Consumer</span><span class="o">(</span><span class="nc">List</span> <span class="n">buffer</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxsize</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">this</span><span class="o">.</span><span class="na">buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">;</span>
 <span class="k">this</span><span class="o">.</span><span class="na">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>

	<span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">try</span> <span class="o">{</span>
 <span class="kd">synchronized</span> <span class="o">(</span><span class="n">buffer</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Consumer : Buffer Empty, wait untill produce"</span><span class="o">);</span>
 	<span class="n">buffer</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
 	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
 	<span class="nc">Object</span> <span class="n">ob</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ob</span> <span class="o">+</span> <span class="s">" : Removed, notify Producer waiting for Removing for maxsize"</span><span class="o">);</span>
  <span class="n">buffer</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
 	<span class="o">}</span>
 <span class="o">}</span>
 <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
   <span class="c1">// TODO: handle exception</span>
 <span class="o">}</span>
	<span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProducerConsumer</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

 <span class="nc">List</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
 <span class="nc">Producer</span> <span class="n">producer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Producer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
 <span class="nc">Consumer</span> <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Consumer</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
 <span class="n">producer</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
 <span class="n">consumer</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

	<span class="o">}</span>

<span class="o">}</span>
<span class="mi">28054</span> <span class="o">:</span> <span class="nc">Produced</span><span class="o">,</span> <span class="n">notify</span> <span class="n">wating</span> <span class="nc">COnsumer</span> <span class="nc">Thread</span>
<span class="mi">28055</span> <span class="o">:</span> <span class="nc">Produced</span><span class="o">,</span> <span class="n">notify</span> <span class="n">wating</span> <span class="nc">COnsumer</span> <span class="nc">Thread</span>
<span class="mi">28056</span> <span class="o">:</span> <span class="nc">Produced</span><span class="o">,</span> <span class="n">notify</span> <span class="n">wating</span> <span class="nc">COnsumer</span> <span class="nc">Thread</span>
<span class="mi">28057</span> <span class="o">:</span> <span class="nc">Produced</span><span class="o">,</span> <span class="n">notify</span> <span class="n">wating</span> <span class="nc">COnsumer</span> <span class="nc">Thread</span>
<span class="mi">28058</span> <span class="o">:</span> <span class="nc">Produced</span><span class="o">,</span> <span class="n">notify</span> <span class="n">wating</span> <span class="nc">COnsumer</span> <span class="nc">Thread</span>
<span class="mi">28059</span> <span class="o">:</span> <span class="nc">Produced</span><span class="o">,</span> <span class="n">notify</span> <span class="n">wating</span> <span class="nc">COnsumer</span> <span class="nc">Thread</span>
<span class="mi">28060</span> <span class="o">:</span> <span class="nc">Produced</span><span class="o">,</span> <span class="n">notify</span> <span class="n">wating</span> <span class="nc">COnsumer</span> <span class="nc">Thread</span>
<span class="nc">Maximum</span> <span class="nc">Size</span> <span class="nc">Reached</span><span class="o">,</span> <span class="n">wait</span> <span class="n">until</span> <span class="n">consume</span>
<span class="mi">28050</span> <span class="o">:</span> <span class="nc">Removed</span><span class="o">,</span> <span class="n">notify</span> <span class="nc">Producer</span> <span class="n">waiting</span> <span class="k">for</span> <span class="nc">Removing</span> <span class="k">for</span> <span class="n">maxsize</span>
<span class="mi">28051</span> <span class="o">:</span> <span class="nc">Removed</span><span class="o">,</span> <span class="n">notify</span> <span class="nc">Producer</span> <span class="n">waiting</span> <span class="k">for</span> <span class="nc">Removing</span> <span class="k">for</span> <span class="n">maxsize</span>
<span class="mi">28052</span> <span class="o">:</span> <span class="nc">Removed</span><span class="o">,</span> <span class="n">notify</span> <span class="nc">Producer</span> <span class="n">waiting</span> <span class="k">for</span> <span class="nc">Removing</span> <span class="k">for</span> <span class="n">maxsize</span>
<span class="mi">28053</span> <span class="o">:</span> <span class="nc">Removed</span><span class="o">,</span> <span class="n">notify</span> <span class="nc">Producer</span> <span class="n">waiting</span> <span class="k">for</span> <span class="nc">Removing</span> <span class="k">for</span> <span class="n">maxsize</span>
<span class="mi">28054</span> <span class="o">:</span> <span class="nc">Removed</span><span class="o">,</span> <span class="n">notify</span> <span class="nc">Producer</span> <span class="n">waiting</span> <span class="k">for</span> <span class="nc">Removing</span> <span class="k">for</span> <span class="n">maxsize</span>
<span class="mi">28055</span> <span class="o">:</span> <span class="nc">Removed</span><span class="o">,</span> <span class="n">notify</span> <span class="nc">Producer</span> <span class="n">waiting</span> <span class="k">for</span> <span class="nc">Removing</span> <span class="k">for</span> <span class="n">maxsize</span>
<span class="mi">28056</span> <span class="o">:</span> <span class="nc">Removed</span><span class="o">,</span> <span class="n">notify</span> <span class="nc">Producer</span> <span class="n">waiting</span> <span class="k">for</span> <span class="nc">Removing</span> <span class="k">for</span> <span class="n">maxsize</span>
<span class="mi">28057</span> <span class="o">:</span> <span class="nc">Removed</span><span class="o">,</span> <span class="n">notify</span> <span class="nc">Producer</span> <span class="n">waiting</span> <span class="k">for</span> <span class="nc">Removing</span> <span class="k">for</span> <span class="n">maxsize</span>
<span class="mi">28058</span> <span class="o">:</span> <span class="nc">Removed</span><span class="o">,</span> <span class="n">notify</span> <span class="nc">Producer</span> <span class="n">waiting</span> <span class="k">for</span> <span class="nc">Removing</span> <span class="k">for</span> <span class="n">maxsize</span>
<span class="mi">28059</span> <span class="o">:</span> <span class="nc">Removed</span><span class="o">,</span> <span class="n">notify</span> <span class="nc">Producer</span> <span class="n">waiting</span> <span class="k">for</span> <span class="nc">Removing</span> <span class="k">for</span> <span class="n">maxsize</span>
<span class="nc">Consumer</span> <span class="o">:</span> <span class="nc">Buffer</span> <span class="nc">Empty</span><span class="o">,</span> <span class="n">wait</span> <span class="n">untill</span> <span class="n">produce</span>
</code></pre></div></div>

<h2 id="what-is-blockingqueue-implement-producer-consumer-using-blocking-queue">What is BlockingQueue? implement Producer-Consumer using Blocking Queue?</h2>

<p>A <strong>BlockingQueue</strong> is typically used when one thread will produce objects,
another thread consumes those Objects.</p>

<p><img src="media/4f4ead35a1bdec13f55242080e1eecf2.png" alt="" /></p>

<p>A BlockingQueue with one thread putting into it, and another thread taking from it.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th><strong>Throws Exception</strong></th>
      <th><strong>Special Value</strong></th>
      <th><strong>Blocks</strong></th>
      <th><strong>Times Out</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Insert</strong></td>
      <td>add(o)</td>
      <td>offer(o)</td>
      <td>put(o)</td>
      <td>offer(o, timeout, timeunit)</td>
    </tr>
    <tr>
      <td><strong>Remove</strong></td>
      <td>remove(o)</td>
      <td>poll()</td>
      <td>take()</td>
      <td>poll(timeout, timeunit)</td>
    </tr>
    <tr>
      <td><strong>Examine</strong></td>
      <td>element()</td>
      <td>peek()</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p><strong>BlockingQueue</strong> in <strong>Java doesn’t allow null elements</strong>, various
implementations like ArrayBlockingQueue, LinkedBlockingQueue throws
NullPointerException when you try to add null on queue</p>
  </li>
  <li>
    <p><strong>two types of BlockingQueue:</strong>
```java
a.	Bounded queue – with maximal capacity defined
BlockingQueue<String> blockingQueue = new LinkedBlockingDeque&lt;&gt;(10);</String></p>
  </li>
</ul>

<p>b.	UnBounded queue –no maximum capacity, can grow almost indefinitely
BlockingQueue<String> blockingQueue = new LinkedBlockingDeque&lt;&gt;();</String></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;u&gt;Producer-Consumer Example&lt;/u&gt;

BlockingQueue provides a **put()** method to store the element
and **take()** method to retrieve the element. Both are blocking method, which
means **put()** will block if the queue has reached its capacity and there is no
place to add a new element.

Similarly **, take()** method will block if blocking queue is empty. So, you can
see that critical requirement of the producer-consumer pattern is met right
there, you don't need to put any thread synchronization code.

```java
class Producer extends Thread {
	private BlockingQueue&lt;Integer&gt; sharedQueue;
	public Producer(BlockingQueue&lt;Integer&gt; aQueue) {
 super("PRODUCER");
 this.sharedQueue = aQueue;
	}
	public void run() { // no synchronization needed
 for (int i = 0; i &lt; 10; i++) {
 	try {
  System.out.println(getName() + " produced " + i);
  sharedQueue.put(i);
  Thread.sleep(200);	
            // if we remove sleep, put will execute 10 times, then take will execute 
             } catch (InterruptedException e) {
  e.printStackTrace();
 	}
 }
	}
}
class Consumer extends Thread {
	private BlockingQueue&lt;Integer&gt; sharedQueue;

	public Consumer(BlockingQueue&lt;Integer&gt; aQueue) {
 super("CONSUMER");
 this.sharedQueue = aQueue;
	}

	public void run() {
 try {
 	while (true) {
  Integer item = sharedQueue.take();
  System.out.println(getName() + " consumed " + item);
 	}
 } catch (InterruptedException e) {
 	e.printStackTrace();
 }
	}
}

public class BlockingQueueDemo {
	public static void main(String[] args) {
 	BlockingQueue&lt;Integer&gt; sharedQ = new LinkedBlockingQueue&lt;Integer&gt;();
 	Producer p = new Producer(sharedQ); 
 	Consumer c = new Consumer(sharedQ); 
 	p.start(); 
 	c.start(); 	
 }
}
</code></pre></div></div>

<ul>
  <li>
    <p><a href="https://javapapers.com/java/java-arrayblockingqueue/">ArrayBlockingQueue</a> –
a blocking queue class based on bounded Java Array. Once instantiated,
cannot be resized.</p>
  </li>
  <li>
    <p><strong>PriorityBlockingQueue</strong> – a priority queue based blocking queue. It is an
unbounded concurrent collection.</p>
  </li>
  <li>
    <p><strong>LinkedBlockingQueue</strong> – an optionally bounded Java concurrent collection.
Orders elements based on FIFO order.</p>
  </li>
</ul>

<h2 id="thread-yield-">Thread. yield ()</h2>

<p><strong>yield() method:</strong> Theoretically, <strong>to ‘yield’ means to let go, to give up, to
surrender</strong>. A yielding thread tells the virtual machine that it’s willing to
let other threads be scheduled in its place.</p>

<p>This indicates that it’s not doing something too critical. <strong>Note that it’s only
a hint, though, and not guaranteed to have any effect at all.</strong></p>

<ul>
  <li>
    <p>Yield is a Static method and Native too.</p>
  </li>
  <li>
    <p>Yield tells the currently executing thread to give a chance to the threads
that have equal priority in the <a href="https://howtodoinjava.com/java-5/java-executor-framework-tutorial-and-best-practices/">Thread
Pool</a>.</p>
  </li>
  <li>
    <p><strong>There is no guarantee</strong> that <strong>Yield will make the currently executing
thread to runnable state immediately</strong>.</p>
  </li>
  <li>
    <p>It can only make a <strong>thread from Running State to Runnable State</strong>, not in
wait or blocked state.</p>
  </li>
</ul>

<h2 id="what-do-you-understand-about-thread-priority">What do you understand about Thread Priority?</h2>

<p>Every thread has a priority; usually higher priority thread gets precedence in
execution but it depends on Thread Scheduler implementation that is OS
dependent. We can specify the priority of thread but it doesn’t guarantee that
higher priority thread will get executed before lower priority thread.</p>

<h2 id="how-can-we-make-sure-main-is-the-last-thread-to-finish-in-java-program">How can we make sure main() is the last thread to finish in Java Program?</h2>

<p>We can use Thread join() method to make sure all the threads created by the
program is dead before finishing the main function.</p>

<h2 id="why-wait-notify-and-notifyall-methods-have-to-be-called-from-synchronized-method-or-block">Why wait(), notify() and notifyAll() methods have to be called from synchronized method or block?</h2>

<p>When a Thread calls wait() on any Object, it must have the monitor on the Object
that it will leave and goes in wait state until any other thread call notify()
on this Object. Similarly when a thread calls notify() on any Object, it leaves
the monitor on the Object and other waiting threads can get the monitor on the
Object. Since all these methods require Thread to have the Object monitor, that
can be achieved only by synchronization, they need to be called from
synchronized method or block.</p>

<h2 id="how-can-we-achieve-thread-safety-in-java">How can we achieve thread safety in Java?</h2>

<p>There are several ways to achieve thread safety in java – <strong>synchronization,
atomic concurrent classes, implementing concurrent Lock interface, using
volatile keyword</strong>, using immutable classes and Thread safe classes.</p>

<h2 id="what-is-volatile-keyword-in-java">What is volatile keyword in Java</h2>

<p>When we use volatile keyword with a variable, all the threads read it’s value
directly from the memory and don’t cache it. This makes sure that the value read
is the same as in the memory.</p>

<h2 id="what-is-threadlocal">What is ThreadLocal?</h2>

<p>Java ThreadLocal is used to create thread-local variables. We know that all
threads of an Object share it’s variables, so if the variable is not thread
safe, we can use synchronization but if we want to avoid synchronization, we can
use ThreadLocal variables.<br />
Every thread has it’s own ThreadLocal variable and they can use it’s get() and
set() methods to get the default value or change it’s value local to Thread.
ThreadLocal instances are typically private static fields in classes that wish
to associate state with a thread</p>

<h2 id="what-is-java-thread-dump-how-can-we-get-java-thread-dump-of-a-program">What is Java Thread Dump, How can we get Java Thread dump of a Program?</h2>

<p>Thread dump is list of all the threads active in the JVM, thread dumps are very
helpful in analyzing bottlenecks in the application and analyzing deadlock
situations.</p>

<p>There are many ways using which we can generate Thread dump – Using Profiler,
Kill -3 command, <strong>jstack tool etc</strong>. I prefer jstack tool to generate thread
dump of a program because it’s easy to use and comes with JDK installation</p>

<h2 id="what-is-atomic-operation-what-are-atomic-classes-in-java-concurrency-api">What is atomic operation? What are atomic classes in Java Concurrency API?</h2>

<p>Atomic operations are performed in a single unit of task .int++ is not an atomic
operation. So by the time one threads read it’s value and increment it by one,
other thread has read the older value leading to wrong result.</p>

<p>To solve this issue, we will have to make sure that increment operation on count
is atomic, we can do that using Synchronization but Java 5
java.util.concurrent.atomic provides wrapper classes for int and long that can
be used to achieve this atomically without usage of Synchronization</p>

<h2 id="what-is-executors-class">What is Executors Class?</h2>

<p>Executors class provide utility methods for <strong>Executor, ExecutorService,
ScheduledExecutorService,</strong> ThreadFactory, and Callable classes.</p>

<p>Executors class can be used to easily create Thread Pool in java, also this is
the only class supporting execution of Callable implementations.</p>

<p><strong>What happens when an Exception occurs in a thread?</strong> <br />
<strong>Thread.UncaughtExceptionHandler</strong> is an interface, defined as nested interface
for handlers invoked when a Thread abruptly terminates due to an uncaught
exception.</p>

<p>When a thread is about to terminate due to an uncaught exception the Java
Virtual Machine will query the thread for
its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will
invoke the handler’s uncaughtException() method, passing the thread and the
exception as arguments.</p>

<p><strong>Why wait, notify and notifyAll are not inside thread class?</strong> <br />
One reason which is obvious is that Java provides lock at object level not at
thread level.</p>

<h2 id="how-do-you-check-if-a-thread-holds-a-lock-or-not-1"><strong>How do you check if a Thread holds a lock or not?</strong></h2>
<p>Boolean Thread.<em>holdsLock</em>(Obj)</p>

<h2 id="what-is-futuretask-in-java-answer"><strong>What is FutureTask in Java? (answer)</strong></h2>
<p>This class provides a base implementation of Future, it retrieve the result of
the computation. It will get the results from Feature Object.</p>

<h2 id="what-is-the-concurrency-level-of-concurrenthashmap-in-java-answer"><strong>What is the concurrency level of ConcurrentHashMap in Java? (answer)</strong></h2>
<p>ConcurrentHashMap achieves it’s scalability and thread-safety by partitioning
actual map into a number of sections. This partitioning is achieved using
concurrency level.</p>

<p>Its optional parameter of <strong>ConcurrentHashMap constructor and it’s default value
is 16.</strong> The table is internally partitioned to try to permit the indicated
number of concurrent updates without contention. To learn more about concurrency
level and internal resizing</p>

<h2 id="what-happens-if-a-thread-throws-an-exception-inside-synchronized-block-1"><strong>What happens if a thread throws an Exception inside synchronized block?</strong></h2>
<p>To answer this question, no matter how you exist synchronized block, either
normally by finishing execution or abruptly by throwing exception, thread
releases the lock it acquired while entering that synchronized block. This is
actually one of the reasons I like synchronized block over lock interface, which
requires explicit attention to release lock, generally this is achieved by
releasing the lock in a <a href="http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html">finally
block</a>.</p>
</div><section class="article__sharing d-print-none"><!-- Addthis BEGIN --><script type="text/javascript"
    src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5dd2bcde40b385b7"></script>
  <div class="addthis_inline_share_toolbox addthis_default_style"></div><!-- Addthis END -->
</section><div class="d-print-none"><footer class="article__footer"><meta itemprop="dateModified" content="2017-11-11T00:00:00+00:00"><!-- start custom article footer snippet -->

<!-- end custom article footer snippet --></footer><div class="article__section-navigator clearfix"><div class="previous"><span>PREVIOUS</span><a href="/Java-Interview-Questions-1.html">Java - Interview Questions PART-1</a></div><div class="next"><span>NEXT</span><a href="/Java-Interview-Questions-3.html">Java - Interview Questions PART-3</a></div></div></div>

</div>

<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    $(function() {
      var $this ,$scroll;
      var $articleContent = $('.js-article-content');
      var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
      var scroll = hasSidebar ? '.js-page-main' : 'html, body';
      $scroll = $(scroll);

      $articleContent.find('.highlight').each(function() {
        $this = $(this);
        $this.attr('data-lang', $this.find('code').attr('data-lang'));
      });
      $articleContent.find('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]').each(function() {
        $this = $(this);
        $this.append($('<a class="anchor d-print-none" aria-hidden="true"></a>').html('<i class="fas fa-anchor"></i>'));
      });
      $articleContent.on('click', '.anchor', function() {
        $scroll.scrollToAnchor('#' + $(this).parent().attr('id'), 400);
      });
    });
  });
})();
//alert('start .......');
document.getElementsByClassName('article__header')[0].style.display = 'none';
document.getElementsByClassName('article__info')[0].style.display = 'none';
//alert(' end .......');
 
 document.onreadystatechange = function(){
     if(document.readyState === 'complete'){
         /*code here*/
		 //alert('onreadystatechange comled ... start .......');
document.getElementsByClassName('article__header')[0].style.display = 'none';
document.getElementsByClassName('article__info')[0].style.display = 'none';
//alert('onreadystatechange comled ... end .......');
     }
}

</script></div><section class="page__comments d-print-none"></section></article><!-- start custom main bottom snippet -->

<!-- end custom main bottom snippet --></div>
            </div></div></div><div class="page__footer d-print-none"><footer class="footer py-4 js-page-footer">
  <div class="main"><div itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Satya Kaveti"><meta itemprop="url" content="/"><meta itemprop="description" content="I am an amazing person."><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"></ul>
</div>
</div>
    </div><div class="site-info mt-2">
      <div>© SatyaCodes 2020 ,
        <a title="Satya Kaveti" href="about/">Satya Kaveti's Writing</a>.
		<span>| <a href="about/">About Me</a> &nbsp |  </span>
		<span><a href="/terms.html">Terms</a> &nbsp |  </span>
		<span><a href="/contact.html">Contact</a> &nbsp |  </span>
		<span><a href="http://www.satyacodesapps.ml/" target="_blank">Our Apps</a> &nbsp |  </span>
		<span><a href="https://www.facebook.com/isatyakaveti" target="_blank"><i class="fab fa-facebook-f"></i></a> &nbsp |  </span>
		<span><a href="https://www.youtube.com/" target="_blank"><i class="fab fa-youtube-square"></i></a> &nbsp |  </span>
		<span><a href="https://in.linkedin.com/in/satyakaveti"target="_blank"><i class="fab fa-linkedin-in"></i></a> &nbsp | 
		<span>[ 
		<!-- Start of WebFreeCounter Code -->
<a href="http://www.statworker.com/" target="_blank"><img src="https://www.webfreecounter.com/hit.php?id=gfpapx&nd=7&style=2" border="0" alt="statworker.com"></a>
<!-- End of WebFreeCounter Code -->
</span>
<span><a href="https://statcounter.com/p12408441/?guest=1" target="_blank"> ]</a></span>


      </div>
    </div>
  </div>
</footer></div></div>
    </div><script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $body = $('body'), $window = $(window);
    var $pageRoot = $('.js-page-root'), $pageMain = $('.js-page-main');
    var activeCount = 0;
    function modal(options) {
      var $root = this, visible, onChange, hideWhenWindowScroll = false;
      var scrollTop;
      function setOptions(options) {
        var _options = options || {};
        visible = _options.initialVisible === undefined ? false : show;
        onChange = _options.onChange;
        hideWhenWindowScroll = _options.hideWhenWindowScroll;
      }
      function init() {
        setState(visible);
      }
      function setState(isShow) {
        if (isShow === visible) {
          return;
        }
        visible = isShow;
        if (visible) {
          activeCount++;
          scrollTop = $(window).scrollTop() || $pageMain.scrollTop();
          $root.addClass('modal--show');
          $pageMain.scrollTop(scrollTop);
          activeCount === 1 && ($pageRoot.addClass('show-modal'), $body.addClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.on('scroll', hide);
          $window.on('keyup', handleKeyup);
        } else {
          activeCount > 0 && activeCount--;
          $root.removeClass('modal--show');
          $window.scrollTop(scrollTop);
          activeCount === 0 && ($pageRoot.removeClass('show-modal'), $body.removeClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.off('scroll', hide);
          $window.off('keyup', handleKeyup);
        }
        onChange && onChange(visible);
      }
      function show() {
        setState(true);
      }
      function hide() {
        setState(false);
      }
      function handleKeyup(e) {
        // Char Code: 27  ESC
        if (e.which ===  27) {
          hide();
        }
      }
      setOptions(options);
      init();
      return {
        show: show,
        hide: hide,
        $el: $root
      };
    }
    $.fn.modal = modal;
  });
})();
</script><div class="modal modal--overflow page__search-modal d-print-none js-page-search-modal"><script>
(function () {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    // search panel
    var search = (window.search || (window.search = {}));
    var useDefaultSearchBox = window.useDefaultSearchBox === undefined ?
      true : window.useDefaultSearchBox ;

    var $searchModal = $('.js-page-search-modal');
    var $searchToggle = $('.js-search-toggle');
    var searchModal = $searchModal.modal({ onChange: handleModalChange, hideWhenWindowScroll: true });
    var modalVisible = false;
    search.searchModal = searchModal;

    var $searchBox = null;
    var $searchInput = null;
    var $searchClear = null;

    function getModalVisible() {
      return modalVisible;
    }
    search.getModalVisible = getModalVisible;

    function handleModalChange(visible) {
      modalVisible = visible;
      if (visible) {
        search.onShow && search.onShow();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].focus();
      } else {
        search.onShow && search.onHide();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].blur();
        setTimeout(function() {
          useDefaultSearchBox && ($searchInput.val(''), $searchBox.removeClass('not-empty'));
          search.clear && search.clear();
          window.pageAsideAffix && window.pageAsideAffix.refresh();
        }, 400);
      }
    }

    $searchToggle.on('click', function() {
      modalVisible ? searchModal.hide() : searchModal.show();
    });
    // Char Code: 83  S, 191 /
    $(window).on('keyup', function(e) {
      if (!modalVisible && !window.isFormElement(e.target || e.srcElement) && (e.which === 83 || e.which === 191)) {
        modalVisible || searchModal.show();
      }
    });

    if (useDefaultSearchBox) {
      $searchBox = $('.js-search-box');
      $searchInput = $searchBox.children('input');
      $searchClear = $searchBox.children('.js-icon-clear');
      search.getSearchInput = function() {
        return $searchInput.get(0);
      };
      search.getVal = function() {
        return $searchInput.val();
      };
      search.setVal = function(val) {
        $searchInput.val(val);
      };

      $searchInput.on('focus', function() {
        $(this).addClass('focus');
      });
      $searchInput.on('blur', function() {
        $(this).removeClass('focus');
      });
      $searchInput.on('input', window.throttle(function() {
        var val = $(this).val();
        if (val === '' || typeof val !== 'string') {
          search.clear && search.clear();
        } else {
          $searchBox.addClass('not-empty');
          search.onInputNotEmpty && search.onInputNotEmpty(val);
        }
      }, 400));
      $searchClear.on('click', function() {
        $searchInput.val(''); $searchBox.removeClass('not-empty');
        search.clear && search.clear();
      });
    }
  });
})();
</script><div class="search search--dark">
  <div class="main">
    <div class="search__header">Search</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--theme-dark button--pill search__cancel js-search-toggle">
        Cancel</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>
<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var search = (window.search || (window.search = {}));
  var searchData = window.TEXT_SEARCH_DATA || {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) { return null; }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function clear() {
    $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }
  function onInputNotEmpty(val) {
    $result.html(render(searchByQuery(val)));
    $resultItems = $('.search-result__item'); activeIndex = 0;
    $resultItems.eq(0).addClass('active');
  }

  search.clear = clear;
  search.onInputNotEmpty = onInputNotEmpty;

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  // Char Code: 13  Enter, 37  ⬅, 38  ⬆, 39  ➡, 40  ⬇
  $(window).on('keyup', function(e) {
    var modalVisible = search.getModalVisible && search.getModalVisible();
    if (modalVisible) {
      if (e.which === 38) {
        modalVisible && moveActiveIndex('up');
      } else if (e.which === 40) {
        modalVisible && moveActiveIndex('down');
      } else if (e.which === 13) {
        modalVisible && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });
});
</script></div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function affix(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroll,
        offsetBottom = 0, scrollTarget = window, scroll = window.document, disabled = false, isOverallScroller = true,
        rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop,
        hasInit = false, curState;

      function setOptions(options) {
        var _options = options || {};
        _options.offsetBottom && (offsetBottom = _options.offsetBottom);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroll && (scroll = _options.scroll);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $scrollTarget = $(scrollTarget);
        isOverallScroller = window.isOverallScroller($scrollTarget[0]);
        $scroll = $(scroll);
      }
      function preCalc() {
        top();
        rootHeight = $root.outerHeight();
        rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
        rootLeft = $root.offset().left;
      }
      function calc(needPreCalc) {
        needPreCalc && preCalc();
        scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
        rootBottomTop = scrollBottom - rootTop;
      }
      function top() {
        if (curState !== 'top') {
          $root.removeClass('fixed').css({
            left: 0,
            top: 0
          });
          curState = 'top';
        }
      }
      function fixed() {
        if (curState !== 'fixed') {
          $root.addClass('fixed').css({
            left: rootLeft + 'px',
            top: 0
          });
          curState = 'fixed';
        }
      }
      function bottom() {
        if (curState !== 'bottom') {
          $root.removeClass('fixed').css({
            left: 0,
            top: rootBottomTop + 'px'
          });
          curState = 'bottom';
        }
      }
      function setState() {
        var scrollTop = $scrollTarget.scrollTop();
        if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
          fixed();
        } else if (scrollTop < rootTop) {
          top();
        } else {
          bottom();
        }
      }
      function init() {
        if(!hasInit) {
          var interval, timeout;
          calc(true); setState();
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState();
          });
          $window.on('resize', function() {
            disabled || (calc(true), setState());
          });
          hasInit = true;
        }
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true, { animation: false }); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function toc(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroller, $tocUl = $('<ul class="toc toc--ellipsis"></ul>'), $tocLi, $headings, $activeLast, $activeCur,
        selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false,
        headingsPos, scrolling = false, hasRendered = false, hasInit = false;

      function setOptions(options) {
        var _options = options || {};
        _options.selectors && (selectors = _options.selectors);
        _options.container && (container = _options.container);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroller && (scroller = _options.scroller);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $headings = $(container).find(selectors).filter('[id]');
        $scrollTarget = $(scrollTarget);
        $scroller = $(scroller);
      }
      function calc() {
        headingsPos = [];
        $headings.each(function() {
          headingsPos.push(Math.floor($(this).position().top));
        });
      }
      function setState(element, disabled) {
        var scrollTop = $scrollTarget.scrollTop(), i;
        if (disabled || !headingsPos || headingsPos.length < 1) { return; }
        if (element) {
          $activeCur = element;
        } else {
          for (i = 0; i < headingsPos.length; i++) {
            if (scrollTop >= headingsPos[i]) {
              $activeCur = $tocLi.eq(i);
            } else {
              $activeCur || ($activeCur = $tocLi.eq(i));
              break;
            }
          }
        }
        $activeLast && $activeLast.removeClass('active');
        ($activeLast = $activeCur).addClass('active');
      }
      function render() {
        if(!hasRendered) {
          $root.append($tocUl);
          $headings.each(function() {
            var $this = $(this);
            $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
              .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
          });
          $tocLi = $tocUl.children('li');
          $tocUl.on('click', 'a', function(e) {
            e.preventDefault();
            var $this = $(this);
            scrolling = true;
            setState($this.parent());
            $scroller.scrollToAnchor($this.attr('href'), 400, function() {
              scrolling = false;
            });
          });
        }
        hasRendered = true;
      }
      function init() {
        var interval, timeout;
        if(!hasInit) {
          render(); calc(); setState(null, scrolling);
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState(null, scrolling);
          });
          $window.on('resize', window.throttle(function() {
            if (!disabled) {
              render(); calc(); setState(null, scrolling);
            }
          }, 100));
        }
        hasInit = true;
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();
/*(function () {

})();*/
</script><script>
  /* toc must before affix, since affix need to konw toc' height. */(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  var TOC_SELECTOR = window.TEXT_VARIABLES.site.toc.selectors;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window);
    var $articleContent = $('.js-article-content');
    var $tocRoot = $('.js-toc-root'), $col2 = $('.js-col-aside');
    var toc;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
    var hasToc = $articleContent.find(TOC_SELECTOR).length > 0;

    function disabled() {
      return $col2.css('display') === 'none' || !hasToc;
    }

    tocDisabled = disabled();

    toc = $tocRoot.toc({
      selectors: TOC_SELECTOR,
      container: $articleContent,
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      tocDisabled = disabled();
      toc && toc.setOptions({
        disabled: tocDisabled
      });
    }, 100));

  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $pageFooter = $('.js-page-footer');
    var $pageAside = $('.js-page-aside');
    var affix;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');

    affix = $pageAside.affix({
      offsetBottom: $pageFooter.outerHeight(),
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      scroll: hasSidebar ? $('.js-page-main').children() : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      affix && affix.setOptions({
        disabled: tocDisabled
      });
    }, 100));

    window.pageAsideAffix = affix;
  });
})();
</script>
    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();
</script>
  </body>
</html>