<!DOCTYPE html><html lang="en">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>SatyaCodes - MongoDB - Interview Questions</title>

<meta name="description" content="MongoDB Interview QuestionsIntroduction to MongoDBWhen dealing with data, there are two types of data as we know – (i) structured data and (ii) unstructured ...">
<link rel="canonical" href="/MongoDB-Interview.html"><link rel="alternate" type="application/rss+xml" title="SatyaCodes" href="/feed.xml"><!-- start favicons snippet, use https://realfavicongenerator.net/ --><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicons snippet -->
 <link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" >
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>MongoDB - Interview Questions | SatyaCodes</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="MongoDB - Interview Questions" />
<meta name="author" content="Satya Kaveti" />
<meta property="og:locale" content="en" />
<meta name="description" content="MongoDB Interview Questions Introduction to MongoDB When dealing with data, there are two types of data as we know – (i) structured data and (ii) unstructured data. Structured data is usually stored in a tabular form whereas unstructured data is not. To manage huge sets of unstructured data like log or IoT data, a NoSQL database is used. Now, what is MongoDB? MongoDB is an open-source NoSQL database written in C++ language. It uses JSON-like documents with optional schemas. It provides easy scalability and is a cross-platform, document-oriented database. MongoDB works on the concept of Collection and Document. It combines the ability to scale out with features such as secondary indexes, range queries, sorting, aggregations, and geospatial indexes. MongoDB is developed by MongoDB Inc. and licensed under the Server Side Public License (SSPL). Crack your next tech interview with confidence! Take a free mock interview, get instant⚡️ feedback and recommendation💡 Take Free Mock Interview MongoDB Basic Interview Questions 1. What are some of the advantages of MongoDB? Some advantages of MongoDB are as follows: MongoDB supports field, range-based, string pattern matching type queries. for searching the data in the database MongoDB support primary and secondary index on any fields MongoDB basically uses JavaScript objects in place of procedures MongoDB uses a dynamic database schema MongoDB is very easy to scale up or down MongoDB has inbuilt support for data partitioning (Sharding). 2. What is a Document in MongoDB? A Document in MongoDB is an ordered set of keys with associated values. It is represented by a map, hash, or dictionary. In JavaScript, documents are represented as objects: {&quot;greeting&quot; : &quot;Hello world!&quot;} Complex documents will contain multiple key/value pairs: {&quot;greeting&quot; : &quot;Hello world!&quot;, &quot;views&quot; : 3} 3. What is a Collection in MongoDB? A collection in MongoDB is a group of documents. If a document is the MongoDB analog of a row in a relational database, then a collection can be thought of as the analog to a table. Documents within a single collection can have any number of different “shapes.”, i.e. collections have dynamic schemas. For example, both of the following documents could be stored in a single collection: {&quot;greeting&quot; : &quot;Hello world!&quot;, &quot;views&quot;: 3} {&quot;signoff&quot;: &quot;Good bye&quot;} You can download a PDF version of Mongodb Interview Questions. Download PDF 4. What are Databases in MongoDB? MongoDB groups collections into databases. MongoDB can host several databases, each grouping together collections. Some reserved database names are as follows: admin local config 5. What is the Mongo Shell? It is a JavaScript shell that allows interaction with a MongoDB instance from the command line. With that one can perform administrative functions, inspecting an instance, or exploring MongoDB. To start the shell, run the mongo executable: $ mongod $ mongo MongoDB shell version: 4.2.0 connecting to: test &gt; The shell is a full-featured JavaScript interpreter, capable of running arbitrary JavaScript programs. Let’s see how basic math works on this: &gt; x = 100; 200 &gt; x / 5; 20 6. How does Scale-Out occur in MongoDB? The document-oriented data model of MongoDB makes it easier to split data across multiple servers. Balancing and loading data across a cluster is done by MongoDB. It then redistributes documents automatically. The mongos acts as a query router, providing an interface between client applications and the sharded cluster. Config servers store metadata and configuration settings for the cluster. MongoDB uses the config servers to manage distributed locks. Each sharded cluster must have its own config servers. 7. What are some features of MongoDB? Indexing: It supports generic secondary indexes and provides unique, compound, geospatial, and full-text indexing capabilities as well. Aggregation: It provides an aggregation framework based on the concept of data processing pipelines. Special collection and index types: It supports time-to-live (TTL) collections for data that should expire at a certain time File storage: It supports an easy-to-use protocol for storing large files and file metadata. Sharding: Sharding is the process of splitting data up across machines. 8. How to add data in MongoDB? The basic method for adding data to MongoDB is “inserts”. To insert a single document, use the collection’s insertOne method: &gt; db.books.insertOne({&quot;title&quot; : &quot;Start With Why&quot;}) For inserting multiple documents into a collection, we use insertMany. This method enables passing an array of documents to the database. 9. How do you Update a Document? Once a document is stored in the database, it can be changed using one of several update methods: updateOne, updateMany, and replaceOne. updateOne and updateMany each takes a filter document as their first parameter and a modifier document, which describes changes to make, as the second parameter. replaceOne also takes a filter as the first parameter, but as the second parameter replaceOne expects a document with which it will replace the document matching the filter. For example, in order to replace a document: { &quot;_id&quot; : ObjectId(&quot;4b2b9f67a1f631733d917a7a&quot;), &quot;name&quot; : &quot;alice&quot;, &quot;friends&quot; : 24, &quot;enemies&quot; : 2 } 10. How do you Delete a Document? The CRUD API in MongoDB provides deleteOne and deleteMany for this purpose. Both of these methods take a filter document as their first parameter. The filter specifies a set of criteria to match against in removing documents. For example: &gt; db.books.deleteOne({&quot;_id&quot; : 3}) 11. How to perform queries in MongoDB? The find method is used to perform queries in MongoDB. Querying returns a subset of documents in a collection, from no documents at all to the entire collection. Which documents get returned is determined by the first argument to find, which is a document specifying the query criteria. Example: &gt; db.users.find({&quot;age&quot; : 24}) 12. What are the data types in MongoDB? MongoDB supports a wide range of data types as values in documents. Documents in MongoDB are similar to objects in JavaScript. Along with JSON’s essential key/value–pair nature, MongoDB adds support for a number of additional data types. The common data types in MongoDB are: Null {&quot;x&quot; : null} Boolean {&quot;x&quot; : true} Number {&quot;x&quot; : 4} String {&quot;x&quot; : &quot;foobar&quot;} Date {&quot;x&quot; : new Date()} Regular expression {&quot;x&quot; : /foobar/i} Array {&quot;x&quot; : [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]} Embedded document {&quot;x&quot; : {&quot;foo&quot; : &quot;bar&quot;}} Object ID {&quot;x&quot; : ObjectId()} Binary Data Binary data is a string of arbitrary bytes. Code {&quot;x&quot; : function() { /* ... */ }} 13. When to use MongoDB? You should use MongoDB when you are building internet and business applications that need to evolve quickly and scale elegantly. MongoDB is popular with developers of all kinds who are building scalable applications using agile methodologies. MongoDB is a great choice if one needs to: Support a rapid iterative development. Scale to high levels of read and write traffic - MongoDB supports horizontal scaling through Sharding, distributing data across several machines, and facilitating high throughput operations with large sets of data. Scale your data repository to a massive size. Evolve the type of deployment as the business changes. Store, manage and search data with text, geospatial, or time-series dimensions. MongoDB Intermediate Interview Questions 14. How is Querying done in MongoDB? The find method is used to perform queries in MongoDB. Querying returns a subset of documents in a collection, from no documents at all to the entire collection. Which documents get returned is determined by the first argument to find, which is a document specifying the query criteria. For example: If we have a string we want to match, such as a “username” key with the value “alice”, we use that key/value pair instead: &gt; db.users.find({&quot;username&quot; : &quot;alice&quot;}) 15. Explain the term “Indexing” in MongoDB. In MongoDB, indexes help in efficiently resolving queries. What an Index does is that it stores a small part of the data set in a form that is easy to traverse. The index stores the value of the specific field or set of fields, ordered by the value of the field as specified in the index. MongoDB’s indexes work almost identically to typical relational database indexes. Indexes look at an ordered list with references to the content. These in turn allow MongoDB to query orders of magnitude faster. To create an index, use the createIndex collection method. For example: &gt; db.users.find({&quot;username&quot;: &quot;user101&quot;}).explain(&quot;executionStats&quot;) Here, executionStats mode helps us understand the effect of using an index to satisfy queries. 16. What are Geospatial Indexes in MongoDB? MongoDB has two types of geospatial indexes: 2dsphere and 2d. 2dsphere indexes work with spherical geometries that model the surface of the earth based on the WGS84 datum. This datum model the surface of the earth as an oblate spheroid, meaning that there is some flattening at the poles. Distance calculations using 2sphere indexes, therefore, take the shape of the earth into account and provide a more accurate treatment of distance between, for example, two cities, than do 2d indexes. Use 2d indexes for points stored on a two-dimensional plane. 2dsphere allows you to specify geometries for points, lines, and polygons in the GeoJSON format. A point is given by a two-element array, representing [longitude, latitude]: { &quot;name&quot; : &quot;New York City&quot;, &quot;loc&quot; : { &quot;type&quot; : &quot;Point&quot;, &quot;coordinates&quot; : [50, 2] } } A line is given by an array of points: { &quot;name&quot; : &quot;Hudson River&quot;, &quot;loc&quot; : { &quot;type&quot; : &quot;LineString&quot;, &quot;coordinates&quot; : [[0,1], [0,2], [1,2]] } } 17. Explain the process of Sharding. Sharding is the process of splitting data up across machines. We also use the term “partitioning” sometimes to describe this concept. We can store more data and handle more load without requiring larger or more powerful machines, by putting a subset of data on each machine. In the figure below, RS0 and RS1 are shards. MongoDB’s sharding allows you to create a cluster of many machines (shards) and break up a collection across them, putting a subset of data on each shard. This allows your application to grow beyond the resource limits of a standalone server or replica set. Sharded Client Connection Non Sharded Client Connection 18. Explain the SET Modifier in MongoDB? If the value of a field does not yet exist, the “$set” sets the value. This can be useful for updating schemas or adding user-defined keys. Example: &gt; db.users.findOne() { &quot;_id&quot; : ObjectId(&quot;4b253b067525f35f94b60a31&quot;), &quot;name&quot; : &quot;alice&quot;, &quot;age&quot; : 23, &quot;sex&quot; : &quot;female&quot;, &quot;location&quot; : &quot;India&quot; } To add a field to this, we use “$set”: &gt; db.users.updateOne({&quot;_id&quot; : ObjectId(&quot;4b253b067525f35f94b60a31&quot;)}, ... {&quot;$set&quot; : {&quot;favorite book&quot; : &quot;Start with Why&quot;}}) MongoDB Advanced Interview Questions 19. What do you mean by Transactions? A transaction is a logical unit of processing in a database that includes one or more database operations, which can be read or write operations. Transactions provide a useful feature in MongoDB to ensure consistency. MongoDB provides two APIs to use transactions. Core API: It is a similar syntax to relational databases (e.g., start_transaction and commit_transaction) Call-back API: This is the recommended approach to using transactions. It starts a transaction, executes the specified operations, and commits (or aborts on the error). It also automatically incorporates error handling logic for “TransientTransactionError” and”UnknownTransactionCommitResult”. 20. What are MongoDB Charts? MongoDB Charts is a new, integrated tool in MongoDB for data visualization. MongoDB Charts offers the best way to create visualizations using data from a MongoDB database. It allows users to perform quick data representation from a database without writing code in a programming language such as Java or Python. The two different implementations of MongoDB Charts are: MongoDB Charts PaaS (Platform as a Service) MongoDB Charts Server 21. What is the Aggregation Framework in MongoDB? The aggregation framework is a set of analytics tools within MongoDB that allow you to do analytics on documents in one or more collections. The aggregation framework is based on the concept of a pipeline. With an aggregation pipeline, we take input from a MongoDB collection and pass the documents from that collection through one or more stages, each of which performs a different operation on its inputs (See figure below). Each stage takes as input whatever the stage before it produced as output. The inputs and outputs for all stages are documents—a stream of documents. 22. Explain the concept of pipeline in the MongoDB aggregation framework. An individual stage of an aggregation pipeline is a data processing unit. It takes in a stream of input documents one at a time, processes each document one at a time, and produces an output stream of documents one at a time (see figure below). 23. What is a Replica Set in MongoDB? To keep identical copies of your data on multiple servers, we use replication. It is recommended for all production deployments. Use replication to keep your application running and your data safe, even if something happens to one or more of your servers. Such replication can be created by a replica set with MongoDB. A replica set is a group of servers with one primary, the server taking writes, and multiple secondaries, servers that keep copies of the primary’s data. If the primary crashes, the secondaries can elect a new primary from amongst themselves. 24. Explain the Replication Architecture in MongoDB. The following diagram depicts the architecture diagram of a simple replica set cluster with only three server nodes – one primary node and two secondary nodes: In the preceding model, the PRIMARY database is the only active replica set member that receives write operations from database clients. The PRIMARY database saves data changes in the Oplog. Changes saved in the Oplog are sequential—that is, saved in the order that they are received and executed. The SECONDARY database is querying the PRIMARY database for new changes in the Oplog. If there are any changes, then Oplog entries are copied from PRIMARY to SECONDARY as soon as they are created on the PRIMARY node. Then, the SECONDARY database applies changes from the Oplog to its own datafiles. Oplog entries are applied in the same order they were inserted in the log. As a result, datafiles on SECONDARY are kept in sync with changes on PRIMARY. Usually, SECONDARY databases copy data changes directly from PRIMARY. Sometimes a SECONDARY database can replicate data from another SECONDARY. This type of replication is called Chained Replication because it is a two-step replication process. Chained replication is useful in certain replication topologies, and it is enabled by default in MongoDB. 25. What are some utilities for backup and restore in MongoDB? The mongo shell does not include functions for exporting, importing, backup, or restore. However, MongoDB has created methods for accomplishing this, so that no scripting work or complex GUIs are needed. For this, several utility scripts are provided that can be used to get data in or out of the database in bulk. These utility scripts are: mongoimport mongoexport mongodump mongorestore Conclusion 26. Conclusion MongoDB is a powerful, flexible, and scalable general-purpose database. It combines the ability to scale out with features such as secondary indexes, range queries, sorting, aggregations, and geospatial indexes. Thus, in conclusion, MongoDB is: Supports Indexing Designed to scale Rich with Features High Performance Load Balancing Supports sharding Although MongoDB is powerful, incorporating many features from relational systems, it is not intended to do everything that a relational database does. For some functionality, the database server offloads processing and logic to the client-side (handled either by the drivers or by a user’s application code). Its maintenance of this streamlined design is one of the reasons MongoDB can achieve such high performance. Here are few References to understand MongoDB in-depth: https://www.mongodb.com/2 https://docs.mongodb.com" />
<meta property="og:description" content="MongoDB Interview Questions Introduction to MongoDB When dealing with data, there are two types of data as we know – (i) structured data and (ii) unstructured data. Structured data is usually stored in a tabular form whereas unstructured data is not. To manage huge sets of unstructured data like log or IoT data, a NoSQL database is used. Now, what is MongoDB? MongoDB is an open-source NoSQL database written in C++ language. It uses JSON-like documents with optional schemas. It provides easy scalability and is a cross-platform, document-oriented database. MongoDB works on the concept of Collection and Document. It combines the ability to scale out with features such as secondary indexes, range queries, sorting, aggregations, and geospatial indexes. MongoDB is developed by MongoDB Inc. and licensed under the Server Side Public License (SSPL). Crack your next tech interview with confidence! Take a free mock interview, get instant⚡️ feedback and recommendation💡 Take Free Mock Interview MongoDB Basic Interview Questions 1. What are some of the advantages of MongoDB? Some advantages of MongoDB are as follows: MongoDB supports field, range-based, string pattern matching type queries. for searching the data in the database MongoDB support primary and secondary index on any fields MongoDB basically uses JavaScript objects in place of procedures MongoDB uses a dynamic database schema MongoDB is very easy to scale up or down MongoDB has inbuilt support for data partitioning (Sharding). 2. What is a Document in MongoDB? A Document in MongoDB is an ordered set of keys with associated values. It is represented by a map, hash, or dictionary. In JavaScript, documents are represented as objects: {&quot;greeting&quot; : &quot;Hello world!&quot;} Complex documents will contain multiple key/value pairs: {&quot;greeting&quot; : &quot;Hello world!&quot;, &quot;views&quot; : 3} 3. What is a Collection in MongoDB? A collection in MongoDB is a group of documents. If a document is the MongoDB analog of a row in a relational database, then a collection can be thought of as the analog to a table. Documents within a single collection can have any number of different “shapes.”, i.e. collections have dynamic schemas. For example, both of the following documents could be stored in a single collection: {&quot;greeting&quot; : &quot;Hello world!&quot;, &quot;views&quot;: 3} {&quot;signoff&quot;: &quot;Good bye&quot;} You can download a PDF version of Mongodb Interview Questions. Download PDF 4. What are Databases in MongoDB? MongoDB groups collections into databases. MongoDB can host several databases, each grouping together collections. Some reserved database names are as follows: admin local config 5. What is the Mongo Shell? It is a JavaScript shell that allows interaction with a MongoDB instance from the command line. With that one can perform administrative functions, inspecting an instance, or exploring MongoDB. To start the shell, run the mongo executable: $ mongod $ mongo MongoDB shell version: 4.2.0 connecting to: test &gt; The shell is a full-featured JavaScript interpreter, capable of running arbitrary JavaScript programs. Let’s see how basic math works on this: &gt; x = 100; 200 &gt; x / 5; 20 6. How does Scale-Out occur in MongoDB? The document-oriented data model of MongoDB makes it easier to split data across multiple servers. Balancing and loading data across a cluster is done by MongoDB. It then redistributes documents automatically. The mongos acts as a query router, providing an interface between client applications and the sharded cluster. Config servers store metadata and configuration settings for the cluster. MongoDB uses the config servers to manage distributed locks. Each sharded cluster must have its own config servers. 7. What are some features of MongoDB? Indexing: It supports generic secondary indexes and provides unique, compound, geospatial, and full-text indexing capabilities as well. Aggregation: It provides an aggregation framework based on the concept of data processing pipelines. Special collection and index types: It supports time-to-live (TTL) collections for data that should expire at a certain time File storage: It supports an easy-to-use protocol for storing large files and file metadata. Sharding: Sharding is the process of splitting data up across machines. 8. How to add data in MongoDB? The basic method for adding data to MongoDB is “inserts”. To insert a single document, use the collection’s insertOne method: &gt; db.books.insertOne({&quot;title&quot; : &quot;Start With Why&quot;}) For inserting multiple documents into a collection, we use insertMany. This method enables passing an array of documents to the database. 9. How do you Update a Document? Once a document is stored in the database, it can be changed using one of several update methods: updateOne, updateMany, and replaceOne. updateOne and updateMany each takes a filter document as their first parameter and a modifier document, which describes changes to make, as the second parameter. replaceOne also takes a filter as the first parameter, but as the second parameter replaceOne expects a document with which it will replace the document matching the filter. For example, in order to replace a document: { &quot;_id&quot; : ObjectId(&quot;4b2b9f67a1f631733d917a7a&quot;), &quot;name&quot; : &quot;alice&quot;, &quot;friends&quot; : 24, &quot;enemies&quot; : 2 } 10. How do you Delete a Document? The CRUD API in MongoDB provides deleteOne and deleteMany for this purpose. Both of these methods take a filter document as their first parameter. The filter specifies a set of criteria to match against in removing documents. For example: &gt; db.books.deleteOne({&quot;_id&quot; : 3}) 11. How to perform queries in MongoDB? The find method is used to perform queries in MongoDB. Querying returns a subset of documents in a collection, from no documents at all to the entire collection. Which documents get returned is determined by the first argument to find, which is a document specifying the query criteria. Example: &gt; db.users.find({&quot;age&quot; : 24}) 12. What are the data types in MongoDB? MongoDB supports a wide range of data types as values in documents. Documents in MongoDB are similar to objects in JavaScript. Along with JSON’s essential key/value–pair nature, MongoDB adds support for a number of additional data types. The common data types in MongoDB are: Null {&quot;x&quot; : null} Boolean {&quot;x&quot; : true} Number {&quot;x&quot; : 4} String {&quot;x&quot; : &quot;foobar&quot;} Date {&quot;x&quot; : new Date()} Regular expression {&quot;x&quot; : /foobar/i} Array {&quot;x&quot; : [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]} Embedded document {&quot;x&quot; : {&quot;foo&quot; : &quot;bar&quot;}} Object ID {&quot;x&quot; : ObjectId()} Binary Data Binary data is a string of arbitrary bytes. Code {&quot;x&quot; : function() { /* ... */ }} 13. When to use MongoDB? You should use MongoDB when you are building internet and business applications that need to evolve quickly and scale elegantly. MongoDB is popular with developers of all kinds who are building scalable applications using agile methodologies. MongoDB is a great choice if one needs to: Support a rapid iterative development. Scale to high levels of read and write traffic - MongoDB supports horizontal scaling through Sharding, distributing data across several machines, and facilitating high throughput operations with large sets of data. Scale your data repository to a massive size. Evolve the type of deployment as the business changes. Store, manage and search data with text, geospatial, or time-series dimensions. MongoDB Intermediate Interview Questions 14. How is Querying done in MongoDB? The find method is used to perform queries in MongoDB. Querying returns a subset of documents in a collection, from no documents at all to the entire collection. Which documents get returned is determined by the first argument to find, which is a document specifying the query criteria. For example: If we have a string we want to match, such as a “username” key with the value “alice”, we use that key/value pair instead: &gt; db.users.find({&quot;username&quot; : &quot;alice&quot;}) 15. Explain the term “Indexing” in MongoDB. In MongoDB, indexes help in efficiently resolving queries. What an Index does is that it stores a small part of the data set in a form that is easy to traverse. The index stores the value of the specific field or set of fields, ordered by the value of the field as specified in the index. MongoDB’s indexes work almost identically to typical relational database indexes. Indexes look at an ordered list with references to the content. These in turn allow MongoDB to query orders of magnitude faster. To create an index, use the createIndex collection method. For example: &gt; db.users.find({&quot;username&quot;: &quot;user101&quot;}).explain(&quot;executionStats&quot;) Here, executionStats mode helps us understand the effect of using an index to satisfy queries. 16. What are Geospatial Indexes in MongoDB? MongoDB has two types of geospatial indexes: 2dsphere and 2d. 2dsphere indexes work with spherical geometries that model the surface of the earth based on the WGS84 datum. This datum model the surface of the earth as an oblate spheroid, meaning that there is some flattening at the poles. Distance calculations using 2sphere indexes, therefore, take the shape of the earth into account and provide a more accurate treatment of distance between, for example, two cities, than do 2d indexes. Use 2d indexes for points stored on a two-dimensional plane. 2dsphere allows you to specify geometries for points, lines, and polygons in the GeoJSON format. A point is given by a two-element array, representing [longitude, latitude]: { &quot;name&quot; : &quot;New York City&quot;, &quot;loc&quot; : { &quot;type&quot; : &quot;Point&quot;, &quot;coordinates&quot; : [50, 2] } } A line is given by an array of points: { &quot;name&quot; : &quot;Hudson River&quot;, &quot;loc&quot; : { &quot;type&quot; : &quot;LineString&quot;, &quot;coordinates&quot; : [[0,1], [0,2], [1,2]] } } 17. Explain the process of Sharding. Sharding is the process of splitting data up across machines. We also use the term “partitioning” sometimes to describe this concept. We can store more data and handle more load without requiring larger or more powerful machines, by putting a subset of data on each machine. In the figure below, RS0 and RS1 are shards. MongoDB’s sharding allows you to create a cluster of many machines (shards) and break up a collection across them, putting a subset of data on each shard. This allows your application to grow beyond the resource limits of a standalone server or replica set. Sharded Client Connection Non Sharded Client Connection 18. Explain the SET Modifier in MongoDB? If the value of a field does not yet exist, the “$set” sets the value. This can be useful for updating schemas or adding user-defined keys. Example: &gt; db.users.findOne() { &quot;_id&quot; : ObjectId(&quot;4b253b067525f35f94b60a31&quot;), &quot;name&quot; : &quot;alice&quot;, &quot;age&quot; : 23, &quot;sex&quot; : &quot;female&quot;, &quot;location&quot; : &quot;India&quot; } To add a field to this, we use “$set”: &gt; db.users.updateOne({&quot;_id&quot; : ObjectId(&quot;4b253b067525f35f94b60a31&quot;)}, ... {&quot;$set&quot; : {&quot;favorite book&quot; : &quot;Start with Why&quot;}}) MongoDB Advanced Interview Questions 19. What do you mean by Transactions? A transaction is a logical unit of processing in a database that includes one or more database operations, which can be read or write operations. Transactions provide a useful feature in MongoDB to ensure consistency. MongoDB provides two APIs to use transactions. Core API: It is a similar syntax to relational databases (e.g., start_transaction and commit_transaction) Call-back API: This is the recommended approach to using transactions. It starts a transaction, executes the specified operations, and commits (or aborts on the error). It also automatically incorporates error handling logic for “TransientTransactionError” and”UnknownTransactionCommitResult”. 20. What are MongoDB Charts? MongoDB Charts is a new, integrated tool in MongoDB for data visualization. MongoDB Charts offers the best way to create visualizations using data from a MongoDB database. It allows users to perform quick data representation from a database without writing code in a programming language such as Java or Python. The two different implementations of MongoDB Charts are: MongoDB Charts PaaS (Platform as a Service) MongoDB Charts Server 21. What is the Aggregation Framework in MongoDB? The aggregation framework is a set of analytics tools within MongoDB that allow you to do analytics on documents in one or more collections. The aggregation framework is based on the concept of a pipeline. With an aggregation pipeline, we take input from a MongoDB collection and pass the documents from that collection through one or more stages, each of which performs a different operation on its inputs (See figure below). Each stage takes as input whatever the stage before it produced as output. The inputs and outputs for all stages are documents—a stream of documents. 22. Explain the concept of pipeline in the MongoDB aggregation framework. An individual stage of an aggregation pipeline is a data processing unit. It takes in a stream of input documents one at a time, processes each document one at a time, and produces an output stream of documents one at a time (see figure below). 23. What is a Replica Set in MongoDB? To keep identical copies of your data on multiple servers, we use replication. It is recommended for all production deployments. Use replication to keep your application running and your data safe, even if something happens to one or more of your servers. Such replication can be created by a replica set with MongoDB. A replica set is a group of servers with one primary, the server taking writes, and multiple secondaries, servers that keep copies of the primary’s data. If the primary crashes, the secondaries can elect a new primary from amongst themselves. 24. Explain the Replication Architecture in MongoDB. The following diagram depicts the architecture diagram of a simple replica set cluster with only three server nodes – one primary node and two secondary nodes: In the preceding model, the PRIMARY database is the only active replica set member that receives write operations from database clients. The PRIMARY database saves data changes in the Oplog. Changes saved in the Oplog are sequential—that is, saved in the order that they are received and executed. The SECONDARY database is querying the PRIMARY database for new changes in the Oplog. If there are any changes, then Oplog entries are copied from PRIMARY to SECONDARY as soon as they are created on the PRIMARY node. Then, the SECONDARY database applies changes from the Oplog to its own datafiles. Oplog entries are applied in the same order they were inserted in the log. As a result, datafiles on SECONDARY are kept in sync with changes on PRIMARY. Usually, SECONDARY databases copy data changes directly from PRIMARY. Sometimes a SECONDARY database can replicate data from another SECONDARY. This type of replication is called Chained Replication because it is a two-step replication process. Chained replication is useful in certain replication topologies, and it is enabled by default in MongoDB. 25. What are some utilities for backup and restore in MongoDB? The mongo shell does not include functions for exporting, importing, backup, or restore. However, MongoDB has created methods for accomplishing this, so that no scripting work or complex GUIs are needed. For this, several utility scripts are provided that can be used to get data in or out of the database in bulk. These utility scripts are: mongoimport mongoexport mongodump mongorestore Conclusion 26. Conclusion MongoDB is a powerful, flexible, and scalable general-purpose database. It combines the ability to scale out with features such as secondary indexes, range queries, sorting, aggregations, and geospatial indexes. Thus, in conclusion, MongoDB is: Supports Indexing Designed to scale Rich with Features High Performance Load Balancing Supports sharding Although MongoDB is powerful, incorporating many features from relational systems, it is not intended to do everything that a relational database does. For some functionality, the database server offloads processing and logic to the client-side (handled either by the drivers or by a user’s application code). Its maintenance of this streamlined design is one of the reasons MongoDB can achieve such high performance. Here are few References to understand MongoDB in-depth: https://www.mongodb.com/2 https://docs.mongodb.com" />
<meta property="og:site_name" content="SatyaCodes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-11T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="MongoDB - Interview Questions" />
<script type="application/ld+json">
{"datePublished":"2020-07-11T00:00:00+00:00","dateModified":"2020-07-11T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/MongoDB-Interview.html"},"author":{"@type":"Person","name":"Satya Kaveti"},"@type":"BlogPosting","description":"MongoDB Interview Questions Introduction to MongoDB When dealing with data, there are two types of data as we know – (i) structured data and (ii) unstructured data. Structured data is usually stored in a tabular form whereas unstructured data is not. To manage huge sets of unstructured data like log or IoT data, a NoSQL database is used. Now, what is MongoDB? MongoDB is an open-source NoSQL database written in C++ language. It uses JSON-like documents with optional schemas. It provides easy scalability and is a cross-platform, document-oriented database. MongoDB works on the concept of Collection and Document. It combines the ability to scale out with features such as secondary indexes, range queries, sorting, aggregations, and geospatial indexes. MongoDB is developed by MongoDB Inc. and licensed under the Server Side Public License (SSPL). Crack your next tech interview with confidence! Take a free mock interview, get instant⚡️ feedback and recommendation💡 Take Free Mock Interview MongoDB Basic Interview Questions 1. What are some of the advantages of MongoDB? Some advantages of MongoDB are as follows: MongoDB supports field, range-based, string pattern matching type queries. for searching the data in the database MongoDB support primary and secondary index on any fields MongoDB basically uses JavaScript objects in place of procedures MongoDB uses a dynamic database schema MongoDB is very easy to scale up or down MongoDB has inbuilt support for data partitioning (Sharding). 2. What is a Document in MongoDB? A Document in MongoDB is an ordered set of keys with associated values. It is represented by a map, hash, or dictionary. In JavaScript, documents are represented as objects: {&quot;greeting&quot; : &quot;Hello world!&quot;} Complex documents will contain multiple key/value pairs: {&quot;greeting&quot; : &quot;Hello world!&quot;, &quot;views&quot; : 3} 3. What is a Collection in MongoDB? A collection in MongoDB is a group of documents. If a document is the MongoDB analog of a row in a relational database, then a collection can be thought of as the analog to a table. Documents within a single collection can have any number of different “shapes.”, i.e. collections have dynamic schemas. For example, both of the following documents could be stored in a single collection: {&quot;greeting&quot; : &quot;Hello world!&quot;, &quot;views&quot;: 3} {&quot;signoff&quot;: &quot;Good bye&quot;} You can download a PDF version of Mongodb Interview Questions. Download PDF 4. What are Databases in MongoDB? MongoDB groups collections into databases. MongoDB can host several databases, each grouping together collections. Some reserved database names are as follows: admin local config 5. What is the Mongo Shell? It is a JavaScript shell that allows interaction with a MongoDB instance from the command line. With that one can perform administrative functions, inspecting an instance, or exploring MongoDB. To start the shell, run the mongo executable: $ mongod $ mongo MongoDB shell version: 4.2.0 connecting to: test &gt; The shell is a full-featured JavaScript interpreter, capable of running arbitrary JavaScript programs. Let’s see how basic math works on this: &gt; x = 100; 200 &gt; x / 5; 20 6. How does Scale-Out occur in MongoDB? The document-oriented data model of MongoDB makes it easier to split data across multiple servers. Balancing and loading data across a cluster is done by MongoDB. It then redistributes documents automatically. The mongos acts as a query router, providing an interface between client applications and the sharded cluster. Config servers store metadata and configuration settings for the cluster. MongoDB uses the config servers to manage distributed locks. Each sharded cluster must have its own config servers. 7. What are some features of MongoDB? Indexing: It supports generic secondary indexes and provides unique, compound, geospatial, and full-text indexing capabilities as well. Aggregation: It provides an aggregation framework based on the concept of data processing pipelines. Special collection and index types: It supports time-to-live (TTL) collections for data that should expire at a certain time File storage: It supports an easy-to-use protocol for storing large files and file metadata. Sharding: Sharding is the process of splitting data up across machines. 8. How to add data in MongoDB? The basic method for adding data to MongoDB is “inserts”. To insert a single document, use the collection’s insertOne method: &gt; db.books.insertOne({&quot;title&quot; : &quot;Start With Why&quot;}) For inserting multiple documents into a collection, we use insertMany. This method enables passing an array of documents to the database. 9. How do you Update a Document? Once a document is stored in the database, it can be changed using one of several update methods: updateOne, updateMany, and replaceOne. updateOne and updateMany each takes a filter document as their first parameter and a modifier document, which describes changes to make, as the second parameter. replaceOne also takes a filter as the first parameter, but as the second parameter replaceOne expects a document with which it will replace the document matching the filter. For example, in order to replace a document: { &quot;_id&quot; : ObjectId(&quot;4b2b9f67a1f631733d917a7a&quot;), &quot;name&quot; : &quot;alice&quot;, &quot;friends&quot; : 24, &quot;enemies&quot; : 2 } 10. How do you Delete a Document? The CRUD API in MongoDB provides deleteOne and deleteMany for this purpose. Both of these methods take a filter document as their first parameter. The filter specifies a set of criteria to match against in removing documents. For example: &gt; db.books.deleteOne({&quot;_id&quot; : 3}) 11. How to perform queries in MongoDB? The find method is used to perform queries in MongoDB. Querying returns a subset of documents in a collection, from no documents at all to the entire collection. Which documents get returned is determined by the first argument to find, which is a document specifying the query criteria. Example: &gt; db.users.find({&quot;age&quot; : 24}) 12. What are the data types in MongoDB? MongoDB supports a wide range of data types as values in documents. Documents in MongoDB are similar to objects in JavaScript. Along with JSON’s essential key/value–pair nature, MongoDB adds support for a number of additional data types. The common data types in MongoDB are: Null {&quot;x&quot; : null} Boolean {&quot;x&quot; : true} Number {&quot;x&quot; : 4} String {&quot;x&quot; : &quot;foobar&quot;} Date {&quot;x&quot; : new Date()} Regular expression {&quot;x&quot; : /foobar/i} Array {&quot;x&quot; : [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]} Embedded document {&quot;x&quot; : {&quot;foo&quot; : &quot;bar&quot;}} Object ID {&quot;x&quot; : ObjectId()} Binary Data Binary data is a string of arbitrary bytes. Code {&quot;x&quot; : function() { /* ... */ }} 13. When to use MongoDB? You should use MongoDB when you are building internet and business applications that need to evolve quickly and scale elegantly. MongoDB is popular with developers of all kinds who are building scalable applications using agile methodologies. MongoDB is a great choice if one needs to: Support a rapid iterative development. Scale to high levels of read and write traffic - MongoDB supports horizontal scaling through Sharding, distributing data across several machines, and facilitating high throughput operations with large sets of data. Scale your data repository to a massive size. Evolve the type of deployment as the business changes. Store, manage and search data with text, geospatial, or time-series dimensions. MongoDB Intermediate Interview Questions 14. How is Querying done in MongoDB? The find method is used to perform queries in MongoDB. Querying returns a subset of documents in a collection, from no documents at all to the entire collection. Which documents get returned is determined by the first argument to find, which is a document specifying the query criteria. For example: If we have a string we want to match, such as a “username” key with the value “alice”, we use that key/value pair instead: &gt; db.users.find({&quot;username&quot; : &quot;alice&quot;}) 15. Explain the term “Indexing” in MongoDB. In MongoDB, indexes help in efficiently resolving queries. What an Index does is that it stores a small part of the data set in a form that is easy to traverse. The index stores the value of the specific field or set of fields, ordered by the value of the field as specified in the index. MongoDB’s indexes work almost identically to typical relational database indexes. Indexes look at an ordered list with references to the content. These in turn allow MongoDB to query orders of magnitude faster. To create an index, use the createIndex collection method. For example: &gt; db.users.find({&quot;username&quot;: &quot;user101&quot;}).explain(&quot;executionStats&quot;) Here, executionStats mode helps us understand the effect of using an index to satisfy queries. 16. What are Geospatial Indexes in MongoDB? MongoDB has two types of geospatial indexes: 2dsphere and 2d. 2dsphere indexes work with spherical geometries that model the surface of the earth based on the WGS84 datum. This datum model the surface of the earth as an oblate spheroid, meaning that there is some flattening at the poles. Distance calculations using 2sphere indexes, therefore, take the shape of the earth into account and provide a more accurate treatment of distance between, for example, two cities, than do 2d indexes. Use 2d indexes for points stored on a two-dimensional plane. 2dsphere allows you to specify geometries for points, lines, and polygons in the GeoJSON format. A point is given by a two-element array, representing [longitude, latitude]: { &quot;name&quot; : &quot;New York City&quot;, &quot;loc&quot; : { &quot;type&quot; : &quot;Point&quot;, &quot;coordinates&quot; : [50, 2] } } A line is given by an array of points: { &quot;name&quot; : &quot;Hudson River&quot;, &quot;loc&quot; : { &quot;type&quot; : &quot;LineString&quot;, &quot;coordinates&quot; : [[0,1], [0,2], [1,2]] } } 17. Explain the process of Sharding. Sharding is the process of splitting data up across machines. We also use the term “partitioning” sometimes to describe this concept. We can store more data and handle more load without requiring larger or more powerful machines, by putting a subset of data on each machine. In the figure below, RS0 and RS1 are shards. MongoDB’s sharding allows you to create a cluster of many machines (shards) and break up a collection across them, putting a subset of data on each shard. This allows your application to grow beyond the resource limits of a standalone server or replica set. Sharded Client Connection Non Sharded Client Connection 18. Explain the SET Modifier in MongoDB? If the value of a field does not yet exist, the “$set” sets the value. This can be useful for updating schemas or adding user-defined keys. Example: &gt; db.users.findOne() { &quot;_id&quot; : ObjectId(&quot;4b253b067525f35f94b60a31&quot;), &quot;name&quot; : &quot;alice&quot;, &quot;age&quot; : 23, &quot;sex&quot; : &quot;female&quot;, &quot;location&quot; : &quot;India&quot; } To add a field to this, we use “$set”: &gt; db.users.updateOne({&quot;_id&quot; : ObjectId(&quot;4b253b067525f35f94b60a31&quot;)}, ... {&quot;$set&quot; : {&quot;favorite book&quot; : &quot;Start with Why&quot;}}) MongoDB Advanced Interview Questions 19. What do you mean by Transactions? A transaction is a logical unit of processing in a database that includes one or more database operations, which can be read or write operations. Transactions provide a useful feature in MongoDB to ensure consistency. MongoDB provides two APIs to use transactions. Core API: It is a similar syntax to relational databases (e.g., start_transaction and commit_transaction) Call-back API: This is the recommended approach to using transactions. It starts a transaction, executes the specified operations, and commits (or aborts on the error). It also automatically incorporates error handling logic for “TransientTransactionError” and”UnknownTransactionCommitResult”. 20. What are MongoDB Charts? MongoDB Charts is a new, integrated tool in MongoDB for data visualization. MongoDB Charts offers the best way to create visualizations using data from a MongoDB database. It allows users to perform quick data representation from a database without writing code in a programming language such as Java or Python. The two different implementations of MongoDB Charts are: MongoDB Charts PaaS (Platform as a Service) MongoDB Charts Server 21. What is the Aggregation Framework in MongoDB? The aggregation framework is a set of analytics tools within MongoDB that allow you to do analytics on documents in one or more collections. The aggregation framework is based on the concept of a pipeline. With an aggregation pipeline, we take input from a MongoDB collection and pass the documents from that collection through one or more stages, each of which performs a different operation on its inputs (See figure below). Each stage takes as input whatever the stage before it produced as output. The inputs and outputs for all stages are documents—a stream of documents. 22. Explain the concept of pipeline in the MongoDB aggregation framework. An individual stage of an aggregation pipeline is a data processing unit. It takes in a stream of input documents one at a time, processes each document one at a time, and produces an output stream of documents one at a time (see figure below). 23. What is a Replica Set in MongoDB? To keep identical copies of your data on multiple servers, we use replication. It is recommended for all production deployments. Use replication to keep your application running and your data safe, even if something happens to one or more of your servers. Such replication can be created by a replica set with MongoDB. A replica set is a group of servers with one primary, the server taking writes, and multiple secondaries, servers that keep copies of the primary’s data. If the primary crashes, the secondaries can elect a new primary from amongst themselves. 24. Explain the Replication Architecture in MongoDB. The following diagram depicts the architecture diagram of a simple replica set cluster with only three server nodes – one primary node and two secondary nodes: In the preceding model, the PRIMARY database is the only active replica set member that receives write operations from database clients. The PRIMARY database saves data changes in the Oplog. Changes saved in the Oplog are sequential—that is, saved in the order that they are received and executed. The SECONDARY database is querying the PRIMARY database for new changes in the Oplog. If there are any changes, then Oplog entries are copied from PRIMARY to SECONDARY as soon as they are created on the PRIMARY node. Then, the SECONDARY database applies changes from the Oplog to its own datafiles. Oplog entries are applied in the same order they were inserted in the log. As a result, datafiles on SECONDARY are kept in sync with changes on PRIMARY. Usually, SECONDARY databases copy data changes directly from PRIMARY. Sometimes a SECONDARY database can replicate data from another SECONDARY. This type of replication is called Chained Replication because it is a two-step replication process. Chained replication is useful in certain replication topologies, and it is enabled by default in MongoDB. 25. What are some utilities for backup and restore in MongoDB? The mongo shell does not include functions for exporting, importing, backup, or restore. However, MongoDB has created methods for accomplishing this, so that no scripting work or complex GUIs are needed. For this, several utility scripts are provided that can be used to get data in or out of the database in bulk. These utility scripts are: mongoimport mongoexport mongodump mongorestore Conclusion 26. Conclusion MongoDB is a powerful, flexible, and scalable general-purpose database. It combines the ability to scale out with features such as secondary indexes, range queries, sorting, aggregations, and geospatial indexes. Thus, in conclusion, MongoDB is: Supports Indexing Designed to scale Rich with Features High Performance Load Balancing Supports sharding Although MongoDB is powerful, incorporating many features from relational systems, it is not intended to do everything that a relational database does. For some functionality, the database server offloads processing and logic to the client-side (handled either by the drivers or by a user’s application code). Its maintenance of this streamlined design is one of the reasons MongoDB can achieve such high performance. Here are few References to understand MongoDB in-depth: https://www.mongodb.com/2 https://docs.mongodb.com","url":"/MongoDB-Interview.html","headline":"MongoDB - Interview Questions","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- start custom head snippets -->

<!-- end custom head snippets --><script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.isFormElement = function(node) {
    var tagName = node.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i;
      loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cbs[i]();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();
(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();
(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();
</script><script>
  (function() {
    var TEXT_VARIABLES = {
      version: '2.2.4',
      sources: {
        font_awesome: 'https://use.fontawesome.com/releases/v5.0.13/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        valine: 'https://unpkg.com/valine/dist/Valine.min.js',
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3'
        }
      },
      paths: {
        search_js: '/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script></head>
  <body>
    <div class="root" data-is-touch="false">
      <div class="layout--page js-page-root"><div class="page__main js-page-main page__viewport has-aside cell cell--auto">

      <div class="page__main-inner"><div class="page__header d-print-none"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="76px" height="76px" viewBox="0 0 76 76" enable-background="new 0 0 76 76" xml:space="preserve">  <image id="image0" width="76" height="76" x="0" y="0"
    xlink:href="data:image/png;base64,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" />
</svg>
<a title="Tutorials, Java Tutorials,DevOps Tutorials,Spring Tutorial,SpringBoot Tutorials, Docker,Chef,Jenkins,Git,BitBucket,Bamboo,AWS,Kubernetes,Puppet,Ansible,Nagios." href="/">SatyaCodes</a></div><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></div><nav class="navigation">
        <ul><li class="navigation__item"><a href="/posts.html">AllPosts</a></li><li class="navigation__item"><a href="/tutorials.html">Tutorials</a></li><li class="navigation__item"><a href="/java.html">Java</a></li><li class="navigation__item"><a href="/devops.html">DevOps</a></li><li class="navigation__item"><a href="/books.html">Books</a></li><li class="navigation__item"><a href="/interview-questions.html">InterviewQ's</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li></ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class ="main"><div class="grid grid--reverse">

              <div class="col-aside d-print-none js-col-aside"><aside class="page__aside js-page-aside"><div class="toc-aside js-toc-root"></div></aside></div>

              <div class="col-main cell cell--auto"><!-- start custom main top snippet -->

<!-- end custom main top snippet --><article itemscope itemtype="http://schema.org/Article"><div class="article__header"><header><h1>MongoDB - Interview Questions</h1></header></div><meta itemprop="headline" content="MongoDB - Interview Questions"><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=Interview">Interview</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Jul 11, 2020</span>
            </li></ul></div><meta itemprop="author" content="Satya Kaveti"/><meta itemprop="datePublished" content="2020-07-11T00:00:00+00:00">
    <meta itemprop="keywords" content="Interview"><div class="js-article-content"><div class="layout--article"><!-- start custom article top snippet -->

<!-- end custom article top snippet --><div class="article__content" itemprop="articleBody"><h1 id="mongodb-interview-questions">MongoDB Interview Questions</h1>

<h3 id="introduction-to-mongodb">Introduction to MongoDB</h3>

<p>When dealing with data, there are two types of data as we know – (i) structured data and (ii) unstructured data. Structured data is usually stored in a tabular form whereas unstructured data is not. To manage huge sets of unstructured data like log or IoT data, a NoSQL database is used.</p>

<p>Now, what is MongoDB?</p>

<ul>
  <li>MongoDB is an open-source NoSQL database written in C++ language. It uses JSON-like documents with optional schemas.</li>
  <li>It provides easy scalability and is a cross-platform, document-oriented database.</li>
  <li>MongoDB works on the concept of Collection and Document.</li>
  <li>It combines the ability to scale out with features such as secondary indexes, range queries, sorting, aggregations, and geospatial indexes.</li>
  <li>MongoDB is developed by MongoDB Inc. and licensed under the Server Side Public License (SSPL).</li>
</ul>

<p>Crack your next tech interview with confidence!</p>

<p>Take a free mock interview, get instant⚡️ feedback and recommendation💡</p>

<p><a href="https://www.interviewbit.com/event/free-mock-coding-interview?utm_source=ib&amp;utm_medium=in-interview-guide&amp;utm_campaign=MoCo&amp;utm_content=/mongodb-interview-questions/">Take Free Mock Interview</a></p>

<h2 id="mongodb-basic-interview-questions">MongoDB Basic Interview Questions</h2>

<h3 id="1-what-are-some-of-the-advantages-of-mongodb">1. What are some of the advantages of MongoDB?</h3>

<p>Some advantages of MongoDB are as follows:</p>

<ul>
  <li>MongoDB supports field, range-based, string pattern matching type queries. for searching the data in the database</li>
  <li>MongoDB support primary and secondary index on any fields</li>
  <li>MongoDB basically uses JavaScript objects in place of procedures</li>
  <li>MongoDB uses a dynamic database schema</li>
  <li>MongoDB is very easy to scale up or down</li>
  <li>MongoDB has inbuilt support for data partitioning (Sharding).</li>
</ul>

<h3 id="2-what-is-a-document-in-mongodb">2. What is a Document in MongoDB?</h3>

<p>A Document in MongoDB is an ordered set of keys with associated values. It is represented by a map, hash, or dictionary. In JavaScript, documents are represented as objects:<br />
<code class="language-plaintext highlighter-rouge">{"greeting" : "Hello world!"}</code></p>

<p>Complex documents will contain multiple key/value pairs:<br />
<code class="language-plaintext highlighter-rouge">{"greeting" : "Hello world!", "views" : 3}</code></p>

<h3 id="3-what-is-a-collection-in-mongodb">3. What is a Collection in MongoDB?</h3>

<p>A collection in MongoDB is a group of documents. If a document is the MongoDB analog of a row in a relational database, then a collection can be thought of as the analog to a table.<br />
Documents within a single collection can have any number of different “shapes.”, i.e. collections have dynamic schemas.<br />
For example, both of the following documents could be stored in a single collection:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"greeting" : "Hello world!", "views": 3}
{"signoff": "Good bye"}
</code></pre></div></div>

<p>You can download a PDF version of Mongodb Interview Questions.</p>

<p><img src="https://assets.interviewbit.com/assets/svg/download_icon-cd2d5b54bc600ee83352693330804e7d9324dddf41fc105cd5e3176e92f3cd36.svg.gz" alt="" />Download PDF</p>

<hr />

<h3 id="4-what-are-databases-in-mongodb">4. What are Databases in MongoDB?</h3>

<p>MongoDB groups collections into databases. MongoDB can host several databases, each grouping together collections.<br />
Some reserved database names are as follows:<br />
<em>admin</em><br />
<em>local</em><br />
<em>config</em></p>

<h3 id="5-what-is-the-mongo-shell">5. What is the Mongo Shell?</h3>

<p>It is a JavaScript shell that allows interaction with a MongoDB instance from the command line. With that one can perform administrative functions, inspecting an instance, or exploring MongoDB.</p>

<p>To start the shell, run the mongo executable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mongod
$ mongo
MongoDB shell version: 4.2.0
connecting to: test
&gt;
</code></pre></div></div>

<p>The shell is a full-featured JavaScript interpreter, capable of running arbitrary JavaScript programs. Let’s see how basic math works on this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; x = 100;
200
&gt; x / 5;
20
</code></pre></div></div>

<h3 id="6-how-does-scale-out-occur-in-mongodb">6. How does Scale-Out occur in MongoDB?</h3>

<p>The document-oriented data model of MongoDB makes it easier to split data across multiple servers. Balancing and loading data across a cluster is done by MongoDB. It then redistributes documents automatically.</p>

<p>The mongos acts as a query router, providing an interface between client applications and the sharded cluster.</p>

<p>Config servers store metadata and configuration settings for the cluster. MongoDB uses the config servers to manage distributed locks. Each sharded cluster must have its own config servers.</p>

<p><img src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/202/original/Mongos.jpg?1616050215" alt="" /></p>

<h3 id="7-what-are-some-features-of-mongodb">7. What are some features of MongoDB?</h3>

<ul>
  <li>Indexing: It supports generic secondary indexes and provides unique, compound, geospatial, and full-text indexing capabilities as well.</li>
  <li>Aggregation: It provides an aggregation framework based on the concept of data processing pipelines.</li>
  <li>Special collection and index types: It supports time-to-live (TTL) collections for data that should expire at a certain time</li>
  <li>File storage: It supports an easy-to-use protocol for storing large files and file metadata.</li>
  <li>Sharding: Sharding is the process of splitting data up across machines.</li>
</ul>

<h3 id="8-how-to-add-data-in-mongodb">8. How to add data in MongoDB?</h3>

<p>The basic method for adding data to MongoDB is “inserts”. To insert a single document, use the collection’s <code class="language-plaintext highlighter-rouge">insertOne</code> method:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.books.insertOne({"title" : "Start With Why"})
</code></pre></div></div>

<p>For inserting multiple documents into a collection, we use <code class="language-plaintext highlighter-rouge">insertMany</code>. This method enables passing an array of documents to the database.</p>

<h3 id="9-how-do-you-update-a-document">9. How do you Update a Document?</h3>

<p>Once a document is stored in the database, it can be changed using one of several update methods: <code class="language-plaintext highlighter-rouge">updateOne</code>, <code class="language-plaintext highlighter-rouge">updateMany</code>, and <code class="language-plaintext highlighter-rouge">replaceOne. updateOne</code> and <code class="language-plaintext highlighter-rouge">updateMany</code> each takes a filter document as their first parameter and a modifier document, which describes changes to make, as the second parameter. <code class="language-plaintext highlighter-rouge">replaceOne</code> also takes a filter as the first parameter, but as the second parameter <code class="language-plaintext highlighter-rouge">replaceOne</code> expects a document with which it will replace the document matching the filter.</p>

<p>For example, in order to replace a document:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   "_id" : ObjectId("4b2b9f67a1f631733d917a7a"),
   "name" : "alice",
   "friends" : 24,
   "enemies" : 2
}
</code></pre></div></div>

<h3 id="10-how-do-you-delete-a-document">10. How do you Delete a Document?</h3>

<p>The CRUD API in MongoDB provides <code class="language-plaintext highlighter-rouge">deleteOne</code> and <code class="language-plaintext highlighter-rouge">deleteMany</code> for this purpose. Both of these methods take a filter document as their first parameter. The filter specifies a set of criteria to match against in removing documents.</p>

<p>For example:<br />
<code class="language-plaintext highlighter-rouge">&gt; db.books.deleteOne({"_id" : 3})</code></p>

<h3 id="11-how-to-perform-queries-in-mongodb">11. How to perform queries in MongoDB?</h3>

<p>The <code class="language-plaintext highlighter-rouge">find</code> method is used to perform queries in MongoDB. Querying returns a subset of documents in a collection, from no documents at all to the entire collection. Which documents get returned is determined by the first argument to <code class="language-plaintext highlighter-rouge">find</code>, which is a document specifying the query criteria.</p>

<p>Example:<br />
<code class="language-plaintext highlighter-rouge">&gt; db.users.find({"age" : 24})</code></p>

<h3 id="12-what-are-the-data-types-in-mongodb">12. What are the data types in MongoDB?</h3>

<p>MongoDB supports a wide range of data types as values in documents. Documents in MongoDB are similar to objects in JavaScript. Along with JSON’s essential key/value–pair nature, MongoDB adds support for a number of additional data types. The common data types in MongoDB are:</p>

<ul>
  <li>Null<br />
<code class="language-plaintext highlighter-rouge">{"x" : null}</code></li>
  <li>Boolean<br />
<code class="language-plaintext highlighter-rouge">{"x" : true}</code></li>
  <li>Number<br />
<code class="language-plaintext highlighter-rouge">{"x" : 4}</code></li>
  <li>String<br />
<code class="language-plaintext highlighter-rouge">{"x" : "foobar"}</code></li>
  <li>Date<br />
<code class="language-plaintext highlighter-rouge">{"x" : new Date()}</code></li>
  <li>Regular expression<br />
<code class="language-plaintext highlighter-rouge">{"x" : /foobar/i}</code></li>
  <li>Array<br />
<code class="language-plaintext highlighter-rouge">{"x" : ["a", "b", "c"]}</code></li>
  <li>Embedded document<br />
<code class="language-plaintext highlighter-rouge">{"x" : {"foo" : "bar"}}</code></li>
  <li>Object ID<br />
<code class="language-plaintext highlighter-rouge">{"x" : ObjectId()}</code></li>
  <li>Binary Data<br />
Binary data is a string of arbitrary bytes.</li>
  <li>Code<br />
<code class="language-plaintext highlighter-rouge">{"x" : function() { /* ... */ }}</code></li>
</ul>

<h3 id="13-when-to-use-mongodb">13. When to use MongoDB?</h3>

<p>You should use MongoDB when you are building internet and business applications that need to evolve quickly and scale elegantly. MongoDB is popular with developers of all kinds who are building scalable applications using agile methodologies.<br />
MongoDB is a great choice if one needs to:</p>

<ul>
  <li>Support a rapid iterative development.</li>
  <li>Scale to high levels of read and write traffic - MongoDB supports horizontal scaling through Sharding, distributing data across several machines, and facilitating high throughput operations with large sets of data.</li>
  <li>Scale your data repository to a massive size.</li>
  <li>Evolve the type of deployment as the business changes.</li>
  <li>Store, manage and search data with text, geospatial, or time-series dimensions.</li>
</ul>

<h2 id="mongodb-intermediate-interview-questions">MongoDB Intermediate Interview Questions</h2>

<h3 id="14-how-is-querying-done-in-mongodb">14. How is Querying done in MongoDB?</h3>

<p>The <code class="language-plaintext highlighter-rouge">find</code> method is used to perform queries in MongoDB. Querying returns a subset of documents in a collection, from no documents at all to the entire collection. Which documents get returned is determined by the first argument to find, which is a document specifying the query criteria.</p>

<p>For example: If we have a string we want to match, such as a “username” key with the value “alice”, we use that key/value pair instead:</p>

<p><code class="language-plaintext highlighter-rouge">&gt; db.users.find({"username" : "alice"})</code></p>

<h3 id="15-explain-the-term-indexing-in-mongodb">15. Explain the term “Indexing” in MongoDB.</h3>

<p>In MongoDB, indexes help in efficiently resolving queries. What an Index does is that it stores a small part of the data set in a form that is easy to traverse. The index stores the value of the specific field or set of fields, ordered by the value of the field as specified in the index.<br />
MongoDB’s indexes work almost identically to typical relational database indexes.</p>

<p>Indexes look at an ordered list with references to the content. These in turn allow MongoDB to query orders of magnitude faster. To create an index, use the <code class="language-plaintext highlighter-rouge">createIndex</code> collection method.</p>

<p>For example:</p>

<p><code class="language-plaintext highlighter-rouge">&gt; db.users.find({"username": "user101"}).explain("executionStats")</code></p>

<p>Here, <code class="language-plaintext highlighter-rouge">executionStats</code> mode helps us understand the effect of using an index to satisfy queries.</p>

<h3 id="16-what-are-geospatial-indexes-in-mongodb">16. What are Geospatial Indexes in MongoDB?</h3>

<p>MongoDB has two types of geospatial indexes: 2dsphere and 2d. 2dsphere indexes work with spherical geometries that model the surface of the earth based on the WGS84 datum. This datum model the surface of the earth as an oblate spheroid, meaning that there is some flattening at the poles. Distance calculations using 2sphere indexes, therefore, take the shape of the earth into account and provide a more accurate treatment of distance between, for example, two cities, than do 2d indexes. Use 2d indexes for points stored on a two-dimensional plane.</p>

<p>2dsphere allows you to specify geometries for points, lines, and polygons in the GeoJSON format. A point is given by a two-element array, representing [longitude, latitude]:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   "name" : "New York City",
   "loc" : {
       "type" : "Point",
       "coordinates" : [50, 2]
   }
}
</code></pre></div></div>

<p>A line is given by an array of points:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   "name" : "Hudson River",
   "loc" : {
       "type" : "LineString",
       "coordinates" : [[0,1], [0,2], [1,2]]
   }
}
</code></pre></div></div>

<h3 id="17-explain-the-process-of-sharding">17. Explain the process of Sharding.</h3>

<p>Sharding is the process of splitting data up across machines. We also use the term “partitioning” sometimes to describe this concept. We can store more data and handle more load without requiring larger or more powerful machines, by putting a subset of data on each machine.<br />
In the figure below, RS0 and RS1 are shards. MongoDB’s sharding allows you to create a cluster of many machines (shards) and break up a collection across them, putting a subset of data on each shard. This allows your application to grow beyond the resource limits of a standalone server or replica set.</p>

<p><img src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/204/original/sharded_client_connection.jpg?1616054864" alt="" /></p>

<p>Sharded Client Connection</p>

<p><img src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/206/original/Non_sharded_client_connection.jpg?1616054947" alt="" /></p>

<p>Non Sharded Client Connection</p>

<h3 id="18-explain-the-set-modifier-in-mongodb">18. Explain the SET Modifier in MongoDB?</h3>

<p>If the value of a field does not yet exist, the “$set” sets the value. This can be useful for updating schemas or adding user-defined keys.</p>

<p>Example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.users.findOne()
{
   "_id" : ObjectId("4b253b067525f35f94b60a31"),
   "name" : "alice",
   "age" : 23,
   "sex" : "female",
   "location" : "India"
}
</code></pre></div></div>

<p>To add a field to this, we use “$set”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.users.updateOne({"_id" :
ObjectId("4b253b067525f35f94b60a31")},
... {"$set" : {"favorite book" : "Start with Why"}})
</code></pre></div></div>

<h2 id="mongodb-advanced-interview-questions">MongoDB Advanced Interview Questions</h2>

<h3 id="19-what-do-you-mean-by-transactions">19. What do you mean by Transactions?</h3>

<p>A transaction is a logical unit of processing in a database that includes one or more database operations, which can be read or write operations. Transactions provide a useful feature in MongoDB to ensure consistency.</p>

<p>MongoDB provides two APIs to use transactions.</p>

<ul>
  <li>Core API: It is a similar syntax to relational databases (e.g., start_transaction and commit_transaction)</li>
  <li>Call-back API: This is the recommended approach to using transactions. It starts a transaction, executes the specified operations, and commits (or aborts on the error). It also automatically incorporates error handling logic for “TransientTransactionError” and”UnknownTransactionCommitResult”.</li>
</ul>

<h3 id="20-what-are-mongodb-charts">20. What are MongoDB Charts?</h3>

<p>MongoDB Charts is a new, integrated tool in MongoDB for data visualization.</p>

<p>MongoDB Charts offers the best way to create visualizations using data from a MongoDB database.<br />
It allows users to perform quick data representation from a database without writing code in a programming language such as Java or Python.</p>

<p>The two different implementations of MongoDB Charts are:</p>

<ul>
  <li>MongoDB Charts PaaS (Platform as a Service)</li>
  <li>MongoDB Charts Server</li>
</ul>

<h3 id="21-what-is-the-aggregation-framework-in-mongodb">21. What is the Aggregation Framework in MongoDB?</h3>

<ul>
  <li>The aggregation framework is a set of analytics tools within MongoDB that allow you to do analytics on documents in one or more collections.</li>
  <li>The aggregation framework is based on the concept of a pipeline. With an aggregation pipeline, we take input from a MongoDB collection and pass the documents from that collection through one or more stages, each of which performs a different operation on its inputs (See figure below). Each stage takes as input whatever the stage before it produced as output. The inputs and outputs for all stages are documents—a stream of documents.</li>
</ul>

<p><img src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/208/original/aggregation-framework.jpg?1616058137" alt="" /></p>

<h3 id="22-explain-the-concept-of-pipeline-in-the-mongodb-aggregation-framework">22. Explain the concept of pipeline in the MongoDB aggregation framework.</h3>

<p>An individual stage of an aggregation pipeline is a data processing unit. It takes in a stream of input documents one at a time, processes each document one at a time, and produces an output stream of documents one at a time (see figure below).</p>

<p><img src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/209/original/mongodb_aggregation_pipeline.jpg?1616058315" alt="" /></p>

<h3 id="23-what-is-a-replica-set-in-mongodb">23. What is a Replica Set in MongoDB?</h3>

<p>To keep identical copies of your data on multiple servers, we use replication. It is recommended for all production deployments. Use replication to keep your application running and your data safe, even if something happens to one or more of your servers.</p>

<p>Such replication can be created by a replica set with MongoDB. A replica set is a group of servers with one primary, the server taking writes, and multiple secondaries, servers that keep copies of the primary’s data. If the primary crashes, the secondaries can elect a new primary from amongst themselves.</p>

<h3 id="24-explain-the-replication-architecture-in-mongodb">24. Explain the Replication Architecture in MongoDB.</h3>

<p>The following diagram depicts the architecture diagram of a simple replica set cluster with only three server nodes – one primary node and two secondary nodes:</p>

<p><img src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/210/original/replication_architecture.jpg?1616058517" alt="" /></p>

<ul>
  <li>In the preceding model, the PRIMARY database is the only active replica set member that receives write operations from database clients. The PRIMARY database saves data changes in the Oplog. Changes saved in the Oplog are sequential—that is, saved in the order that they are received and executed.</li>
  <li>The SECONDARY database is querying the PRIMARY database for new changes in the Oplog. If there are any changes, then Oplog entries are copied from PRIMARY to SECONDARY as soon as they are created on the PRIMARY node.</li>
  <li>Then, the SECONDARY database applies changes from the Oplog to its own datafiles. Oplog entries are applied in the same order they were inserted in the log. As a result, datafiles on SECONDARY are kept in sync with changes on PRIMARY.</li>
  <li>Usually, SECONDARY databases copy data changes directly from PRIMARY. Sometimes a SECONDARY database can replicate data from another SECONDARY. This type of replication is called Chained Replication because it is a two-step replication process. Chained replication is useful in certain replication topologies, and it is enabled by default in MongoDB.</li>
</ul>

<h3 id="25-what-are-some-utilities-for-backup-and-restore-in-mongodb">25. What are some utilities for backup and restore in MongoDB?</h3>

<p>The mongo shell does not include functions for exporting, importing, backup, or restore. However, MongoDB has created methods for accomplishing this, so that no scripting work or complex GUIs are needed. For this, several utility scripts are provided that can be used to get data in or out of the database in bulk. These utility scripts are:</p>

<ul>
  <li>mongoimport</li>
  <li>mongoexport</li>
  <li>mongodump</li>
  <li>mongorestore</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<h3 id="26-conclusion">26. Conclusion</h3>

<p>MongoDB is a powerful, flexible, and scalable general-purpose database. It combines the ability to scale out with features such as secondary indexes, range queries, sorting, aggregations, and geospatial indexes.<br />
Thus, in conclusion, MongoDB is:</p>

<ul>
  <li>Supports Indexing</li>
  <li>Designed to scale</li>
  <li>Rich with Features</li>
  <li>High Performance</li>
  <li>Load Balancing</li>
  <li>Supports sharding</li>
</ul>

<p>Although MongoDB is powerful, incorporating many features from relational systems, it is not intended to do everything that a relational database does. For some functionality, the database server offloads processing and logic to the client-side (handled either by the drivers or by a user’s application code). Its maintenance of this streamlined design is one of the reasons MongoDB can achieve such high performance.</p>

<p>Here are few References to understand MongoDB in-depth:<br />
<a href="https://www.mongodb.com/2">https://www.mongodb.com/2</a><br />
<a href="https://docs.mongodb.com/">https://docs.mongodb.com</a></p>
</div><section class="article__sharing d-print-none"><!-- Addthis BEGIN --><script type="text/javascript"
    src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5dd2bcde40b385b7"></script>
  <div class="addthis_inline_share_toolbox addthis_default_style"></div><!-- Addthis END -->
</section><div class="d-print-none"><footer class="article__footer"><meta itemprop="dateModified" content="2020-07-11T00:00:00+00:00"><!-- start custom article footer snippet -->

<!-- end custom article footer snippet --></footer><div class="article__section-navigator clearfix"><div class="previous"><span>PREVIOUS</span><a href="/JavaScript-Interview.html">JavaScript - Interview Questions</a></div><div class="next"><span>NEXT</span><a href="/Java-Eclipse-Tomcat-HTTP-Status-404-Fix.html">Java - Eclipse Tomcat HTTP Status 404 Fix</a></div></div></div>

</div>

<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    $(function() {
      var $this ,$scroll;
      var $articleContent = $('.js-article-content');
      var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
      var scroll = hasSidebar ? '.js-page-main' : 'html, body';
      $scroll = $(scroll);

      $articleContent.find('.highlight').each(function() {
        $this = $(this);
        $this.attr('data-lang', $this.find('code').attr('data-lang'));
      });
      $articleContent.find('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]').each(function() {
        $this = $(this);
        $this.append($('<a class="anchor d-print-none" aria-hidden="true"></a>').html('<i class="fas fa-anchor"></i>'));
      });
      $articleContent.on('click', '.anchor', function() {
        $scroll.scrollToAnchor('#' + $(this).parent().attr('id'), 400);
      });
    });
  });
})();
//alert('start .......');
document.getElementsByClassName('article__header')[0].style.display = 'none';
document.getElementsByClassName('article__info')[0].style.display = 'none';
//alert(' end .......');
 
 document.onreadystatechange = function(){
     if(document.readyState === 'complete'){
         /*code here*/
		 //alert('onreadystatechange comled ... start .......');
document.getElementsByClassName('article__header')[0].style.display = 'none';
document.getElementsByClassName('article__info')[0].style.display = 'none';
//alert('onreadystatechange comled ... end .......');
     }
}

</script></div><section class="page__comments d-print-none"></section></article><!-- start custom main bottom snippet -->

<!-- end custom main bottom snippet --></div>
            </div></div></div><div class="page__footer d-print-none"><footer class="footer py-4 js-page-footer">
  <div class="main"><div itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Satya Kaveti"><meta itemprop="url" content="/"><meta itemprop="description" content="I am an amazing person."><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"></ul>
</div>
</div>
    </div><div class="site-info mt-2">
      <div>© SatyaCodes 2020 ,
        <a title="Satya Kaveti" href="about/">Satya Kaveti's Writing</a>.
		<span>| <a href="about/">About Me</a> &nbsp |  </span>
		<span><a href="/terms.html">Terms</a> &nbsp |  </span>
		<span><a href="/contact.html">Contact</a> &nbsp |  </span>
		<span><a href="http://www.satyacodesapps.ml/" target="_blank">Our Apps</a> &nbsp |  </span>
		<span><a href="https://www.facebook.com/isatyakaveti" target="_blank"><i class="fab fa-facebook-f"></i></a> &nbsp |  </span>
		<span><a href="https://www.youtube.com/" target="_blank"><i class="fab fa-youtube-square"></i></a> &nbsp |  </span>
		<span><a href="https://in.linkedin.com/in/satyakaveti"target="_blank"><i class="fab fa-linkedin-in"></i></a> &nbsp | 
		<span>[ 
		<!-- Start of WebFreeCounter Code -->
<a href="http://www.statworker.com/" target="_blank"><img src="https://www.webfreecounter.com/hit.php?id=gfpapx&nd=7&style=2" border="0" alt="statworker.com"></a>
<!-- End of WebFreeCounter Code -->
</span>
<span><a href="https://statcounter.com/p12408441/?guest=1" target="_blank"> ]</a></span>


      </div>
    </div>
  </div>
</footer></div></div>
    </div><script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $body = $('body'), $window = $(window);
    var $pageRoot = $('.js-page-root'), $pageMain = $('.js-page-main');
    var activeCount = 0;
    function modal(options) {
      var $root = this, visible, onChange, hideWhenWindowScroll = false;
      var scrollTop;
      function setOptions(options) {
        var _options = options || {};
        visible = _options.initialVisible === undefined ? false : show;
        onChange = _options.onChange;
        hideWhenWindowScroll = _options.hideWhenWindowScroll;
      }
      function init() {
        setState(visible);
      }
      function setState(isShow) {
        if (isShow === visible) {
          return;
        }
        visible = isShow;
        if (visible) {
          activeCount++;
          scrollTop = $(window).scrollTop() || $pageMain.scrollTop();
          $root.addClass('modal--show');
          $pageMain.scrollTop(scrollTop);
          activeCount === 1 && ($pageRoot.addClass('show-modal'), $body.addClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.on('scroll', hide);
          $window.on('keyup', handleKeyup);
        } else {
          activeCount > 0 && activeCount--;
          $root.removeClass('modal--show');
          $window.scrollTop(scrollTop);
          activeCount === 0 && ($pageRoot.removeClass('show-modal'), $body.removeClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.off('scroll', hide);
          $window.off('keyup', handleKeyup);
        }
        onChange && onChange(visible);
      }
      function show() {
        setState(true);
      }
      function hide() {
        setState(false);
      }
      function handleKeyup(e) {
        // Char Code: 27  ESC
        if (e.which ===  27) {
          hide();
        }
      }
      setOptions(options);
      init();
      return {
        show: show,
        hide: hide,
        $el: $root
      };
    }
    $.fn.modal = modal;
  });
})();
</script><div class="modal modal--overflow page__search-modal d-print-none js-page-search-modal"><script>
(function () {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    // search panel
    var search = (window.search || (window.search = {}));
    var useDefaultSearchBox = window.useDefaultSearchBox === undefined ?
      true : window.useDefaultSearchBox ;

    var $searchModal = $('.js-page-search-modal');
    var $searchToggle = $('.js-search-toggle');
    var searchModal = $searchModal.modal({ onChange: handleModalChange, hideWhenWindowScroll: true });
    var modalVisible = false;
    search.searchModal = searchModal;

    var $searchBox = null;
    var $searchInput = null;
    var $searchClear = null;

    function getModalVisible() {
      return modalVisible;
    }
    search.getModalVisible = getModalVisible;

    function handleModalChange(visible) {
      modalVisible = visible;
      if (visible) {
        search.onShow && search.onShow();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].focus();
      } else {
        search.onShow && search.onHide();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].blur();
        setTimeout(function() {
          useDefaultSearchBox && ($searchInput.val(''), $searchBox.removeClass('not-empty'));
          search.clear && search.clear();
          window.pageAsideAffix && window.pageAsideAffix.refresh();
        }, 400);
      }
    }

    $searchToggle.on('click', function() {
      modalVisible ? searchModal.hide() : searchModal.show();
    });
    // Char Code: 83  S, 191 /
    $(window).on('keyup', function(e) {
      if (!modalVisible && !window.isFormElement(e.target || e.srcElement) && (e.which === 83 || e.which === 191)) {
        modalVisible || searchModal.show();
      }
    });

    if (useDefaultSearchBox) {
      $searchBox = $('.js-search-box');
      $searchInput = $searchBox.children('input');
      $searchClear = $searchBox.children('.js-icon-clear');
      search.getSearchInput = function() {
        return $searchInput.get(0);
      };
      search.getVal = function() {
        return $searchInput.val();
      };
      search.setVal = function(val) {
        $searchInput.val(val);
      };

      $searchInput.on('focus', function() {
        $(this).addClass('focus');
      });
      $searchInput.on('blur', function() {
        $(this).removeClass('focus');
      });
      $searchInput.on('input', window.throttle(function() {
        var val = $(this).val();
        if (val === '' || typeof val !== 'string') {
          search.clear && search.clear();
        } else {
          $searchBox.addClass('not-empty');
          search.onInputNotEmpty && search.onInputNotEmpty(val);
        }
      }, 400));
      $searchClear.on('click', function() {
        $searchInput.val(''); $searchBox.removeClass('not-empty');
        search.clear && search.clear();
      });
    }
  });
})();
</script><div class="search search--dark">
  <div class="main">
    <div class="search__header">Search</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--theme-dark button--pill search__cancel js-search-toggle">
        Cancel</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>
<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var search = (window.search || (window.search = {}));
  var searchData = window.TEXT_SEARCH_DATA || {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) { return null; }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function clear() {
    $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }
  function onInputNotEmpty(val) {
    $result.html(render(searchByQuery(val)));
    $resultItems = $('.search-result__item'); activeIndex = 0;
    $resultItems.eq(0).addClass('active');
  }

  search.clear = clear;
  search.onInputNotEmpty = onInputNotEmpty;

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  // Char Code: 13  Enter, 37  ⬅, 38  ⬆, 39  ➡, 40  ⬇
  $(window).on('keyup', function(e) {
    var modalVisible = search.getModalVisible && search.getModalVisible();
    if (modalVisible) {
      if (e.which === 38) {
        modalVisible && moveActiveIndex('up');
      } else if (e.which === 40) {
        modalVisible && moveActiveIndex('down');
      } else if (e.which === 13) {
        modalVisible && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });
});
</script></div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function affix(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroll,
        offsetBottom = 0, scrollTarget = window, scroll = window.document, disabled = false, isOverallScroller = true,
        rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop,
        hasInit = false, curState;

      function setOptions(options) {
        var _options = options || {};
        _options.offsetBottom && (offsetBottom = _options.offsetBottom);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroll && (scroll = _options.scroll);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $scrollTarget = $(scrollTarget);
        isOverallScroller = window.isOverallScroller($scrollTarget[0]);
        $scroll = $(scroll);
      }
      function preCalc() {
        top();
        rootHeight = $root.outerHeight();
        rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
        rootLeft = $root.offset().left;
      }
      function calc(needPreCalc) {
        needPreCalc && preCalc();
        scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
        rootBottomTop = scrollBottom - rootTop;
      }
      function top() {
        if (curState !== 'top') {
          $root.removeClass('fixed').css({
            left: 0,
            top: 0
          });
          curState = 'top';
        }
      }
      function fixed() {
        if (curState !== 'fixed') {
          $root.addClass('fixed').css({
            left: rootLeft + 'px',
            top: 0
          });
          curState = 'fixed';
        }
      }
      function bottom() {
        if (curState !== 'bottom') {
          $root.removeClass('fixed').css({
            left: 0,
            top: rootBottomTop + 'px'
          });
          curState = 'bottom';
        }
      }
      function setState() {
        var scrollTop = $scrollTarget.scrollTop();
        if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
          fixed();
        } else if (scrollTop < rootTop) {
          top();
        } else {
          bottom();
        }
      }
      function init() {
        if(!hasInit) {
          var interval, timeout;
          calc(true); setState();
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState();
          });
          $window.on('resize', function() {
            disabled || (calc(true), setState());
          });
          hasInit = true;
        }
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true, { animation: false }); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function toc(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroller, $tocUl = $('<ul class="toc toc--ellipsis"></ul>'), $tocLi, $headings, $activeLast, $activeCur,
        selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false,
        headingsPos, scrolling = false, hasRendered = false, hasInit = false;

      function setOptions(options) {
        var _options = options || {};
        _options.selectors && (selectors = _options.selectors);
        _options.container && (container = _options.container);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroller && (scroller = _options.scroller);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $headings = $(container).find(selectors).filter('[id]');
        $scrollTarget = $(scrollTarget);
        $scroller = $(scroller);
      }
      function calc() {
        headingsPos = [];
        $headings.each(function() {
          headingsPos.push(Math.floor($(this).position().top));
        });
      }
      function setState(element, disabled) {
        var scrollTop = $scrollTarget.scrollTop(), i;
        if (disabled || !headingsPos || headingsPos.length < 1) { return; }
        if (element) {
          $activeCur = element;
        } else {
          for (i = 0; i < headingsPos.length; i++) {
            if (scrollTop >= headingsPos[i]) {
              $activeCur = $tocLi.eq(i);
            } else {
              $activeCur || ($activeCur = $tocLi.eq(i));
              break;
            }
          }
        }
        $activeLast && $activeLast.removeClass('active');
        ($activeLast = $activeCur).addClass('active');
      }
      function render() {
        if(!hasRendered) {
          $root.append($tocUl);
          $headings.each(function() {
            var $this = $(this);
            $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
              .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
          });
          $tocLi = $tocUl.children('li');
          $tocUl.on('click', 'a', function(e) {
            e.preventDefault();
            var $this = $(this);
            scrolling = true;
            setState($this.parent());
            $scroller.scrollToAnchor($this.attr('href'), 400, function() {
              scrolling = false;
            });
          });
        }
        hasRendered = true;
      }
      function init() {
        var interval, timeout;
        if(!hasInit) {
          render(); calc(); setState(null, scrolling);
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState(null, scrolling);
          });
          $window.on('resize', window.throttle(function() {
            if (!disabled) {
              render(); calc(); setState(null, scrolling);
            }
          }, 100));
        }
        hasInit = true;
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();
/*(function () {

})();*/
</script><script>
  /* toc must before affix, since affix need to konw toc' height. */(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  var TOC_SELECTOR = window.TEXT_VARIABLES.site.toc.selectors;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window);
    var $articleContent = $('.js-article-content');
    var $tocRoot = $('.js-toc-root'), $col2 = $('.js-col-aside');
    var toc;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
    var hasToc = $articleContent.find(TOC_SELECTOR).length > 0;

    function disabled() {
      return $col2.css('display') === 'none' || !hasToc;
    }

    tocDisabled = disabled();

    toc = $tocRoot.toc({
      selectors: TOC_SELECTOR,
      container: $articleContent,
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      tocDisabled = disabled();
      toc && toc.setOptions({
        disabled: tocDisabled
      });
    }, 100));

  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $pageFooter = $('.js-page-footer');
    var $pageAside = $('.js-page-aside');
    var affix;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');

    affix = $pageAside.affix({
      offsetBottom: $pageFooter.outerHeight(),
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      scroll: hasSidebar ? $('.js-page-main').children() : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      affix && affix.setOptions({
        disabled: tocDisabled
      });
    }, 100));

    window.pageAsideAffix = affix;
  });
})();
</script>
    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();
</script>
  </body>
</html>