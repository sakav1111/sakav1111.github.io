<!DOCTYPE html><html lang="en">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>SatyaCodes - Java - Interview Questions PART-1</title>

<meta name="description" content="BasicsWhat is a strongly typed programming language?In a strongly typed language compiler ensure type correctness, for example, youcan not store the number i...">
<link rel="canonical" href="/Java-Interview-Questions-1.html"><link rel="alternate" type="application/rss+xml" title="SatyaCodes" href="/feed.xml"><!-- start favicons snippet, use https://realfavicongenerator.net/ --><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicons snippet -->
 <link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" >
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Java - Interview Questions PART-1 | SatyaCodes</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Java - Interview Questions PART-1" />
<meta name="author" content="Satya Kaveti" />
<meta property="og:locale" content="en" />
<meta name="description" content="Basics What is a strongly typed programming language? In a strongly typed language compiler ensure type correctness, for example, you can not store the number in String or vice-versa. Java is a strongly typed language, that’s why you have different data types Ex int, float, String, char, boolean etc. On the other hand, weakly typed language don’t enforce type checking at compile time and they tree values based upon context. Python and Perl are two popular example of weakly typed programming language, where you can store a numeric string in number type. Can you describe three different kinds of testing that might be performed? Unit Testing, Integration Testing and Smoke Testing. Unit testing is used to test individual units to verify whether they are working as expected Integration Testing is done to verify whether individually tested module can work together or not Smoke Testing is a way to test whether most common functionality of software is working properly or not e.g. in a flight booking website, you should be able to book, cancel or change flights. What is the difference between iteration and recursion? (detailed answer) Iteration uses a loop to perform the same step again and again. Recursion calls the same method itself to do the repetitive task What is test-driven development? Test driven is one of the popular development methodologies in which tests are written before writing any function code. In fact, test drives the structure of your program. Purists never wrote a single line of application code without writing a test for that. It greatly improve code quality and often attributed as a quality of rockstar developers. How do you find a running Java process on UNIX? You can use the combination of ‘ps’ and ‘grep’ command to find any process running on UNIX machine. ps -e will list every process i.e. process from all user not just you and ps -f will give you full details including PID, which will be required if you want to investigate more or would like to kill this process using kill command. ps -ef grep “java” Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Garbage Collection? there are four kind of reference in Java : Strong reference Weak Reference Soft Reference Phantom Reference JVM Internals and Garbage Collection public class Zoo { public static void main(String[] args) { System.out.println(args[0]); System.out.println(args[1]); } } The program correctly identifies the first two -words” as the arguments. Spaces are used to separate the arguments. If you want spaces inside an argument, you need to use quotes as in this example: $ javac Zoo.java $ java Zoo &quot;San Diego&quot; Zoo All command-line arguments are treated as String objects, even if they represent another data type: $ javac Zoo.java $ java Zoo Zoo 2 Finally, what happens if you don’t pass in enough arguments? $ javac Zoo.java $ java Zoo Zoo Zoo Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 1 at mainmethod.Zoo.main(Zoo.java:7) public class Conflicts { Date date; // some more code } The answer should be easy by now. You can write either import java.util.*; or import java.util.Date;. The tricky cases come about when other imports are present: import java.util.*; import java.sql.*; // DOES NOT COMPILE import java.util.Date; import java.sql.*; If you explicitly import a class name, it takes precedence over any wildcards present. ■ octal (digits 0–7), which uses the number 0 as a prefix—for example, 017 ■ hexadecimal (digits 0–9 and letters A–F), which uses the number 0 followed by x or X as a prefix—for example, 0xFF ■ binary (digits 0–1), which uses the number 0 followed by b or B as a prefix—for example, 0b10 System.out.println(56); // 56 System.out.println(0b11); // 3 System.out.println(017); // 15 System.out.println(0x1F); // 31 added in Java 7. You can have underscores in numbers to make them easier to read: int million1 = 1000000; int million2 = 1_000_000; double notAtStart = _1000.00; // DOES NOT COMPILE double notAtEnd = 1000.00_; // DOES NOT COMPILE double notByDecimal = 1000_.00; // DOES NOT COMPILE double annoyingButLegal = 1_00_0.0_0; // this one compiles Declaring Multiple Variables int i1, i2, i3 = 0; As you should expect, three variables were declared: i1, i2, and i3. However, only one of those values was initialized: i3. The other two remain declared but not yet initialized. int num, String value; // DOES NOT COMPILE This code doesn’t compile because it tries to declare multiple variables of different types in the same statement. double d1, double d2; // DOES NOT COMPILE If you want to declare multiple variables in the same statement, they must share the same type declaration and not repeat it. double d1, d2; would have been legal. boolean b1, b2; String s1 = &quot;1&quot;, s2; double d1, double d2; int i1; int i2; int i3; i4; The first statement is legal. It declares two variables without initializing them. second statement is also legal. It declares two variables and initializes only one of them. The third statement is not legal. Variables d1 and d2 are the same type &amp; breaks between them. The fourth statement is legal.The fifth statement is not legal.The second one is not a valid declaration because it omits the type. Garbage Collection The methods to request JVM to run Garbage Collector System.gc() : ‘System’ class contains a static ‘gc’ method for requesting JVM to run Garbage Collector. Runtime.getRuntime().gc() : gc() method available in Runtime class is an instance method. 1.Nullifying the reference Variable Student s1 = new Student(); Student s2 = new Student(); //No Object eligible for Garbage Collector s1 = null; //One Object eligible for Garbage Collector s2 = null; Both Objects eligible for Garbage Collector 2.Reassigning the reference Variable Student s1 = new Student(); Student s2 = new Student(); s1 = s2; //One Object eligible for Garbage Collector 3.The Objects Created inside a method The objects which are created in a method are by default eligible for Garbage Collector once the method completes 1: public class Scope { 2: public static void main(String[] args) { 3: String one, two; 4: one = new String(&quot;a&quot;); 5: two = new String(&quot;b&quot;); 6: one = two; 7: String three = one; 8: one = null; 9: } } Difference between PATH and Classpath in Java? Answer : PATH is a environment variable in Java which is used to help Java program to compile and run.To set the PATH variable we have to include JDK_HOME/bin directory in PATH environment variable and also we cannot override this variable. On the other hand, ClassPath variable is used by class loader to locate and load compiled Java codes stored in .class file. We you want to run JUnit from any where from cmdline you eed to add Junit.jar in class path. Difference between interpreter and JIT compiler? The interpreter interprets the bytecode line by line and executes it sequentially. It results in poor performance. JIT compiler add optimization to this process by analyzing the code in blocks and then prepare more optimized machine code. Difference between JRE and JVM? JVM is the specification for runtime environment which executes the Java applications. Hotspot JVM is such one implementation of the specification. It loads the class files and uses interpreter and JIT compiler to convert bytecode into machine code and execute it. Difference Between JVM &amp; HotSpot VM JVM : is a Specification, HotSpot : is a implementation of JVM. HotSpot** **is an implementation of the JVM concept, originally developed by Sun and now owned by Oracle. There are other implementations of the JVM specification, like JRockit, IBM J9, among many others. Is Java a pure object oriented language? (answer) Java is not a pure object-oriented programming language e.g. There are many things in Java which are not objects e.g. primitive data types e.g. boolean, char, short, int, long, float, double, different kinds of arithmetic, logical and bitwise operator e.g. +, -. *, /, &amp;&amp;, || etc. Few pure OO languages are Smalltalk and Eiffel. There are seven qualities to be satisfied for a programming language to be pure Object Oriented. They are: 1.Encapsulation/Data Hiding 2.Inheritance 3.Polymorphism 4.Abstraction 5. All predefined types are objects 6. All operations are performed by sending messages to objects 7. All user defined types are objects How does WeakHashMap work? WeakHashMap operates like a normal HashMap but uses WeakReference for keys. Meaning if the key object does not devise any reference then both key/value mapping will become appropriate for garbage collection. How do you locate memory usage from a Java program? Answer: You can use memory related methods from java.lang.Runtime class to get the free memory, total memory and maximum heap memory in Java. public static Runtime getRuntime() returns the instance of Runtime class. public void exit(int status) terminates the current virtual machine. public void addShutdownHook(Thread hook) registers new hook thread. public Process exec(String command) executes given command in a separate process. public int availableProcessors() returns no. of available processors. public long freeMemory() returns amount of free memory in JVM. public long totalMemory() returns amount of total memory in JVM. public class TestApp { public static void main(String[] args) { Runtime r = Runtime.getRuntime(); System.out.println(r.totalMemory()); //16252928 System.out.println(r.freeMemory()); //15709576 System.out.println(r.availableProcessors());//24 r.gc(); } } What is ClassLoader in Java? When a Java program is converted into .class file by Java compiler which is collection of byte code. ClassLoader is responsible to load that class file from file system, network or any other location Bootstrap ClassLoader - JRE/lib/rt.jar Extension ClassLoader - JRE/lib/ext or any directory denoted by java.ext.dirs Application ClassLoader - CLASSPATH environment variable, -classpath or -cp option, Class-Path attribute of Manifest inside **JAR file.** Class Loader in Java BootStrap Extension and Application Java heap memory When a Java program started Java Virtual Machine gets some memory from Operating System. whenever we create an object using new operator or by any another means the object is allocated memory from Heap and When object dies or garbage collected, memory goes back to Heap space. How to increase heap size in Java Default size of Heap space in Java is 128MB on most of 32 bit Sun’s JVM but its highly varies from JVM to JVM. change size of heap space by using JVM options -Xms and -Xmx. Xms denotes starting size of Heap while -Xmx denotes maximum size of Heap in Java. Java Heap and Garbage Collection As we know objects are created inside heap memory and Garbage Collection is a process which removes dead objects from Java Heap space and returns memory back to Heap in Java. For the sake of Garbage collection Heap is divided into three main regions named as New Generation, Old Generation, and Perm space Screen Clipping New Generation of Java Heap is part of Java Heap memory where a newly created object is stored, Old Generation During the course of application many objects created and died but those remain live they got moved to Old Generation by Java Garbage collector thread Perm space of Java Heap is where JVM stores Metadata about classes and methods, String pool and Class level details. Perm Gen stands for permanent generation which holds the meta-data information about the classes. Suppose if you create a class name A, it’s instance variable will be stored in heap memory and class A along with static classloaders will be stored in permanent generation. Garbage collectors will find it difficult to clear or free the memory space stored in permanent generation memory. Hence it is always recommended to keep the permgen memory settings to the advisable limit. JAVA8 has introduced the concept called meta-space generation, hence permgen is no longer needed when you use jdk 1.8 versions. Eden Space – New Objects are Created Survivor Space – Once Eden space is full, Minor thread try to clear the Space, the objects which are survived by GC will be placed in Survivor space. Old Gen – Objects which are survived from a long time, let say 16 Cycles (GC cycle Threshold) of Minor Garbage Collector, those objects moved to Old Gen. The Old Gen space finally collected by Main Garbage collector. Finally, Minor Garbage collector will runs only on Young Gen, Main Garbage Collector will run on whole heap space Does Garbage collection occur in permanent generation space in JVM? YES, Garbage Collection occur in PermGen space as well. and if PermGen space is full or cross a threshold, it can trigger Full GC(Main Thread). If you look at output of GC you will find that PermGen space is also garbage collected. This is why correct sizing of PermGen space is important to avoid frequent full GC. You can control size of PermGen space by JVM options -XX:PermGenSize and -XX:MaxPermGenSize. Types of Garbage Collectors When an object is no longer used, the garbage collector reclaims the underlying memory and reuses it for future object allocation. This means there is no explicit deletion and no memory is given back to the operating system. Java has four types of garbage collectors, Serial Garbage Collector Parallel Garbage Collector CMS Garbage Collector G1 Garbage Collector Each of these four types has its own advantages and disadvantages. Most importantly, we the programmers can choose the type of garbage collector to be used by the JVM. We can choose them by passing the choice as JVM argument 1. Serial Garbage Collector It is designed for the single-threaded environments. It uses just a single thread for garbage collection. It freezes(stops) all the application threads while performing garbage collection. it may not be suitable for a server environment. It is best suited for simple command-line programs. Turn on the **-XX:+UseSerialGC **JVM argument to use the serial garbage collector. 2. Parallel Garbage Collector It is the default garbage collector of the JVM. It uses multiple threads for garbage collection. Similar to serial garbage collector this also freezes(siops) all the application threads while performing garbage collection. 3. Concurrent Garbage Collector Concurrent Mark Sweep (CMS) garbage collector uses multiple threads to scan the heap memory to mark instances for eviction and then sweep the marked instances. It runs along with our Application. Uses multiple cores(cpus) to run multiple GC’s concurrently. Here your application won’t pass/stop Turn on the XX:+USeParNewGC JVM argument to use the CMS garbage collector. 4. G1 Garbage Collector G1 garbage collector is used for large heap memory areas. It separates the heap memory into regions and does collection within them in parallel. G1 also does compacts the free heap space on the go just after reclaiming the memory. G1 collector prioritizes the region based on most garbage first. Turn on the –XX:+UseG1GC JVM argument to use the G1 garbage collector. https://www.youtube.com/watch?v=UnaNQgzw4zY Java 8 Improvement Turn on the -XX:+UseStringDeduplication **JVM argument while using G1 garbage collector. This optimizes the heap memory by removing duplicate String values to a single char[] array**. This option is introduced in Java 8 u 20. Given all the above four types of Java garbage collectors, which one to use depends on the application scenario, hardware available and the throughput requirements. Garbage Collection JVM Options Type of Garbage Collector to run Option Description -XX:+UseSerialGC Serial Garbage Collector -XX:+UseParallelGC Parallel Garbage Collector -XX:+UseConcMarkSweepGC CMS Garbage Collector -XX:ParallelCMSThreads= CMS Collector – number of threads to use -XX:+UseG1GC G1 Gargbage Collector GC Optimization Options Option Description -Xms Initial heap memory size -Xmx Maximum heap memory size -Xmn Size of Young Generation -XX:PermSize Initial Permanent Generation size -XX:MaxPermSize Maximum Permanent Generation size Garbage collection is performed by a daemon thread called Garbage Collector(GC). This thread calls the finalize() method before object is garbage collected. The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing (destroying remaining objects). Neither finalization nor garbage collection is guaranteed. How String Literals Garbage Collected? Strings created without using the new keyword are NEVER garbage collected. Even if there are no references to them. All such strings go into the String pool and just sit there till the whole program ends (ie. the JVM).The String Const. pool cleaned up when the class is unloaded by the JVM. How to you monitor garbage collection activities? just to check whether candidate has ever monitored GC activities or not. You can monitor garbage collection activities either offline or real-time. You can use tools like JConsole and VisualVM VM with its Visual GC plug-in to monitor real time garbage collection activities and memory status of JVM or you can redirect Garbage collection output to a log file for offline analysis by using -XlogGC=&lt;PATH&gt; JVM parameter. Anyway you should always enable GC options like -XX:PrintGCDetails -X:verboseGCand -XX:PrintGCTimeStamps as it doesn’t impact application performance much but provide useful states for performance monitoring. How do you identify minor and major garbage collection in Java? Minor collection prints GC if garbage collection logging is enable using –verbose:gc or -XX:PrintGCDetails Major collection prints -Full GC”. How to Generate GC Log File? In order to understand the GC log, you first need to generate one. Passing the following system properties to your JVM would generate GC logs -XX:+PrintGCDetails -XX:+PrintGCDateStamps –Xloggc:D://gc.log Or add visual-gc plugin to visualVM What Security model used by Java? Sandbox. The sandbox security model makes it easier to work with software that comes from sources you don’t fully trust. What is -Phontom” memory A memory that doesn’t exist in reality. A phantom reference lets you do final touch up closing on an object, even after it has been declared dead — no longer referenced by any live object. During garbage collection, these reference objects are handled specially; that is, the referent field is not traced during the marking phase. When marking is complete, the references are processed in sequence for sweeping phase. Soft Weak Final Phantom How many JVMs can run on a single machine? Multiple, yes You can run as many JVMs as you can fit on your disk and in memory :) Whenever you start a Java application, you’re first starting the JVM and then telling it which application to run. The answer to “which JVM” is simply: The JVM that you loaded the application with! for example, for execution of applets a separate JVM may exist and another JVM can be started by the User for execution of Java Byte Code, on a single machine. Difference between Object Oriented and Object Based language Object Oriented Languages Object Oriented Languages supports all the features of Oops Abstraction, Encapsulation, Polymorhisum, Inhertance. C#, Java, VB. Net are the examples of object oriented languages. Object Based Languages Object based languages does not support inheritance or, polymorphism or, both. Object based languages does not support built-in objects. Javascript, VB are the examples of object bases languages. If I don’t provide any arguments on commandline, then String array of main() is Empty or NULL? It’s Empty, but not Null. Is main method compulsory in Java? The answer to this question depends on version of java you are using. Prior to JDK 5, main method was not mandatory in a java program. You could write your full code under static block and it ran normally. The static block is first executed as soon as the class is loaded before the main(); Read more: https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html#ixzz5fwmNzRHE Read more: https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html#ixzz5fwm9nzDa Data Types How do you convert bytes to String? you can convert bytes to the string using string constructor which accepts byte[], just make sure that right character encoding otherwise platform’s default character encoding will be used which may or may not be same. String str = new String(bytes, &quot;UTF-8&quot;); How do you convert bytes to long in Java The byte takes 1 byte of memory and long takes 8 bytes of memory. Assignment 1 byte value to 8 bytes is done implicitly by the JVM. byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double The left-side value can be assigned to any right-side value and is done implicitly. The reverse requires explicit casting. byte b1 = 10; // 1 byte long l1 = b1; // one byte to 8 bytes, assigned implicitly Is ++ operator is thread-safe in Java? No it’s not a thread safe operator because its involve multiple instructions like reading a value, incriminating it and storing it back into memory which can be overlapped between multiple threads. Volatile Vs Atomic variables? Volatile Example If writerThread() is executed by one thread &amp; readerThread() is executed by another thread the ‘x’ value is different for two threads because they are reading value from their LocalCache. Here the changes of X value is not visible globally (Field Visibility), because they are changing in LocalCache. To avoid this, we need to use ‘volatile’ keyword for fields. The Java volatile keyword is used to mark a Java variable as “being stored in main memory”. that means, every read of a volatile variable will be read from the main memory(Shared Memory), and not from the CPU cache every write to a volatile variable will be written to main memory, and not just to the CPU cache. In the above diagram two threads t1, t2 are trying to change the value of flag. If Thread1 changes value flag=false, then it will flush(push) the changes from LocalCache to SharedCache and it will refresh the all Thread LocalCaches with updated value. If Thread 2 is trying to read, it will get updated value. Volatile solves the visibility problem, where Only one operation is perform Amtomic Problem Atomic - forming a single irreducible unit or component in a larger system. Increment (++) is an Compound Operation(multiple). AtomicVaribles makes compound operations as Atomic(Single) We can solve this problem using Synchronization Another Way using Atomic Variables Atomic Varibles The java.util.concurrent.atomic package defines classes that support atomic operations on single variables. All classes have get and set methods that work like reads and writes on volatile variables. We have following Atomic classes AtomicInteger AtomicLong AtomicBoolean AtomicReference AtomicIntegerArray AtomicLongArray AtomicReferenceArray Common methods incrementAndGet(): Atomically increments by one the current value. decrementAndGet(): Atomically decrements by one the current value. addAndGet(int delta): Atomically adds the given value to the current value. compareAndSet(int expect, int update): Atomically sets the value to the given updated value if the current value == the expected value. getAndAdd(int delta): Atomically adds the given value to the current value. set(int newValue): Sets to the given value. What will this return 3*0.1 == 0.3? true or false? Both are not equal, because floating point arithmetic has a certain precision. Check the difference (a-b) it should be really small. In computer memory, floats and doubles are stored using IEEE 754 standard format. f1 = (0.1+0.1+0.1….11 times) = 1.0999999999999999 f2 = 0.1*11 = 1.1 In BigDecimal class, you can specify the rounding mode and exact precision which you want to use. Using the exact precision limit, rounding errors are mostly solved. Best part is that BigDecimal numbers are immutable i.e. if you create a BigDecimal BD with value -1.23”, that object will remain -1.23” and can never be changed. You can use it’s .compareTo() method to compare to BigDecimal numbers private static void testBdEquality() { BigDecimal a = new BigDecimal(&quot;2.00&quot;); BigDecimal b = new BigDecimal(&quot;2.0&quot;); System.out.println(a.equals(b)); // false System.out.println(a.compareTo(b) == 0); // true } Which one will take more memory, an int or Integer? (answer) An Integer object will take more memory. an Integer is the an object and it store meta data overhead about the object and int is primitive type so its takes less space. Autoboxing and Unboxing? If a method(remember only method – not direct) requires Integer Object value, we can directly pass primitive value without issue. Autoboxing will take care about these. We can also do direct initializations (1.8 V) Integer i = 10;// it will create Integer value of 10 using Autoboxing int j = i;// ;// it will convert Integer to int using Autoboxing Previously it shows Integer i = 10;// it will create Integer value of 10 using Autoboxing int j = i;//But we cant assign int to Integer Type mismatch: cannot convert from Integer to int How to convert Primitives to Wrapper &amp; Wrapper to Primitive ?? // 1. using constructor Integer i =new Integer(10); // 2. using static factory method Integer i = Integer.valueOf(10); //3.wrapper to primitive int val = i.intValue(); How does Autoboxing of Integer works in Java? (answer) Compiler uses valueOf() method to convert primitive to Object uses intValue(), doubleValue() etc to get primitive value from Object. what if I make main() private/protected ? if you do not make main() method public, there is no compilation error. You will runtime error because matching main() method is not present. Remember that whole syntax should match to execute main() method. Error: Main method not found in class Main, please define the main method as: public static void main(String[] args) What is blank final variable? A blank final variable in Java is a final variable that is not initialized during declaration. Below is a simple example of blank final. // A simple blank final example final int i; Value must be assigned in constructor/Static(static final) /Instance block before using it. If we have more than one constructors or overloaded constructor in class, then blank final variable must be initialized in all of them. Difference between java.util.Date &amp; java.sql.Date? java.util.Date represent both Date and Time information. java.sql.Date just represent DATE without time information. java.sql.Time and java.sql.TimeStamp which represents TIME and TIMESTAMP type of SQL database is more close to java.util.Date. java.util.Date is Super class of java.sql.Date Why Java does not support Operator Overloading? The meaning of an operator is always same for variable of basic types like: int, float, double etc. For example: To add two integers, + operator is used. However, for user-defined types (like: objects), you can redefine the way operator works. For example: If there are two objects of a class that contains string as its data members. You can redefine the meaning of + operator and use it to concatenate those strings. To overload an operator, a special operator function is defined inside the class as class className { ... .. ... public returnType operator symbol (arguments) { ... .. ... } ... .. ... }; #include &lt;iostream&gt; using namespace std; class Test { private: int count; public: Test(): count(5){} void operator ++() { count = count+1; } void Display() { cout&lt;&lt;&quot;Count: &quot;&lt;&lt;count; } }; int main() { Test t; // this calls &quot;function void operator ++()&quot; function ++t; t.Display(); return 0; } This function is called when ++ operator operates on the object of Test class (object t in this case). In the program, void operator ++ () operator function is defined (inside Test class). This function increments the value of count by 1 for t object. Why Java Doesn’t Support it? 1.Java is Simple, No Confusions Please!! Java does not support operator overloading: Java is relatively a very simple language to use compared C/C++ with the non-support of complex and confusing features like pointers, multiple inheritance and operator overloading. These features are rarely used in practice and at the same time poorly understood by the language beginners. 2.JVM Performance: How many things Should i do? Form JVM perspective supporting operator overloading is more difficult and if the same thing can be achieved by using method overloading in more intuitive and clean way it does make sense to not support operator overloading in java. a complex JVM will result in slower JVM Can you store String in an Integer array in Java? compile time error or runtime exception? [answer] You cannot store an String in an array of primitive int, it will result in compile time error as shown below, but if you create an array of Object and assign String[] to it and then try to store Integer object on it. Compiler won’t be able to detect that and it will throw ArrayStoreExcpetion at runtime int[] primes = new int[10]; primes[0] = &quot;a&quot;; // compile time error Object[] names = new String[3]; names[0] = new Integer(0);// ArrayStoreException at runtime What is difference between ArrayIndexOutfOBounds and ArrayStoreException? [answer] ArrayIndexOutOfBoundsException comes when your code tries to access an invalid index for a given array e.g. negative index or higher index than length - 1. ArrayStoreException comes when you have stored an element of type other than type of array, as shown in above example. Is it legal to initialize an array int i[] = {1, 2, 3, 4, 5}; [answer] Yes, it’s perfectly legal. You can create and initialize array in same line in Java. Where does array stored in memory? [answer] Array is created in heap space of JVM memory. Since array is object in Java, even if you create array locally inside a method or block, object is always allocated memory from heap. Array concept interview questions and answers in Java Reverse Array using Iterative and Recursive approaches Steps to Solve this 1.initialize array 2.Choose start index 3.Choose end index 4.Swap the elements using temp variable package array; public class ReverseArry { /* * Recursive approach: In recursive approach the function calls itself until * the condition is met. And it is slower than iteration, which means it uses * more memory than iteration. recursion is like a selection structure, and * which makes code smaller and clean. And a function partially defined by * itself. Here tracing the code will be more difficult in the case large * programs */ public static int[] recursiveArry(int a[], int start, int end) { if (start &lt;= end) { int temp; temp = a[start]; a[start] = a[end]; a[end] = temp; recursiveArry(a, start + 1, end - 1);//calling it again } return a; } /* *Iterative approach: Iterative approach is a repetition process until the condition fails.here loops are used such as for, while etc. Here code may be longer but it is faster than recursive. And it consumes less memory compared to recursive approach.If the loop condition is always true in such cases it will be an infinite loop. */ public static int[] iteravtiveArray(int a[], int start, int end) { while(start&lt;end) { int temp; temp = a[start]; a[start]=a[end]; a[end]=temp; start++; end--; } return a; } static void printArray(int arr[], int size) { int i; for (i = 0; i &lt; size; i++) System.out.print(arr[i] + &quot; &quot;); System.out.println(&quot;&quot;); } public static void main(String[] args) { // 1. Initialize array int arr[] = { 1, 2, 3, 4, 5, 6 }; System.out.println(&quot;Input array is &quot;); printArray(arr, 6); // 2. Choose Starting &amp; ending point int b[] = recursiveArry(arr, 0, 5); System.out.println(&quot;Recursive -Reversed array is &quot;); printArray(b, 6); int c[] = iteravtiveArray(arr, 0, 5); System.out.println(&quot;IteravtiveArray -Reversed array is &quot;); printArray(c, 6); } } Input array is 1 2 3 4 5 6 Recursive -Reversed array is 6 5 4 3 2 1 How do you reverse an array in Java? org.apache.commons.lang.ArrayUtils class to reverse Array in Java. As discussed in our last post How to print array element in Java, We are using Arrays.toString() to print content of array. int[] iArray = new int[] {101,102,103,104,105}; String[] sArray = new String[] {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;}; //reverse int array using Apache commons ArrayUtils.reverse() method System.out.println(&quot;Original int array : &quot; + Arrays.toString(iArray)); ArrayUtils.reverse(iArray); java.lang Package We have mainly five classes in java.lang. Which are most commonly used in any java program Object String StringBuffer StringBuilder Wrapper Classes (AutoBoxing / AutoUnboxing) Object Class The most common general methods which can be applicable on any java object are defined in object class. Object class is the parent class of any java class, whether it is predefined or programmer defined, hence all the object class methods are by default available to any java class. Object class define the following 11 methods 1.toString():Returns a string representation of the object. public String toString() { return getClass.getName() + &#39;@&#39; + Integer.toHexString(HashCode); } 2.hashCode():returns the integer representation of memory location which used by JVM while saving/adding Objects into Hashsets, Hashtables or Hashmap 3.equals(Object): Compares two Objects for equality. 4.clone(): Creates a new object of the same class as this object which implements Clonable interface. Test t1 = new Test(); Test t2 = (Test)t1.clone(); 5.finalize():Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. 6.getClass():Returns the runtime class of an obj.getClass(), or the class-literal (Foo.class) return a Class object, which contains some metadata about the class: name package methods fields constructors annotations we can create Class object by following ways Class c = Class.forName(-StudentBO&quot;) Class c = StudentBO.class Class c = a.getClass(); public static void main(String[] args) throws Exception { TestApp a = new TestApp(); Class c1 = a.getClass(); Class c = Class.forName(&quot;java.lang.String&quot;); System.out.print(&quot;Class represented by c : &quot; + c.toString()); Object obj = c.newInstance(); } 7.wait():Waits to be notified by another thread of a change in this object. 8.wait(long):Waits to be notified by another thread of a change in this object. 9.wait(long, int):Waits to be notified by another thread of a change in this object. 10.notify():Wakes up a single thread that is waiting on this object’s monitor. 11.notifyAll():Wakes up all threads that are waiting on this object’s monitor. equals(Object otherObject) – As method name suggests, is used to simply verify the equality of two objects. It’s default implementation simply check the object references of two objects to verify their equality. By default, two objects are equal if and only if they are stored in the same memory address. hashcode() – Returns a unique integer value for the object in runtime. By default, integer value is mostly derived from memory address of the object in heap (but it’s not mandatory always). If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. Whenever we override the equals() method, we should override hashcode() method In String class(not StringBuilder, StringBuffer) &amp; All Wrapper classes equals() method is overridden for Content Comparison Compare two employee Objects based on Their Id? public class Employe { int id; String name; //Setters &amp; Getters @Override public boolean equals(Object obj) { Employe e = (Employe) obj; boolean flag = false; if (this.getId() == e.getId()) { flag = true; } return flag; } public static void main(String[] args) { Employe e1 = new Employe(); Employe e2 = new Employe(); e1.setId(101); e2.setId(101); System.out.println(e1.equals(e2));//true System.out.println(e1.hashCode()); //366712642 System.out.println(e2.hashCode()); //1829164700 – here different } } So are we done? If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. But here it is not!! Not yet. Lets test again above modified Employee class in different way. public static void main(String[] args) { Employe e1 = new Employe(); Employe e2 = new Employe(); e1.setId(101); e2.setId(101); Set&lt;Employe&gt; set = new HashSet&lt;&gt;(); set.add(e1); set.add(e2); System.out.println(set); //[basic.Employe@15db9742, basic.Employe@6d06d69c] } Above class prints two objects in the second print statement. If both employee objects have been equal, in a Set which stores only unique objects, there must be only one instance inside HashSet We are missing the second important method hashCode(). As java docs say, if you override equals()method then you must override hashCode() method public class Employe { int id; String name; @Override public boolean equals(Object obj) { Employe e = (Employe) obj; boolean flag = false; if (this.getId() == e.getId()) { flag = true; } return flag; } @Override public int hashCode() { return getId(); } public static void main(String[] args) { Employe e1 = new Employe(); Employe e2 = new Employe(); e1.setId(101); e2.setId(101); Set&lt;Employe&gt; set = new HashSet&lt;&gt;(); set.add(e1); set.add(e2); System.out.println(set); //[basic.Employe@65] } } Apache commons provide two excellent utility classes EqualsBuilder &amp; HashCodeBuilder for generating hash code and equals methods. Can a top-level class be private or protected? Top level classes in java can’t be private or protected, but inner classes in java can. The reason for not making a top-level class as private is very obvious, because nobody can see a private class and thus they cannot use it What Happens if we compile Empty java file? Compiles but Runtime Error. Is it possible to make array volatile in Java? Yes, you can make an array (both primitive and reference type array e.g. an int array and String array) volatile in Java, but only changes to reference pointing to an array will be visible to all threads, not the whole array. What this means is that suppose you have a reference variable called primes as shown below: protected volatile int[] primes = new int[10]; then if you assign a new array to primes variable, change will be visible to all threads, but changes to individual indices(a[0], a[1]…a[n]) will not be covered under volatile guarantee i.e. primes = new int[20]; It will follow the “happens-before” rule(Happens-before relationship is a guarantee that action performed by one thread is visible to another action in different thread.) and cause memory refresh, but following code will not do so if multiple threads are changing individual array elements e.g. storing updates, there won’t be any happens-before guarantee provided by the volatile modifier for such modification primes[0] = 10; primes[1] = 20; primes[2] = 30; primes[3] = 40; So, if your use-case is to provide memory visibility guarantee for individual array elements than volatile is not the right choice. You must rely on other synchronization and a thread-safety mechanism to cover this case e.g. synchronized** keyword, atomic variables, or ReentrantLock.** Is it possible to make ArrayList, Hashset volatile in Java? On a similar note, sometimes instead of an array, Interviewer put the collection i.e. they will ask can you make a collection variable volatile in Java or not e.g. an ArrayList or HashMap. The answer is same, of course, you can make a reference variable pointing to a Collection volatile in Java, but the happens-before guarantee will only be provided if the value of that reference variable is changed e.g. you assign a new collection to it. Any modification done on actual collection object e.g. adding or removing elements from ArrayList will not invoke happens-before guarantee or memory barrier refresh. What is a.hashCode() used for? How is it related to a.equals(b)? According to the Java specification, two objects which are identical to each other using equals() method needs to have the same hash code What is a compile time constant in Java? What is the risk of using it? Answer: Public static final variables are also known as the compile time constant, the public is optional there. They are substituted with actual values at compile time because compiler recognizes their value up-front, and also recognize that it cannot be altered during runtime. One of the issues is that if you choose to use a public static final variable from in-house or a third party library, and their value changed later, then your client will still be using the old value even after you deploy a new version of JARs. Explain Liskov Substitution Principle. According to the Liskov Substitution Principle, Subtypes must be appropriate for super type i.e. methods or functions which use super class type must be able to work with object of subclass without issues. Co-Variant return types are implemented based on this principle. What is double checked locking in Singleton? Singleton means we can create only one instance of that class Rules: Create Singleton class Object make it as PRIVATE Create PRIVATE constructor Every Singleton class contains at least one factory method class Student { private static Student st; private Student() { System.out.println(&quot;OBJECET Created FIRST TIME&quot;); } public static Student getObject() { if (st == null) { st = new Student(); } else { System.out.println(&quot;OBJECET ALREDAY CREATED&quot;); } return st; } } public class Singleton { public static void main(String[] args) { Student s1 = Student.getObject(); Student s2 = Student.getObject(); System.out.println(s1.hashCode());//7855445 System.out.println(s2.hashCode());//7855445 } } Double checked locking in Singleton means, at any cost only one instance is created in multi-threaded environment. In this case at null checking make Block as Synchronized. public static Singleton getInstanceDC() { if (_instance == null) { // Single Checked synchronized (Singleton.class) { if (_instance == null) { // Double checked _instance = new Singleton(); } } } return _instance; } When to use volatile variable in Java? Volatile keyword is used with only variable in Java it guarantees that value of volatile variable will always be read from main memory and not from Thread’s local cache. So, we can use volatile to achieve synchronization because its guaranteed that all reader thread will see updated value of volatile variable once write operation completed Difference between Serializable and Externalizable in Java? Serialization is a default process of serializing or persisting any object’s state in Java. It’s triggered by implementing Serializable interface which is a marker interface (an interface without any method). uses default implementation to handle the object serialization process. Externalizable is used to user defined serialization process and control default serialization process which is implemented by application. Externalizable interface extends Serializable interface. It consists of two methods // to read object from stream void readExternal(ObjectInput in) // to write object into stream void writeExternal(ObjectOutput out) Difference between static and dynamic binding in Java? (detailed answer) This is usually asked as follow-up of previous question, static binding is related to overloaded method and dynamic binding is related to overridden method. Method like private, final and static are resolved using static binding at compile time but virtual methods which can be overridden are resolved using dynamic binding at runtime. Which design pattern have you used in your production code? Dependency injection Factory pattern Adapter Design pattern Singleton Decoratordesign pattern is used to modify the functionality of an object at runtime. Can you explain Liskov Substitution principle?(Comes under inheritance ) According to Liskov Substitution Principle, Subtypes must be substitutable for supertype i.e. methods or functions which uses superclass type must be able to work with the object of subclass without any issue How to create an instance of any class without using new keyword ***************************************** 1.Using newInstance method of Class class ***************************************** Class c = Class.forName(&quot;StudentBo&quot;); StudentBo bo = (StudentBo) c.newInstance(); ***************************************** 2.Using clone() of java.lang.Object ***************************************** NewClass obj = new NewClass(); NewClass obj2 = (NewClass) obj.clone(); How can we invoke any external process in java? Using, Runtime.getRuntime().exec(…) Static imports rules ? The static import feature of Java 5 facilitates the java programmer to access any static member of a class directly. There is no need to qualify it by the class name. import static java.lang.System.*; (or) import static java.lang.System.out; class StaticImportExample{ public static void main(String args[]){ out.println(&quot;Hello&quot;);//Now no need of System.out out.println(&quot;Java&quot;); } } Ambiguity in static import // both have MAX_VALUE as static import static java.lang.Integer.*; import static java.lang.Byte.*; class Geeks { public static void main(String[] args) { out.println(MAX_VALUE); } } Error:Reference to MAX_VALUE is ambigious Java OOPs Concepts Can we prevent overriding a method without using the final modifier? (answer) Yes, you can prevent the method overriding in Java without using the final modifier. In fact, there are several ways to accomplish it e.g. you can mark the method private or static, those cannot be overridden. Can we override a private method in Java? (answer) No, you cannot. Since the private method is only accessible and visible inside the class they are declared, it’s not possible to override them in subclasses. But we can re-decalre in sub class , it will trated as a new method, bcoz parent class private method is not visible to subclass. class A{ private void show() { System.out.println(&quot;Parent&quot;); } } public class Demo extends A{ private void show() { System.out.println(&quot;Child&quot;); } public static void main(String[] args) { A a = new Demo(); a.show(); } } Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: The method show() from the type A is not visible at Demo.main(Demo.java:12) Though, you can override them inside the inner class as they are accessible there. Can we change the return type of method to subclass while overriding? (answer) Yes, you can, but only from Java 5 onward. This feature is known as covariant method overriding and it was introduced in JDK 5 release. This is immensely helpful if original method return super-class e.g. clone() method return java.lang.Object. By using this, you can directly return the actual type, preventing client-side type casting of the result. Can we make a class both final and abstract at the same time? (answer) No, you cannot apply both final and abstract keyword at the class same time because they are exactly opposite of each other. A final class in Java cannot be extended and you cannot use an abstract class without extending and make it a concrete class. As per Java specification, the compiler will throw an error if you try to make a class abstract and final at the same time. Can we overload or override the main method in Java? (answer) No, since main() is a static method, you can only overload it, you cannot override it because the static method is resolved at compile time without needing object information hence we cannot override the main method in Java. Design Patterns SOLID design principles and GOF design patterns which take advantage of OOPS concept discussed here. What are SOLID Design principles Image result for solid design principles 1. Single Responsibility Principle -One class should have one and only one responsibility” In other words, we should write, change and maintain a class for only one purpose. If it is model class then it should strictly represent only one actor/ entity. This will give we the flexibility to make changes in future without worrying the impacts of changes for another entity. 2. Open Closed Principle -Software components should be open for extension, but closed for modification” If we take a look into any good framework like struts or spring, we will see that we cannot change their core logic and request processing, but we modify the desired application flow just by extending some classes and plugin them in configuration files. For example, spring framework has class DispatcherServlet. This class acts as front controller for String based web applications. To use this class, we are not required to modify this class. All we need is to pass initialization parameters and we can extend it’s functionality the way we want. 3. Liskov’s Substitution Principle -Derived types must be completely substitutable for their base types” 4. Interface Segregation/Separation Principle This principle is my favorite one. It is applicable to interfaces as single responsibility principle holds to classes. ISP says: -Clients should not be forced to implement unnecessary methods which they will not use” Take an example. Developer Alex created an interface Reportable and added two methods generateExcel() and generatedPdf(). Now client ‘A’ wants to use this interface but he intend to use reports only in PDF format and not in excel. Will he be able to use the functionality easily? NO. He will have to implement both the methods, out of which one is extra burden put on him by designer of software. Either he will implement another method or leave it blank. This is not a good design. 5. Dependency Inversion/Injection Principle Remove dependency from classes In spring framework, all modules are provided as separate components which can work together by simply injected dependencies in other module. This dependency is managed externally in XML files. What are GOF(Gang of Four) design patterns? Image result for gof design patterns 1. Creational Design Patterns (Object Creation) Creational patterns often used in place of direct instantiation with constructors. They make the creation process more adaptable and dynamic. In particular, they can provide a great deal of flexibility about which objects are created, how those objects are created, and how they are initialized. DESIGN PATTERN NAME PURPOSE Builder Builder design pattern is an alternative way to construct complex objects and should be used only when we want to build different types of immutable objects using same object building process. Prototype Prototype design pattern is used in scenarios where application needs to create a large number of instances of a class, which have almost same state or differ very little. Factory Factory design pattern is most suitable when complex object creation steps are involved. To ensure that these steps are centralized and not exposed to composing classes. Abstract factory Abstract factory pattern is used whenever we need another level of abstraction over a group of factories created using factory pattern. Singleton Singleton enables an application to have one and only one instance of a class per JVM. 2. Structural Design Patterns Structural design patterns show us how to glue different pieces of a system together in a flexible and extensible fashion. These patterns help us guarantee that when one of the parts changes, the entire application structure does not need to change. DESIGN PATTERN NAME PURPOSE Adapter An adapter convert the interface of a class into another interface clients expect. It lets classes work together that couldn’t otherwise because of incompatible interfaces. Bridge Bridge design pattern is used to decouple a class into two parts – abstraction and it’s implementation – so that both can evolve in future without affecting each other. It increases the loose coupling between class abstraction and it’s implementation. Composite Composite design pattern helps to compose the objects into tree structures to represent whole-part hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly. Decorator Decorator design pattern is used to add additional features or behaviors to a particular instance of a class, while not modifying the other instances of same class. Facade Facade design pattern provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use. Flyweight Flyweight design pattern enables use sharing of objects to support large numbers of fine-grained objects efficiently. A flyweight is a shared object that can be used in multiple contexts simultaneously. The flyweight acts as an independent object in each context. Proxy In proxy design pattern, a proxy object provide a surrogate or placeholder for another object to control access to it. Proxy is heavily used to implement lazy loading related usecases where we do not want to create full object until it is actually needed. 3. Behavioral Design Patterns Behavioral patterns abstract an action we want to take on the object or class that takes the action. By changing the object or class, we can change the algorithm used, the objects affected, or the behavior, while still retaining the same basic interface for client classes. DESIGN PATTERN NAME PURPOSE Chain of responsibility Chain of responsibility design pattern gives more than one object an opportunity to handle a request by linking receiving objects together in form of a chain. Command Command design pattern is useful to abstract the business logic into discrete actions which we call commands. These command objects help in loose coupling between two classes where one class (invoker) shall call a method on other class (receiver) to perform a business operation. Interpreter Interpreter pattern specifies how to evaluate sentences in a language, programatically. It helps in building a grammar for a simple language, so that sentences in the language can be interpreted. Iterator Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. Mediator Mediator pattern defines an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets us vary their interaction independently. Memento Memento pattern is used to restore state of an object to a previous state. It is also known as snapshot pattern. Observer Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It is also referred to as the publish-subscribe pattern. State In state pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class. There shall be a separate concrete class per possible state of an object. Strategy Strategy pattern is used where we choose a specific implementation of algorithm or task in run time – out of multiple other implementations for same task. Template method Template method pattern defines the sequential steps to execute a multi-step algorithm and optionally can provide a default implementation as well (based on requirements). Visitor Visitor pattern is used when we want a hierarchy of objects to modify their behavior but without modifying their source code. What is Strategy pattern in Java? Strategy pattern allows you to introduce new strategy without changing the code. For example, the Collections.sort() method which sorts the list of the object uses the Strategy pattern to compare object. Since every object uses different comparison strategy you can compare various object differently without changing sort method. What is Decorator Design Pattern? Decorator pattern provides new features without modifying the original class. Inheritance is the example. What is the difference between Decorator, Proxy and Adapter pattern in Java? (answer) Again they look similar because their structure or class diagram is very similar but their intent is quite different. Decorator adds additional functionality without touching the class, Proxy provides access control and Adapter is used to make two incompatible interfaces work together. What is a strongly typed programming language? In a strongly typed language compiler ensure type correctness, for example, you can not store the number in String or vice-versa. Java is a strongly typed language, that’s why you have different data types Ex int, float, String, char, boolean etc. On the other hand, weakly typed language don’t enforce type checking at compile time and they tree values based upon context. Python and Perl are two popular example of weakly typed programming language, where you can store a numeric string in number type. Can you describe three different kinds of testing that might be performed? Unit Testing, Integration Testing and Smoke Testing. Unit testing is used to test individual units to verify whether they are working as expected Integration Testing is done to verify whether individually tested module can work together or not Smoke Testing is a way to test whether most common functionality of software is working properly or not e.g. in a flight booking website, you should be able to book, cancel or change flights. What is the difference between iteration and recursion? (detailed answer) Iteration uses a loop to perform the same step again and again. Recursion calls the same method itself to do the repetitive task What is test-driven development? Test driven is one of the popular development methodologies in which tests are written before writing any function code. In fact, test drives the structure of your program. Purists never wrote a single line of application code without writing a test for that. It greatly improve code quality and often attributed as a quality of rockstar developers. How do you find a running Java process on UNIX? You can use the combination of ‘ps’ and ‘grep’ command to find any process running on UNIX machine. ps -e will list every process i.e. process from all user not just you and ps -f will give you full details including PID, which will be required if you want to investigate more or would like to kill this process using kill command. ps -ef grep “java” Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Garbage Collection? there are four kind of reference in Java : Strong reference Weak Reference Soft Reference Phantom Reference" />
<meta property="og:description" content="Basics What is a strongly typed programming language? In a strongly typed language compiler ensure type correctness, for example, you can not store the number in String or vice-versa. Java is a strongly typed language, that’s why you have different data types Ex int, float, String, char, boolean etc. On the other hand, weakly typed language don’t enforce type checking at compile time and they tree values based upon context. Python and Perl are two popular example of weakly typed programming language, where you can store a numeric string in number type. Can you describe three different kinds of testing that might be performed? Unit Testing, Integration Testing and Smoke Testing. Unit testing is used to test individual units to verify whether they are working as expected Integration Testing is done to verify whether individually tested module can work together or not Smoke Testing is a way to test whether most common functionality of software is working properly or not e.g. in a flight booking website, you should be able to book, cancel or change flights. What is the difference between iteration and recursion? (detailed answer) Iteration uses a loop to perform the same step again and again. Recursion calls the same method itself to do the repetitive task What is test-driven development? Test driven is one of the popular development methodologies in which tests are written before writing any function code. In fact, test drives the structure of your program. Purists never wrote a single line of application code without writing a test for that. It greatly improve code quality and often attributed as a quality of rockstar developers. How do you find a running Java process on UNIX? You can use the combination of ‘ps’ and ‘grep’ command to find any process running on UNIX machine. ps -e will list every process i.e. process from all user not just you and ps -f will give you full details including PID, which will be required if you want to investigate more or would like to kill this process using kill command. ps -ef grep “java” Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Garbage Collection? there are four kind of reference in Java : Strong reference Weak Reference Soft Reference Phantom Reference JVM Internals and Garbage Collection public class Zoo { public static void main(String[] args) { System.out.println(args[0]); System.out.println(args[1]); } } The program correctly identifies the first two -words” as the arguments. Spaces are used to separate the arguments. If you want spaces inside an argument, you need to use quotes as in this example: $ javac Zoo.java $ java Zoo &quot;San Diego&quot; Zoo All command-line arguments are treated as String objects, even if they represent another data type: $ javac Zoo.java $ java Zoo Zoo 2 Finally, what happens if you don’t pass in enough arguments? $ javac Zoo.java $ java Zoo Zoo Zoo Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 1 at mainmethod.Zoo.main(Zoo.java:7) public class Conflicts { Date date; // some more code } The answer should be easy by now. You can write either import java.util.*; or import java.util.Date;. The tricky cases come about when other imports are present: import java.util.*; import java.sql.*; // DOES NOT COMPILE import java.util.Date; import java.sql.*; If you explicitly import a class name, it takes precedence over any wildcards present. ■ octal (digits 0–7), which uses the number 0 as a prefix—for example, 017 ■ hexadecimal (digits 0–9 and letters A–F), which uses the number 0 followed by x or X as a prefix—for example, 0xFF ■ binary (digits 0–1), which uses the number 0 followed by b or B as a prefix—for example, 0b10 System.out.println(56); // 56 System.out.println(0b11); // 3 System.out.println(017); // 15 System.out.println(0x1F); // 31 added in Java 7. You can have underscores in numbers to make them easier to read: int million1 = 1000000; int million2 = 1_000_000; double notAtStart = _1000.00; // DOES NOT COMPILE double notAtEnd = 1000.00_; // DOES NOT COMPILE double notByDecimal = 1000_.00; // DOES NOT COMPILE double annoyingButLegal = 1_00_0.0_0; // this one compiles Declaring Multiple Variables int i1, i2, i3 = 0; As you should expect, three variables were declared: i1, i2, and i3. However, only one of those values was initialized: i3. The other two remain declared but not yet initialized. int num, String value; // DOES NOT COMPILE This code doesn’t compile because it tries to declare multiple variables of different types in the same statement. double d1, double d2; // DOES NOT COMPILE If you want to declare multiple variables in the same statement, they must share the same type declaration and not repeat it. double d1, d2; would have been legal. boolean b1, b2; String s1 = &quot;1&quot;, s2; double d1, double d2; int i1; int i2; int i3; i4; The first statement is legal. It declares two variables without initializing them. second statement is also legal. It declares two variables and initializes only one of them. The third statement is not legal. Variables d1 and d2 are the same type &amp; breaks between them. The fourth statement is legal.The fifth statement is not legal.The second one is not a valid declaration because it omits the type. Garbage Collection The methods to request JVM to run Garbage Collector System.gc() : ‘System’ class contains a static ‘gc’ method for requesting JVM to run Garbage Collector. Runtime.getRuntime().gc() : gc() method available in Runtime class is an instance method. 1.Nullifying the reference Variable Student s1 = new Student(); Student s2 = new Student(); //No Object eligible for Garbage Collector s1 = null; //One Object eligible for Garbage Collector s2 = null; Both Objects eligible for Garbage Collector 2.Reassigning the reference Variable Student s1 = new Student(); Student s2 = new Student(); s1 = s2; //One Object eligible for Garbage Collector 3.The Objects Created inside a method The objects which are created in a method are by default eligible for Garbage Collector once the method completes 1: public class Scope { 2: public static void main(String[] args) { 3: String one, two; 4: one = new String(&quot;a&quot;); 5: two = new String(&quot;b&quot;); 6: one = two; 7: String three = one; 8: one = null; 9: } } Difference between PATH and Classpath in Java? Answer : PATH is a environment variable in Java which is used to help Java program to compile and run.To set the PATH variable we have to include JDK_HOME/bin directory in PATH environment variable and also we cannot override this variable. On the other hand, ClassPath variable is used by class loader to locate and load compiled Java codes stored in .class file. We you want to run JUnit from any where from cmdline you eed to add Junit.jar in class path. Difference between interpreter and JIT compiler? The interpreter interprets the bytecode line by line and executes it sequentially. It results in poor performance. JIT compiler add optimization to this process by analyzing the code in blocks and then prepare more optimized machine code. Difference between JRE and JVM? JVM is the specification for runtime environment which executes the Java applications. Hotspot JVM is such one implementation of the specification. It loads the class files and uses interpreter and JIT compiler to convert bytecode into machine code and execute it. Difference Between JVM &amp; HotSpot VM JVM : is a Specification, HotSpot : is a implementation of JVM. HotSpot** **is an implementation of the JVM concept, originally developed by Sun and now owned by Oracle. There are other implementations of the JVM specification, like JRockit, IBM J9, among many others. Is Java a pure object oriented language? (answer) Java is not a pure object-oriented programming language e.g. There are many things in Java which are not objects e.g. primitive data types e.g. boolean, char, short, int, long, float, double, different kinds of arithmetic, logical and bitwise operator e.g. +, -. *, /, &amp;&amp;, || etc. Few pure OO languages are Smalltalk and Eiffel. There are seven qualities to be satisfied for a programming language to be pure Object Oriented. They are: 1.Encapsulation/Data Hiding 2.Inheritance 3.Polymorphism 4.Abstraction 5. All predefined types are objects 6. All operations are performed by sending messages to objects 7. All user defined types are objects How does WeakHashMap work? WeakHashMap operates like a normal HashMap but uses WeakReference for keys. Meaning if the key object does not devise any reference then both key/value mapping will become appropriate for garbage collection. How do you locate memory usage from a Java program? Answer: You can use memory related methods from java.lang.Runtime class to get the free memory, total memory and maximum heap memory in Java. public static Runtime getRuntime() returns the instance of Runtime class. public void exit(int status) terminates the current virtual machine. public void addShutdownHook(Thread hook) registers new hook thread. public Process exec(String command) executes given command in a separate process. public int availableProcessors() returns no. of available processors. public long freeMemory() returns amount of free memory in JVM. public long totalMemory() returns amount of total memory in JVM. public class TestApp { public static void main(String[] args) { Runtime r = Runtime.getRuntime(); System.out.println(r.totalMemory()); //16252928 System.out.println(r.freeMemory()); //15709576 System.out.println(r.availableProcessors());//24 r.gc(); } } What is ClassLoader in Java? When a Java program is converted into .class file by Java compiler which is collection of byte code. ClassLoader is responsible to load that class file from file system, network or any other location Bootstrap ClassLoader - JRE/lib/rt.jar Extension ClassLoader - JRE/lib/ext or any directory denoted by java.ext.dirs Application ClassLoader - CLASSPATH environment variable, -classpath or -cp option, Class-Path attribute of Manifest inside **JAR file.** Class Loader in Java BootStrap Extension and Application Java heap memory When a Java program started Java Virtual Machine gets some memory from Operating System. whenever we create an object using new operator or by any another means the object is allocated memory from Heap and When object dies or garbage collected, memory goes back to Heap space. How to increase heap size in Java Default size of Heap space in Java is 128MB on most of 32 bit Sun’s JVM but its highly varies from JVM to JVM. change size of heap space by using JVM options -Xms and -Xmx. Xms denotes starting size of Heap while -Xmx denotes maximum size of Heap in Java. Java Heap and Garbage Collection As we know objects are created inside heap memory and Garbage Collection is a process which removes dead objects from Java Heap space and returns memory back to Heap in Java. For the sake of Garbage collection Heap is divided into three main regions named as New Generation, Old Generation, and Perm space Screen Clipping New Generation of Java Heap is part of Java Heap memory where a newly created object is stored, Old Generation During the course of application many objects created and died but those remain live they got moved to Old Generation by Java Garbage collector thread Perm space of Java Heap is where JVM stores Metadata about classes and methods, String pool and Class level details. Perm Gen stands for permanent generation which holds the meta-data information about the classes. Suppose if you create a class name A, it’s instance variable will be stored in heap memory and class A along with static classloaders will be stored in permanent generation. Garbage collectors will find it difficult to clear or free the memory space stored in permanent generation memory. Hence it is always recommended to keep the permgen memory settings to the advisable limit. JAVA8 has introduced the concept called meta-space generation, hence permgen is no longer needed when you use jdk 1.8 versions. Eden Space – New Objects are Created Survivor Space – Once Eden space is full, Minor thread try to clear the Space, the objects which are survived by GC will be placed in Survivor space. Old Gen – Objects which are survived from a long time, let say 16 Cycles (GC cycle Threshold) of Minor Garbage Collector, those objects moved to Old Gen. The Old Gen space finally collected by Main Garbage collector. Finally, Minor Garbage collector will runs only on Young Gen, Main Garbage Collector will run on whole heap space Does Garbage collection occur in permanent generation space in JVM? YES, Garbage Collection occur in PermGen space as well. and if PermGen space is full or cross a threshold, it can trigger Full GC(Main Thread). If you look at output of GC you will find that PermGen space is also garbage collected. This is why correct sizing of PermGen space is important to avoid frequent full GC. You can control size of PermGen space by JVM options -XX:PermGenSize and -XX:MaxPermGenSize. Types of Garbage Collectors When an object is no longer used, the garbage collector reclaims the underlying memory and reuses it for future object allocation. This means there is no explicit deletion and no memory is given back to the operating system. Java has four types of garbage collectors, Serial Garbage Collector Parallel Garbage Collector CMS Garbage Collector G1 Garbage Collector Each of these four types has its own advantages and disadvantages. Most importantly, we the programmers can choose the type of garbage collector to be used by the JVM. We can choose them by passing the choice as JVM argument 1. Serial Garbage Collector It is designed for the single-threaded environments. It uses just a single thread for garbage collection. It freezes(stops) all the application threads while performing garbage collection. it may not be suitable for a server environment. It is best suited for simple command-line programs. Turn on the **-XX:+UseSerialGC **JVM argument to use the serial garbage collector. 2. Parallel Garbage Collector It is the default garbage collector of the JVM. It uses multiple threads for garbage collection. Similar to serial garbage collector this also freezes(siops) all the application threads while performing garbage collection. 3. Concurrent Garbage Collector Concurrent Mark Sweep (CMS) garbage collector uses multiple threads to scan the heap memory to mark instances for eviction and then sweep the marked instances. It runs along with our Application. Uses multiple cores(cpus) to run multiple GC’s concurrently. Here your application won’t pass/stop Turn on the XX:+USeParNewGC JVM argument to use the CMS garbage collector. 4. G1 Garbage Collector G1 garbage collector is used for large heap memory areas. It separates the heap memory into regions and does collection within them in parallel. G1 also does compacts the free heap space on the go just after reclaiming the memory. G1 collector prioritizes the region based on most garbage first. Turn on the –XX:+UseG1GC JVM argument to use the G1 garbage collector. https://www.youtube.com/watch?v=UnaNQgzw4zY Java 8 Improvement Turn on the -XX:+UseStringDeduplication **JVM argument while using G1 garbage collector. This optimizes the heap memory by removing duplicate String values to a single char[] array**. This option is introduced in Java 8 u 20. Given all the above four types of Java garbage collectors, which one to use depends on the application scenario, hardware available and the throughput requirements. Garbage Collection JVM Options Type of Garbage Collector to run Option Description -XX:+UseSerialGC Serial Garbage Collector -XX:+UseParallelGC Parallel Garbage Collector -XX:+UseConcMarkSweepGC CMS Garbage Collector -XX:ParallelCMSThreads= CMS Collector – number of threads to use -XX:+UseG1GC G1 Gargbage Collector GC Optimization Options Option Description -Xms Initial heap memory size -Xmx Maximum heap memory size -Xmn Size of Young Generation -XX:PermSize Initial Permanent Generation size -XX:MaxPermSize Maximum Permanent Generation size Garbage collection is performed by a daemon thread called Garbage Collector(GC). This thread calls the finalize() method before object is garbage collected. The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing (destroying remaining objects). Neither finalization nor garbage collection is guaranteed. How String Literals Garbage Collected? Strings created without using the new keyword are NEVER garbage collected. Even if there are no references to them. All such strings go into the String pool and just sit there till the whole program ends (ie. the JVM).The String Const. pool cleaned up when the class is unloaded by the JVM. How to you monitor garbage collection activities? just to check whether candidate has ever monitored GC activities or not. You can monitor garbage collection activities either offline or real-time. You can use tools like JConsole and VisualVM VM with its Visual GC plug-in to monitor real time garbage collection activities and memory status of JVM or you can redirect Garbage collection output to a log file for offline analysis by using -XlogGC=&lt;PATH&gt; JVM parameter. Anyway you should always enable GC options like -XX:PrintGCDetails -X:verboseGCand -XX:PrintGCTimeStamps as it doesn’t impact application performance much but provide useful states for performance monitoring. How do you identify minor and major garbage collection in Java? Minor collection prints GC if garbage collection logging is enable using –verbose:gc or -XX:PrintGCDetails Major collection prints -Full GC”. How to Generate GC Log File? In order to understand the GC log, you first need to generate one. Passing the following system properties to your JVM would generate GC logs -XX:+PrintGCDetails -XX:+PrintGCDateStamps –Xloggc:D://gc.log Or add visual-gc plugin to visualVM What Security model used by Java? Sandbox. The sandbox security model makes it easier to work with software that comes from sources you don’t fully trust. What is -Phontom” memory A memory that doesn’t exist in reality. A phantom reference lets you do final touch up closing on an object, even after it has been declared dead — no longer referenced by any live object. During garbage collection, these reference objects are handled specially; that is, the referent field is not traced during the marking phase. When marking is complete, the references are processed in sequence for sweeping phase. Soft Weak Final Phantom How many JVMs can run on a single machine? Multiple, yes You can run as many JVMs as you can fit on your disk and in memory :) Whenever you start a Java application, you’re first starting the JVM and then telling it which application to run. The answer to “which JVM” is simply: The JVM that you loaded the application with! for example, for execution of applets a separate JVM may exist and another JVM can be started by the User for execution of Java Byte Code, on a single machine. Difference between Object Oriented and Object Based language Object Oriented Languages Object Oriented Languages supports all the features of Oops Abstraction, Encapsulation, Polymorhisum, Inhertance. C#, Java, VB. Net are the examples of object oriented languages. Object Based Languages Object based languages does not support inheritance or, polymorphism or, both. Object based languages does not support built-in objects. Javascript, VB are the examples of object bases languages. If I don’t provide any arguments on commandline, then String array of main() is Empty or NULL? It’s Empty, but not Null. Is main method compulsory in Java? The answer to this question depends on version of java you are using. Prior to JDK 5, main method was not mandatory in a java program. You could write your full code under static block and it ran normally. The static block is first executed as soon as the class is loaded before the main(); Read more: https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html#ixzz5fwmNzRHE Read more: https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html#ixzz5fwm9nzDa Data Types How do you convert bytes to String? you can convert bytes to the string using string constructor which accepts byte[], just make sure that right character encoding otherwise platform’s default character encoding will be used which may or may not be same. String str = new String(bytes, &quot;UTF-8&quot;); How do you convert bytes to long in Java The byte takes 1 byte of memory and long takes 8 bytes of memory. Assignment 1 byte value to 8 bytes is done implicitly by the JVM. byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double The left-side value can be assigned to any right-side value and is done implicitly. The reverse requires explicit casting. byte b1 = 10; // 1 byte long l1 = b1; // one byte to 8 bytes, assigned implicitly Is ++ operator is thread-safe in Java? No it’s not a thread safe operator because its involve multiple instructions like reading a value, incriminating it and storing it back into memory which can be overlapped between multiple threads. Volatile Vs Atomic variables? Volatile Example If writerThread() is executed by one thread &amp; readerThread() is executed by another thread the ‘x’ value is different for two threads because they are reading value from their LocalCache. Here the changes of X value is not visible globally (Field Visibility), because they are changing in LocalCache. To avoid this, we need to use ‘volatile’ keyword for fields. The Java volatile keyword is used to mark a Java variable as “being stored in main memory”. that means, every read of a volatile variable will be read from the main memory(Shared Memory), and not from the CPU cache every write to a volatile variable will be written to main memory, and not just to the CPU cache. In the above diagram two threads t1, t2 are trying to change the value of flag. If Thread1 changes value flag=false, then it will flush(push) the changes from LocalCache to SharedCache and it will refresh the all Thread LocalCaches with updated value. If Thread 2 is trying to read, it will get updated value. Volatile solves the visibility problem, where Only one operation is perform Amtomic Problem Atomic - forming a single irreducible unit or component in a larger system. Increment (++) is an Compound Operation(multiple). AtomicVaribles makes compound operations as Atomic(Single) We can solve this problem using Synchronization Another Way using Atomic Variables Atomic Varibles The java.util.concurrent.atomic package defines classes that support atomic operations on single variables. All classes have get and set methods that work like reads and writes on volatile variables. We have following Atomic classes AtomicInteger AtomicLong AtomicBoolean AtomicReference AtomicIntegerArray AtomicLongArray AtomicReferenceArray Common methods incrementAndGet(): Atomically increments by one the current value. decrementAndGet(): Atomically decrements by one the current value. addAndGet(int delta): Atomically adds the given value to the current value. compareAndSet(int expect, int update): Atomically sets the value to the given updated value if the current value == the expected value. getAndAdd(int delta): Atomically adds the given value to the current value. set(int newValue): Sets to the given value. What will this return 3*0.1 == 0.3? true or false? Both are not equal, because floating point arithmetic has a certain precision. Check the difference (a-b) it should be really small. In computer memory, floats and doubles are stored using IEEE 754 standard format. f1 = (0.1+0.1+0.1….11 times) = 1.0999999999999999 f2 = 0.1*11 = 1.1 In BigDecimal class, you can specify the rounding mode and exact precision which you want to use. Using the exact precision limit, rounding errors are mostly solved. Best part is that BigDecimal numbers are immutable i.e. if you create a BigDecimal BD with value -1.23”, that object will remain -1.23” and can never be changed. You can use it’s .compareTo() method to compare to BigDecimal numbers private static void testBdEquality() { BigDecimal a = new BigDecimal(&quot;2.00&quot;); BigDecimal b = new BigDecimal(&quot;2.0&quot;); System.out.println(a.equals(b)); // false System.out.println(a.compareTo(b) == 0); // true } Which one will take more memory, an int or Integer? (answer) An Integer object will take more memory. an Integer is the an object and it store meta data overhead about the object and int is primitive type so its takes less space. Autoboxing and Unboxing? If a method(remember only method – not direct) requires Integer Object value, we can directly pass primitive value without issue. Autoboxing will take care about these. We can also do direct initializations (1.8 V) Integer i = 10;// it will create Integer value of 10 using Autoboxing int j = i;// ;// it will convert Integer to int using Autoboxing Previously it shows Integer i = 10;// it will create Integer value of 10 using Autoboxing int j = i;//But we cant assign int to Integer Type mismatch: cannot convert from Integer to int How to convert Primitives to Wrapper &amp; Wrapper to Primitive ?? // 1. using constructor Integer i =new Integer(10); // 2. using static factory method Integer i = Integer.valueOf(10); //3.wrapper to primitive int val = i.intValue(); How does Autoboxing of Integer works in Java? (answer) Compiler uses valueOf() method to convert primitive to Object uses intValue(), doubleValue() etc to get primitive value from Object. what if I make main() private/protected ? if you do not make main() method public, there is no compilation error. You will runtime error because matching main() method is not present. Remember that whole syntax should match to execute main() method. Error: Main method not found in class Main, please define the main method as: public static void main(String[] args) What is blank final variable? A blank final variable in Java is a final variable that is not initialized during declaration. Below is a simple example of blank final. // A simple blank final example final int i; Value must be assigned in constructor/Static(static final) /Instance block before using it. If we have more than one constructors or overloaded constructor in class, then blank final variable must be initialized in all of them. Difference between java.util.Date &amp; java.sql.Date? java.util.Date represent both Date and Time information. java.sql.Date just represent DATE without time information. java.sql.Time and java.sql.TimeStamp which represents TIME and TIMESTAMP type of SQL database is more close to java.util.Date. java.util.Date is Super class of java.sql.Date Why Java does not support Operator Overloading? The meaning of an operator is always same for variable of basic types like: int, float, double etc. For example: To add two integers, + operator is used. However, for user-defined types (like: objects), you can redefine the way operator works. For example: If there are two objects of a class that contains string as its data members. You can redefine the meaning of + operator and use it to concatenate those strings. To overload an operator, a special operator function is defined inside the class as class className { ... .. ... public returnType operator symbol (arguments) { ... .. ... } ... .. ... }; #include &lt;iostream&gt; using namespace std; class Test { private: int count; public: Test(): count(5){} void operator ++() { count = count+1; } void Display() { cout&lt;&lt;&quot;Count: &quot;&lt;&lt;count; } }; int main() { Test t; // this calls &quot;function void operator ++()&quot; function ++t; t.Display(); return 0; } This function is called when ++ operator operates on the object of Test class (object t in this case). In the program, void operator ++ () operator function is defined (inside Test class). This function increments the value of count by 1 for t object. Why Java Doesn’t Support it? 1.Java is Simple, No Confusions Please!! Java does not support operator overloading: Java is relatively a very simple language to use compared C/C++ with the non-support of complex and confusing features like pointers, multiple inheritance and operator overloading. These features are rarely used in practice and at the same time poorly understood by the language beginners. 2.JVM Performance: How many things Should i do? Form JVM perspective supporting operator overloading is more difficult and if the same thing can be achieved by using method overloading in more intuitive and clean way it does make sense to not support operator overloading in java. a complex JVM will result in slower JVM Can you store String in an Integer array in Java? compile time error or runtime exception? [answer] You cannot store an String in an array of primitive int, it will result in compile time error as shown below, but if you create an array of Object and assign String[] to it and then try to store Integer object on it. Compiler won’t be able to detect that and it will throw ArrayStoreExcpetion at runtime int[] primes = new int[10]; primes[0] = &quot;a&quot;; // compile time error Object[] names = new String[3]; names[0] = new Integer(0);// ArrayStoreException at runtime What is difference between ArrayIndexOutfOBounds and ArrayStoreException? [answer] ArrayIndexOutOfBoundsException comes when your code tries to access an invalid index for a given array e.g. negative index or higher index than length - 1. ArrayStoreException comes when you have stored an element of type other than type of array, as shown in above example. Is it legal to initialize an array int i[] = {1, 2, 3, 4, 5}; [answer] Yes, it’s perfectly legal. You can create and initialize array in same line in Java. Where does array stored in memory? [answer] Array is created in heap space of JVM memory. Since array is object in Java, even if you create array locally inside a method or block, object is always allocated memory from heap. Array concept interview questions and answers in Java Reverse Array using Iterative and Recursive approaches Steps to Solve this 1.initialize array 2.Choose start index 3.Choose end index 4.Swap the elements using temp variable package array; public class ReverseArry { /* * Recursive approach: In recursive approach the function calls itself until * the condition is met. And it is slower than iteration, which means it uses * more memory than iteration. recursion is like a selection structure, and * which makes code smaller and clean. And a function partially defined by * itself. Here tracing the code will be more difficult in the case large * programs */ public static int[] recursiveArry(int a[], int start, int end) { if (start &lt;= end) { int temp; temp = a[start]; a[start] = a[end]; a[end] = temp; recursiveArry(a, start + 1, end - 1);//calling it again } return a; } /* *Iterative approach: Iterative approach is a repetition process until the condition fails.here loops are used such as for, while etc. Here code may be longer but it is faster than recursive. And it consumes less memory compared to recursive approach.If the loop condition is always true in such cases it will be an infinite loop. */ public static int[] iteravtiveArray(int a[], int start, int end) { while(start&lt;end) { int temp; temp = a[start]; a[start]=a[end]; a[end]=temp; start++; end--; } return a; } static void printArray(int arr[], int size) { int i; for (i = 0; i &lt; size; i++) System.out.print(arr[i] + &quot; &quot;); System.out.println(&quot;&quot;); } public static void main(String[] args) { // 1. Initialize array int arr[] = { 1, 2, 3, 4, 5, 6 }; System.out.println(&quot;Input array is &quot;); printArray(arr, 6); // 2. Choose Starting &amp; ending point int b[] = recursiveArry(arr, 0, 5); System.out.println(&quot;Recursive -Reversed array is &quot;); printArray(b, 6); int c[] = iteravtiveArray(arr, 0, 5); System.out.println(&quot;IteravtiveArray -Reversed array is &quot;); printArray(c, 6); } } Input array is 1 2 3 4 5 6 Recursive -Reversed array is 6 5 4 3 2 1 How do you reverse an array in Java? org.apache.commons.lang.ArrayUtils class to reverse Array in Java. As discussed in our last post How to print array element in Java, We are using Arrays.toString() to print content of array. int[] iArray = new int[] {101,102,103,104,105}; String[] sArray = new String[] {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;}; //reverse int array using Apache commons ArrayUtils.reverse() method System.out.println(&quot;Original int array : &quot; + Arrays.toString(iArray)); ArrayUtils.reverse(iArray); java.lang Package We have mainly five classes in java.lang. Which are most commonly used in any java program Object String StringBuffer StringBuilder Wrapper Classes (AutoBoxing / AutoUnboxing) Object Class The most common general methods which can be applicable on any java object are defined in object class. Object class is the parent class of any java class, whether it is predefined or programmer defined, hence all the object class methods are by default available to any java class. Object class define the following 11 methods 1.toString():Returns a string representation of the object. public String toString() { return getClass.getName() + &#39;@&#39; + Integer.toHexString(HashCode); } 2.hashCode():returns the integer representation of memory location which used by JVM while saving/adding Objects into Hashsets, Hashtables or Hashmap 3.equals(Object): Compares two Objects for equality. 4.clone(): Creates a new object of the same class as this object which implements Clonable interface. Test t1 = new Test(); Test t2 = (Test)t1.clone(); 5.finalize():Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. 6.getClass():Returns the runtime class of an obj.getClass(), or the class-literal (Foo.class) return a Class object, which contains some metadata about the class: name package methods fields constructors annotations we can create Class object by following ways Class c = Class.forName(-StudentBO&quot;) Class c = StudentBO.class Class c = a.getClass(); public static void main(String[] args) throws Exception { TestApp a = new TestApp(); Class c1 = a.getClass(); Class c = Class.forName(&quot;java.lang.String&quot;); System.out.print(&quot;Class represented by c : &quot; + c.toString()); Object obj = c.newInstance(); } 7.wait():Waits to be notified by another thread of a change in this object. 8.wait(long):Waits to be notified by another thread of a change in this object. 9.wait(long, int):Waits to be notified by another thread of a change in this object. 10.notify():Wakes up a single thread that is waiting on this object’s monitor. 11.notifyAll():Wakes up all threads that are waiting on this object’s monitor. equals(Object otherObject) – As method name suggests, is used to simply verify the equality of two objects. It’s default implementation simply check the object references of two objects to verify their equality. By default, two objects are equal if and only if they are stored in the same memory address. hashcode() – Returns a unique integer value for the object in runtime. By default, integer value is mostly derived from memory address of the object in heap (but it’s not mandatory always). If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. Whenever we override the equals() method, we should override hashcode() method In String class(not StringBuilder, StringBuffer) &amp; All Wrapper classes equals() method is overridden for Content Comparison Compare two employee Objects based on Their Id? public class Employe { int id; String name; //Setters &amp; Getters @Override public boolean equals(Object obj) { Employe e = (Employe) obj; boolean flag = false; if (this.getId() == e.getId()) { flag = true; } return flag; } public static void main(String[] args) { Employe e1 = new Employe(); Employe e2 = new Employe(); e1.setId(101); e2.setId(101); System.out.println(e1.equals(e2));//true System.out.println(e1.hashCode()); //366712642 System.out.println(e2.hashCode()); //1829164700 – here different } } So are we done? If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. But here it is not!! Not yet. Lets test again above modified Employee class in different way. public static void main(String[] args) { Employe e1 = new Employe(); Employe e2 = new Employe(); e1.setId(101); e2.setId(101); Set&lt;Employe&gt; set = new HashSet&lt;&gt;(); set.add(e1); set.add(e2); System.out.println(set); //[basic.Employe@15db9742, basic.Employe@6d06d69c] } Above class prints two objects in the second print statement. If both employee objects have been equal, in a Set which stores only unique objects, there must be only one instance inside HashSet We are missing the second important method hashCode(). As java docs say, if you override equals()method then you must override hashCode() method public class Employe { int id; String name; @Override public boolean equals(Object obj) { Employe e = (Employe) obj; boolean flag = false; if (this.getId() == e.getId()) { flag = true; } return flag; } @Override public int hashCode() { return getId(); } public static void main(String[] args) { Employe e1 = new Employe(); Employe e2 = new Employe(); e1.setId(101); e2.setId(101); Set&lt;Employe&gt; set = new HashSet&lt;&gt;(); set.add(e1); set.add(e2); System.out.println(set); //[basic.Employe@65] } } Apache commons provide two excellent utility classes EqualsBuilder &amp; HashCodeBuilder for generating hash code and equals methods. Can a top-level class be private or protected? Top level classes in java can’t be private or protected, but inner classes in java can. The reason for not making a top-level class as private is very obvious, because nobody can see a private class and thus they cannot use it What Happens if we compile Empty java file? Compiles but Runtime Error. Is it possible to make array volatile in Java? Yes, you can make an array (both primitive and reference type array e.g. an int array and String array) volatile in Java, but only changes to reference pointing to an array will be visible to all threads, not the whole array. What this means is that suppose you have a reference variable called primes as shown below: protected volatile int[] primes = new int[10]; then if you assign a new array to primes variable, change will be visible to all threads, but changes to individual indices(a[0], a[1]…a[n]) will not be covered under volatile guarantee i.e. primes = new int[20]; It will follow the “happens-before” rule(Happens-before relationship is a guarantee that action performed by one thread is visible to another action in different thread.) and cause memory refresh, but following code will not do so if multiple threads are changing individual array elements e.g. storing updates, there won’t be any happens-before guarantee provided by the volatile modifier for such modification primes[0] = 10; primes[1] = 20; primes[2] = 30; primes[3] = 40; So, if your use-case is to provide memory visibility guarantee for individual array elements than volatile is not the right choice. You must rely on other synchronization and a thread-safety mechanism to cover this case e.g. synchronized** keyword, atomic variables, or ReentrantLock.** Is it possible to make ArrayList, Hashset volatile in Java? On a similar note, sometimes instead of an array, Interviewer put the collection i.e. they will ask can you make a collection variable volatile in Java or not e.g. an ArrayList or HashMap. The answer is same, of course, you can make a reference variable pointing to a Collection volatile in Java, but the happens-before guarantee will only be provided if the value of that reference variable is changed e.g. you assign a new collection to it. Any modification done on actual collection object e.g. adding or removing elements from ArrayList will not invoke happens-before guarantee or memory barrier refresh. What is a.hashCode() used for? How is it related to a.equals(b)? According to the Java specification, two objects which are identical to each other using equals() method needs to have the same hash code What is a compile time constant in Java? What is the risk of using it? Answer: Public static final variables are also known as the compile time constant, the public is optional there. They are substituted with actual values at compile time because compiler recognizes their value up-front, and also recognize that it cannot be altered during runtime. One of the issues is that if you choose to use a public static final variable from in-house or a third party library, and their value changed later, then your client will still be using the old value even after you deploy a new version of JARs. Explain Liskov Substitution Principle. According to the Liskov Substitution Principle, Subtypes must be appropriate for super type i.e. methods or functions which use super class type must be able to work with object of subclass without issues. Co-Variant return types are implemented based on this principle. What is double checked locking in Singleton? Singleton means we can create only one instance of that class Rules: Create Singleton class Object make it as PRIVATE Create PRIVATE constructor Every Singleton class contains at least one factory method class Student { private static Student st; private Student() { System.out.println(&quot;OBJECET Created FIRST TIME&quot;); } public static Student getObject() { if (st == null) { st = new Student(); } else { System.out.println(&quot;OBJECET ALREDAY CREATED&quot;); } return st; } } public class Singleton { public static void main(String[] args) { Student s1 = Student.getObject(); Student s2 = Student.getObject(); System.out.println(s1.hashCode());//7855445 System.out.println(s2.hashCode());//7855445 } } Double checked locking in Singleton means, at any cost only one instance is created in multi-threaded environment. In this case at null checking make Block as Synchronized. public static Singleton getInstanceDC() { if (_instance == null) { // Single Checked synchronized (Singleton.class) { if (_instance == null) { // Double checked _instance = new Singleton(); } } } return _instance; } When to use volatile variable in Java? Volatile keyword is used with only variable in Java it guarantees that value of volatile variable will always be read from main memory and not from Thread’s local cache. So, we can use volatile to achieve synchronization because its guaranteed that all reader thread will see updated value of volatile variable once write operation completed Difference between Serializable and Externalizable in Java? Serialization is a default process of serializing or persisting any object’s state in Java. It’s triggered by implementing Serializable interface which is a marker interface (an interface without any method). uses default implementation to handle the object serialization process. Externalizable is used to user defined serialization process and control default serialization process which is implemented by application. Externalizable interface extends Serializable interface. It consists of two methods // to read object from stream void readExternal(ObjectInput in) // to write object into stream void writeExternal(ObjectOutput out) Difference between static and dynamic binding in Java? (detailed answer) This is usually asked as follow-up of previous question, static binding is related to overloaded method and dynamic binding is related to overridden method. Method like private, final and static are resolved using static binding at compile time but virtual methods which can be overridden are resolved using dynamic binding at runtime. Which design pattern have you used in your production code? Dependency injection Factory pattern Adapter Design pattern Singleton Decoratordesign pattern is used to modify the functionality of an object at runtime. Can you explain Liskov Substitution principle?(Comes under inheritance ) According to Liskov Substitution Principle, Subtypes must be substitutable for supertype i.e. methods or functions which uses superclass type must be able to work with the object of subclass without any issue How to create an instance of any class without using new keyword ***************************************** 1.Using newInstance method of Class class ***************************************** Class c = Class.forName(&quot;StudentBo&quot;); StudentBo bo = (StudentBo) c.newInstance(); ***************************************** 2.Using clone() of java.lang.Object ***************************************** NewClass obj = new NewClass(); NewClass obj2 = (NewClass) obj.clone(); How can we invoke any external process in java? Using, Runtime.getRuntime().exec(…) Static imports rules ? The static import feature of Java 5 facilitates the java programmer to access any static member of a class directly. There is no need to qualify it by the class name. import static java.lang.System.*; (or) import static java.lang.System.out; class StaticImportExample{ public static void main(String args[]){ out.println(&quot;Hello&quot;);//Now no need of System.out out.println(&quot;Java&quot;); } } Ambiguity in static import // both have MAX_VALUE as static import static java.lang.Integer.*; import static java.lang.Byte.*; class Geeks { public static void main(String[] args) { out.println(MAX_VALUE); } } Error:Reference to MAX_VALUE is ambigious Java OOPs Concepts Can we prevent overriding a method without using the final modifier? (answer) Yes, you can prevent the method overriding in Java without using the final modifier. In fact, there are several ways to accomplish it e.g. you can mark the method private or static, those cannot be overridden. Can we override a private method in Java? (answer) No, you cannot. Since the private method is only accessible and visible inside the class they are declared, it’s not possible to override them in subclasses. But we can re-decalre in sub class , it will trated as a new method, bcoz parent class private method is not visible to subclass. class A{ private void show() { System.out.println(&quot;Parent&quot;); } } public class Demo extends A{ private void show() { System.out.println(&quot;Child&quot;); } public static void main(String[] args) { A a = new Demo(); a.show(); } } Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: The method show() from the type A is not visible at Demo.main(Demo.java:12) Though, you can override them inside the inner class as they are accessible there. Can we change the return type of method to subclass while overriding? (answer) Yes, you can, but only from Java 5 onward. This feature is known as covariant method overriding and it was introduced in JDK 5 release. This is immensely helpful if original method return super-class e.g. clone() method return java.lang.Object. By using this, you can directly return the actual type, preventing client-side type casting of the result. Can we make a class both final and abstract at the same time? (answer) No, you cannot apply both final and abstract keyword at the class same time because they are exactly opposite of each other. A final class in Java cannot be extended and you cannot use an abstract class without extending and make it a concrete class. As per Java specification, the compiler will throw an error if you try to make a class abstract and final at the same time. Can we overload or override the main method in Java? (answer) No, since main() is a static method, you can only overload it, you cannot override it because the static method is resolved at compile time without needing object information hence we cannot override the main method in Java. Design Patterns SOLID design principles and GOF design patterns which take advantage of OOPS concept discussed here. What are SOLID Design principles Image result for solid design principles 1. Single Responsibility Principle -One class should have one and only one responsibility” In other words, we should write, change and maintain a class for only one purpose. If it is model class then it should strictly represent only one actor/ entity. This will give we the flexibility to make changes in future without worrying the impacts of changes for another entity. 2. Open Closed Principle -Software components should be open for extension, but closed for modification” If we take a look into any good framework like struts or spring, we will see that we cannot change their core logic and request processing, but we modify the desired application flow just by extending some classes and plugin them in configuration files. For example, spring framework has class DispatcherServlet. This class acts as front controller for String based web applications. To use this class, we are not required to modify this class. All we need is to pass initialization parameters and we can extend it’s functionality the way we want. 3. Liskov’s Substitution Principle -Derived types must be completely substitutable for their base types” 4. Interface Segregation/Separation Principle This principle is my favorite one. It is applicable to interfaces as single responsibility principle holds to classes. ISP says: -Clients should not be forced to implement unnecessary methods which they will not use” Take an example. Developer Alex created an interface Reportable and added two methods generateExcel() and generatedPdf(). Now client ‘A’ wants to use this interface but he intend to use reports only in PDF format and not in excel. Will he be able to use the functionality easily? NO. He will have to implement both the methods, out of which one is extra burden put on him by designer of software. Either he will implement another method or leave it blank. This is not a good design. 5. Dependency Inversion/Injection Principle Remove dependency from classes In spring framework, all modules are provided as separate components which can work together by simply injected dependencies in other module. This dependency is managed externally in XML files. What are GOF(Gang of Four) design patterns? Image result for gof design patterns 1. Creational Design Patterns (Object Creation) Creational patterns often used in place of direct instantiation with constructors. They make the creation process more adaptable and dynamic. In particular, they can provide a great deal of flexibility about which objects are created, how those objects are created, and how they are initialized. DESIGN PATTERN NAME PURPOSE Builder Builder design pattern is an alternative way to construct complex objects and should be used only when we want to build different types of immutable objects using same object building process. Prototype Prototype design pattern is used in scenarios where application needs to create a large number of instances of a class, which have almost same state or differ very little. Factory Factory design pattern is most suitable when complex object creation steps are involved. To ensure that these steps are centralized and not exposed to composing classes. Abstract factory Abstract factory pattern is used whenever we need another level of abstraction over a group of factories created using factory pattern. Singleton Singleton enables an application to have one and only one instance of a class per JVM. 2. Structural Design Patterns Structural design patterns show us how to glue different pieces of a system together in a flexible and extensible fashion. These patterns help us guarantee that when one of the parts changes, the entire application structure does not need to change. DESIGN PATTERN NAME PURPOSE Adapter An adapter convert the interface of a class into another interface clients expect. It lets classes work together that couldn’t otherwise because of incompatible interfaces. Bridge Bridge design pattern is used to decouple a class into two parts – abstraction and it’s implementation – so that both can evolve in future without affecting each other. It increases the loose coupling between class abstraction and it’s implementation. Composite Composite design pattern helps to compose the objects into tree structures to represent whole-part hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly. Decorator Decorator design pattern is used to add additional features or behaviors to a particular instance of a class, while not modifying the other instances of same class. Facade Facade design pattern provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use. Flyweight Flyweight design pattern enables use sharing of objects to support large numbers of fine-grained objects efficiently. A flyweight is a shared object that can be used in multiple contexts simultaneously. The flyweight acts as an independent object in each context. Proxy In proxy design pattern, a proxy object provide a surrogate or placeholder for another object to control access to it. Proxy is heavily used to implement lazy loading related usecases where we do not want to create full object until it is actually needed. 3. Behavioral Design Patterns Behavioral patterns abstract an action we want to take on the object or class that takes the action. By changing the object or class, we can change the algorithm used, the objects affected, or the behavior, while still retaining the same basic interface for client classes. DESIGN PATTERN NAME PURPOSE Chain of responsibility Chain of responsibility design pattern gives more than one object an opportunity to handle a request by linking receiving objects together in form of a chain. Command Command design pattern is useful to abstract the business logic into discrete actions which we call commands. These command objects help in loose coupling between two classes where one class (invoker) shall call a method on other class (receiver) to perform a business operation. Interpreter Interpreter pattern specifies how to evaluate sentences in a language, programatically. It helps in building a grammar for a simple language, so that sentences in the language can be interpreted. Iterator Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. Mediator Mediator pattern defines an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets us vary their interaction independently. Memento Memento pattern is used to restore state of an object to a previous state. It is also known as snapshot pattern. Observer Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It is also referred to as the publish-subscribe pattern. State In state pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class. There shall be a separate concrete class per possible state of an object. Strategy Strategy pattern is used where we choose a specific implementation of algorithm or task in run time – out of multiple other implementations for same task. Template method Template method pattern defines the sequential steps to execute a multi-step algorithm and optionally can provide a default implementation as well (based on requirements). Visitor Visitor pattern is used when we want a hierarchy of objects to modify their behavior but without modifying their source code. What is Strategy pattern in Java? Strategy pattern allows you to introduce new strategy without changing the code. For example, the Collections.sort() method which sorts the list of the object uses the Strategy pattern to compare object. Since every object uses different comparison strategy you can compare various object differently without changing sort method. What is Decorator Design Pattern? Decorator pattern provides new features without modifying the original class. Inheritance is the example. What is the difference between Decorator, Proxy and Adapter pattern in Java? (answer) Again they look similar because their structure or class diagram is very similar but their intent is quite different. Decorator adds additional functionality without touching the class, Proxy provides access control and Adapter is used to make two incompatible interfaces work together. What is a strongly typed programming language? In a strongly typed language compiler ensure type correctness, for example, you can not store the number in String or vice-versa. Java is a strongly typed language, that’s why you have different data types Ex int, float, String, char, boolean etc. On the other hand, weakly typed language don’t enforce type checking at compile time and they tree values based upon context. Python and Perl are two popular example of weakly typed programming language, where you can store a numeric string in number type. Can you describe three different kinds of testing that might be performed? Unit Testing, Integration Testing and Smoke Testing. Unit testing is used to test individual units to verify whether they are working as expected Integration Testing is done to verify whether individually tested module can work together or not Smoke Testing is a way to test whether most common functionality of software is working properly or not e.g. in a flight booking website, you should be able to book, cancel or change flights. What is the difference between iteration and recursion? (detailed answer) Iteration uses a loop to perform the same step again and again. Recursion calls the same method itself to do the repetitive task What is test-driven development? Test driven is one of the popular development methodologies in which tests are written before writing any function code. In fact, test drives the structure of your program. Purists never wrote a single line of application code without writing a test for that. It greatly improve code quality and often attributed as a quality of rockstar developers. How do you find a running Java process on UNIX? You can use the combination of ‘ps’ and ‘grep’ command to find any process running on UNIX machine. ps -e will list every process i.e. process from all user not just you and ps -f will give you full details including PID, which will be required if you want to investigate more or would like to kill this process using kill command. ps -ef grep “java” Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Garbage Collection? there are four kind of reference in Java : Strong reference Weak Reference Soft Reference Phantom Reference" />
<meta property="og:site_name" content="SatyaCodes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-11T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Java - Interview Questions PART-1" />
<script type="application/ld+json">
{"datePublished":"2017-11-11T00:00:00+00:00","dateModified":"2017-11-11T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/Java-Interview-Questions-1.html"},"author":{"@type":"Person","name":"Satya Kaveti"},"@type":"BlogPosting","description":"Basics What is a strongly typed programming language? In a strongly typed language compiler ensure type correctness, for example, you can not store the number in String or vice-versa. Java is a strongly typed language, that’s why you have different data types Ex int, float, String, char, boolean etc. On the other hand, weakly typed language don’t enforce type checking at compile time and they tree values based upon context. Python and Perl are two popular example of weakly typed programming language, where you can store a numeric string in number type. Can you describe three different kinds of testing that might be performed? Unit Testing, Integration Testing and Smoke Testing. Unit testing is used to test individual units to verify whether they are working as expected Integration Testing is done to verify whether individually tested module can work together or not Smoke Testing is a way to test whether most common functionality of software is working properly or not e.g. in a flight booking website, you should be able to book, cancel or change flights. What is the difference between iteration and recursion? (detailed answer) Iteration uses a loop to perform the same step again and again. Recursion calls the same method itself to do the repetitive task What is test-driven development? Test driven is one of the popular development methodologies in which tests are written before writing any function code. In fact, test drives the structure of your program. Purists never wrote a single line of application code without writing a test for that. It greatly improve code quality and often attributed as a quality of rockstar developers. How do you find a running Java process on UNIX? You can use the combination of ‘ps’ and ‘grep’ command to find any process running on UNIX machine. ps -e will list every process i.e. process from all user not just you and ps -f will give you full details including PID, which will be required if you want to investigate more or would like to kill this process using kill command. ps -ef grep “java” Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Garbage Collection? there are four kind of reference in Java : Strong reference Weak Reference Soft Reference Phantom Reference JVM Internals and Garbage Collection public class Zoo { public static void main(String[] args) { System.out.println(args[0]); System.out.println(args[1]); } } The program correctly identifies the first two -words” as the arguments. Spaces are used to separate the arguments. If you want spaces inside an argument, you need to use quotes as in this example: $ javac Zoo.java $ java Zoo &quot;San Diego&quot; Zoo All command-line arguments are treated as String objects, even if they represent another data type: $ javac Zoo.java $ java Zoo Zoo 2 Finally, what happens if you don’t pass in enough arguments? $ javac Zoo.java $ java Zoo Zoo Zoo Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 1 at mainmethod.Zoo.main(Zoo.java:7) public class Conflicts { Date date; // some more code } The answer should be easy by now. You can write either import java.util.*; or import java.util.Date;. The tricky cases come about when other imports are present: import java.util.*; import java.sql.*; // DOES NOT COMPILE import java.util.Date; import java.sql.*; If you explicitly import a class name, it takes precedence over any wildcards present. ■ octal (digits 0–7), which uses the number 0 as a prefix—for example, 017 ■ hexadecimal (digits 0–9 and letters A–F), which uses the number 0 followed by x or X as a prefix—for example, 0xFF ■ binary (digits 0–1), which uses the number 0 followed by b or B as a prefix—for example, 0b10 System.out.println(56); // 56 System.out.println(0b11); // 3 System.out.println(017); // 15 System.out.println(0x1F); // 31 added in Java 7. You can have underscores in numbers to make them easier to read: int million1 = 1000000; int million2 = 1_000_000; double notAtStart = _1000.00; // DOES NOT COMPILE double notAtEnd = 1000.00_; // DOES NOT COMPILE double notByDecimal = 1000_.00; // DOES NOT COMPILE double annoyingButLegal = 1_00_0.0_0; // this one compiles Declaring Multiple Variables int i1, i2, i3 = 0; As you should expect, three variables were declared: i1, i2, and i3. However, only one of those values was initialized: i3. The other two remain declared but not yet initialized. int num, String value; // DOES NOT COMPILE This code doesn’t compile because it tries to declare multiple variables of different types in the same statement. double d1, double d2; // DOES NOT COMPILE If you want to declare multiple variables in the same statement, they must share the same type declaration and not repeat it. double d1, d2; would have been legal. boolean b1, b2; String s1 = &quot;1&quot;, s2; double d1, double d2; int i1; int i2; int i3; i4; The first statement is legal. It declares two variables without initializing them. second statement is also legal. It declares two variables and initializes only one of them. The third statement is not legal. Variables d1 and d2 are the same type &amp; breaks between them. The fourth statement is legal.The fifth statement is not legal.The second one is not a valid declaration because it omits the type. Garbage Collection The methods to request JVM to run Garbage Collector System.gc() : ‘System’ class contains a static ‘gc’ method for requesting JVM to run Garbage Collector. Runtime.getRuntime().gc() : gc() method available in Runtime class is an instance method. 1.Nullifying the reference Variable Student s1 = new Student(); Student s2 = new Student(); //No Object eligible for Garbage Collector s1 = null; //One Object eligible for Garbage Collector s2 = null; Both Objects eligible for Garbage Collector 2.Reassigning the reference Variable Student s1 = new Student(); Student s2 = new Student(); s1 = s2; //One Object eligible for Garbage Collector 3.The Objects Created inside a method The objects which are created in a method are by default eligible for Garbage Collector once the method completes 1: public class Scope { 2: public static void main(String[] args) { 3: String one, two; 4: one = new String(&quot;a&quot;); 5: two = new String(&quot;b&quot;); 6: one = two; 7: String three = one; 8: one = null; 9: } } Difference between PATH and Classpath in Java? Answer : PATH is a environment variable in Java which is used to help Java program to compile and run.To set the PATH variable we have to include JDK_HOME/bin directory in PATH environment variable and also we cannot override this variable. On the other hand, ClassPath variable is used by class loader to locate and load compiled Java codes stored in .class file. We you want to run JUnit from any where from cmdline you eed to add Junit.jar in class path. Difference between interpreter and JIT compiler? The interpreter interprets the bytecode line by line and executes it sequentially. It results in poor performance. JIT compiler add optimization to this process by analyzing the code in blocks and then prepare more optimized machine code. Difference between JRE and JVM? JVM is the specification for runtime environment which executes the Java applications. Hotspot JVM is such one implementation of the specification. It loads the class files and uses interpreter and JIT compiler to convert bytecode into machine code and execute it. Difference Between JVM &amp; HotSpot VM JVM : is a Specification, HotSpot : is a implementation of JVM. HotSpot** **is an implementation of the JVM concept, originally developed by Sun and now owned by Oracle. There are other implementations of the JVM specification, like JRockit, IBM J9, among many others. Is Java a pure object oriented language? (answer) Java is not a pure object-oriented programming language e.g. There are many things in Java which are not objects e.g. primitive data types e.g. boolean, char, short, int, long, float, double, different kinds of arithmetic, logical and bitwise operator e.g. +, -. *, /, &amp;&amp;, || etc. Few pure OO languages are Smalltalk and Eiffel. There are seven qualities to be satisfied for a programming language to be pure Object Oriented. They are: 1.Encapsulation/Data Hiding 2.Inheritance 3.Polymorphism 4.Abstraction 5. All predefined types are objects 6. All operations are performed by sending messages to objects 7. All user defined types are objects How does WeakHashMap work? WeakHashMap operates like a normal HashMap but uses WeakReference for keys. Meaning if the key object does not devise any reference then both key/value mapping will become appropriate for garbage collection. How do you locate memory usage from a Java program? Answer: You can use memory related methods from java.lang.Runtime class to get the free memory, total memory and maximum heap memory in Java. public static Runtime getRuntime() returns the instance of Runtime class. public void exit(int status) terminates the current virtual machine. public void addShutdownHook(Thread hook) registers new hook thread. public Process exec(String command) executes given command in a separate process. public int availableProcessors() returns no. of available processors. public long freeMemory() returns amount of free memory in JVM. public long totalMemory() returns amount of total memory in JVM. public class TestApp { public static void main(String[] args) { Runtime r = Runtime.getRuntime(); System.out.println(r.totalMemory()); //16252928 System.out.println(r.freeMemory()); //15709576 System.out.println(r.availableProcessors());//24 r.gc(); } } What is ClassLoader in Java? When a Java program is converted into .class file by Java compiler which is collection of byte code. ClassLoader is responsible to load that class file from file system, network or any other location Bootstrap ClassLoader - JRE/lib/rt.jar Extension ClassLoader - JRE/lib/ext or any directory denoted by java.ext.dirs Application ClassLoader - CLASSPATH environment variable, -classpath or -cp option, Class-Path attribute of Manifest inside **JAR file.** Class Loader in Java BootStrap Extension and Application Java heap memory When a Java program started Java Virtual Machine gets some memory from Operating System. whenever we create an object using new operator or by any another means the object is allocated memory from Heap and When object dies or garbage collected, memory goes back to Heap space. How to increase heap size in Java Default size of Heap space in Java is 128MB on most of 32 bit Sun’s JVM but its highly varies from JVM to JVM. change size of heap space by using JVM options -Xms and -Xmx. Xms denotes starting size of Heap while -Xmx denotes maximum size of Heap in Java. Java Heap and Garbage Collection As we know objects are created inside heap memory and Garbage Collection is a process which removes dead objects from Java Heap space and returns memory back to Heap in Java. For the sake of Garbage collection Heap is divided into three main regions named as New Generation, Old Generation, and Perm space Screen Clipping New Generation of Java Heap is part of Java Heap memory where a newly created object is stored, Old Generation During the course of application many objects created and died but those remain live they got moved to Old Generation by Java Garbage collector thread Perm space of Java Heap is where JVM stores Metadata about classes and methods, String pool and Class level details. Perm Gen stands for permanent generation which holds the meta-data information about the classes. Suppose if you create a class name A, it’s instance variable will be stored in heap memory and class A along with static classloaders will be stored in permanent generation. Garbage collectors will find it difficult to clear or free the memory space stored in permanent generation memory. Hence it is always recommended to keep the permgen memory settings to the advisable limit. JAVA8 has introduced the concept called meta-space generation, hence permgen is no longer needed when you use jdk 1.8 versions. Eden Space – New Objects are Created Survivor Space – Once Eden space is full, Minor thread try to clear the Space, the objects which are survived by GC will be placed in Survivor space. Old Gen – Objects which are survived from a long time, let say 16 Cycles (GC cycle Threshold) of Minor Garbage Collector, those objects moved to Old Gen. The Old Gen space finally collected by Main Garbage collector. Finally, Minor Garbage collector will runs only on Young Gen, Main Garbage Collector will run on whole heap space Does Garbage collection occur in permanent generation space in JVM? YES, Garbage Collection occur in PermGen space as well. and if PermGen space is full or cross a threshold, it can trigger Full GC(Main Thread). If you look at output of GC you will find that PermGen space is also garbage collected. This is why correct sizing of PermGen space is important to avoid frequent full GC. You can control size of PermGen space by JVM options -XX:PermGenSize and -XX:MaxPermGenSize. Types of Garbage Collectors When an object is no longer used, the garbage collector reclaims the underlying memory and reuses it for future object allocation. This means there is no explicit deletion and no memory is given back to the operating system. Java has four types of garbage collectors, Serial Garbage Collector Parallel Garbage Collector CMS Garbage Collector G1 Garbage Collector Each of these four types has its own advantages and disadvantages. Most importantly, we the programmers can choose the type of garbage collector to be used by the JVM. We can choose them by passing the choice as JVM argument 1. Serial Garbage Collector It is designed for the single-threaded environments. It uses just a single thread for garbage collection. It freezes(stops) all the application threads while performing garbage collection. it may not be suitable for a server environment. It is best suited for simple command-line programs. Turn on the **-XX:+UseSerialGC **JVM argument to use the serial garbage collector. 2. Parallel Garbage Collector It is the default garbage collector of the JVM. It uses multiple threads for garbage collection. Similar to serial garbage collector this also freezes(siops) all the application threads while performing garbage collection. 3. Concurrent Garbage Collector Concurrent Mark Sweep (CMS) garbage collector uses multiple threads to scan the heap memory to mark instances for eviction and then sweep the marked instances. It runs along with our Application. Uses multiple cores(cpus) to run multiple GC’s concurrently. Here your application won’t pass/stop Turn on the XX:+USeParNewGC JVM argument to use the CMS garbage collector. 4. G1 Garbage Collector G1 garbage collector is used for large heap memory areas. It separates the heap memory into regions and does collection within them in parallel. G1 also does compacts the free heap space on the go just after reclaiming the memory. G1 collector prioritizes the region based on most garbage first. Turn on the –XX:+UseG1GC JVM argument to use the G1 garbage collector. https://www.youtube.com/watch?v=UnaNQgzw4zY Java 8 Improvement Turn on the -XX:+UseStringDeduplication **JVM argument while using G1 garbage collector. This optimizes the heap memory by removing duplicate String values to a single char[] array**. This option is introduced in Java 8 u 20. Given all the above four types of Java garbage collectors, which one to use depends on the application scenario, hardware available and the throughput requirements. Garbage Collection JVM Options Type of Garbage Collector to run Option Description -XX:+UseSerialGC Serial Garbage Collector -XX:+UseParallelGC Parallel Garbage Collector -XX:+UseConcMarkSweepGC CMS Garbage Collector -XX:ParallelCMSThreads= CMS Collector – number of threads to use -XX:+UseG1GC G1 Gargbage Collector GC Optimization Options Option Description -Xms Initial heap memory size -Xmx Maximum heap memory size -Xmn Size of Young Generation -XX:PermSize Initial Permanent Generation size -XX:MaxPermSize Maximum Permanent Generation size Garbage collection is performed by a daemon thread called Garbage Collector(GC). This thread calls the finalize() method before object is garbage collected. The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing (destroying remaining objects). Neither finalization nor garbage collection is guaranteed. How String Literals Garbage Collected? Strings created without using the new keyword are NEVER garbage collected. Even if there are no references to them. All such strings go into the String pool and just sit there till the whole program ends (ie. the JVM).The String Const. pool cleaned up when the class is unloaded by the JVM. How to you monitor garbage collection activities? just to check whether candidate has ever monitored GC activities or not. You can monitor garbage collection activities either offline or real-time. You can use tools like JConsole and VisualVM VM with its Visual GC plug-in to monitor real time garbage collection activities and memory status of JVM or you can redirect Garbage collection output to a log file for offline analysis by using -XlogGC=&lt;PATH&gt; JVM parameter. Anyway you should always enable GC options like -XX:PrintGCDetails -X:verboseGCand -XX:PrintGCTimeStamps as it doesn’t impact application performance much but provide useful states for performance monitoring. How do you identify minor and major garbage collection in Java? Minor collection prints GC if garbage collection logging is enable using –verbose:gc or -XX:PrintGCDetails Major collection prints -Full GC”. How to Generate GC Log File? In order to understand the GC log, you first need to generate one. Passing the following system properties to your JVM would generate GC logs -XX:+PrintGCDetails -XX:+PrintGCDateStamps –Xloggc:D://gc.log Or add visual-gc plugin to visualVM What Security model used by Java? Sandbox. The sandbox security model makes it easier to work with software that comes from sources you don’t fully trust. What is -Phontom” memory A memory that doesn’t exist in reality. A phantom reference lets you do final touch up closing on an object, even after it has been declared dead — no longer referenced by any live object. During garbage collection, these reference objects are handled specially; that is, the referent field is not traced during the marking phase. When marking is complete, the references are processed in sequence for sweeping phase. Soft Weak Final Phantom How many JVMs can run on a single machine? Multiple, yes You can run as many JVMs as you can fit on your disk and in memory :) Whenever you start a Java application, you’re first starting the JVM and then telling it which application to run. The answer to “which JVM” is simply: The JVM that you loaded the application with! for example, for execution of applets a separate JVM may exist and another JVM can be started by the User for execution of Java Byte Code, on a single machine. Difference between Object Oriented and Object Based language Object Oriented Languages Object Oriented Languages supports all the features of Oops Abstraction, Encapsulation, Polymorhisum, Inhertance. C#, Java, VB. Net are the examples of object oriented languages. Object Based Languages Object based languages does not support inheritance or, polymorphism or, both. Object based languages does not support built-in objects. Javascript, VB are the examples of object bases languages. If I don’t provide any arguments on commandline, then String array of main() is Empty or NULL? It’s Empty, but not Null. Is main method compulsory in Java? The answer to this question depends on version of java you are using. Prior to JDK 5, main method was not mandatory in a java program. You could write your full code under static block and it ran normally. The static block is first executed as soon as the class is loaded before the main(); Read more: https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html#ixzz5fwmNzRHE Read more: https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html#ixzz5fwm9nzDa Data Types How do you convert bytes to String? you can convert bytes to the string using string constructor which accepts byte[], just make sure that right character encoding otherwise platform’s default character encoding will be used which may or may not be same. String str = new String(bytes, &quot;UTF-8&quot;); How do you convert bytes to long in Java The byte takes 1 byte of memory and long takes 8 bytes of memory. Assignment 1 byte value to 8 bytes is done implicitly by the JVM. byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double The left-side value can be assigned to any right-side value and is done implicitly. The reverse requires explicit casting. byte b1 = 10; // 1 byte long l1 = b1; // one byte to 8 bytes, assigned implicitly Is ++ operator is thread-safe in Java? No it’s not a thread safe operator because its involve multiple instructions like reading a value, incriminating it and storing it back into memory which can be overlapped between multiple threads. Volatile Vs Atomic variables? Volatile Example If writerThread() is executed by one thread &amp; readerThread() is executed by another thread the ‘x’ value is different for two threads because they are reading value from their LocalCache. Here the changes of X value is not visible globally (Field Visibility), because they are changing in LocalCache. To avoid this, we need to use ‘volatile’ keyword for fields. The Java volatile keyword is used to mark a Java variable as “being stored in main memory”. that means, every read of a volatile variable will be read from the main memory(Shared Memory), and not from the CPU cache every write to a volatile variable will be written to main memory, and not just to the CPU cache. In the above diagram two threads t1, t2 are trying to change the value of flag. If Thread1 changes value flag=false, then it will flush(push) the changes from LocalCache to SharedCache and it will refresh the all Thread LocalCaches with updated value. If Thread 2 is trying to read, it will get updated value. Volatile solves the visibility problem, where Only one operation is perform Amtomic Problem Atomic - forming a single irreducible unit or component in a larger system. Increment (++) is an Compound Operation(multiple). AtomicVaribles makes compound operations as Atomic(Single) We can solve this problem using Synchronization Another Way using Atomic Variables Atomic Varibles The java.util.concurrent.atomic package defines classes that support atomic operations on single variables. All classes have get and set methods that work like reads and writes on volatile variables. We have following Atomic classes AtomicInteger AtomicLong AtomicBoolean AtomicReference AtomicIntegerArray AtomicLongArray AtomicReferenceArray Common methods incrementAndGet(): Atomically increments by one the current value. decrementAndGet(): Atomically decrements by one the current value. addAndGet(int delta): Atomically adds the given value to the current value. compareAndSet(int expect, int update): Atomically sets the value to the given updated value if the current value == the expected value. getAndAdd(int delta): Atomically adds the given value to the current value. set(int newValue): Sets to the given value. What will this return 3*0.1 == 0.3? true or false? Both are not equal, because floating point arithmetic has a certain precision. Check the difference (a-b) it should be really small. In computer memory, floats and doubles are stored using IEEE 754 standard format. f1 = (0.1+0.1+0.1….11 times) = 1.0999999999999999 f2 = 0.1*11 = 1.1 In BigDecimal class, you can specify the rounding mode and exact precision which you want to use. Using the exact precision limit, rounding errors are mostly solved. Best part is that BigDecimal numbers are immutable i.e. if you create a BigDecimal BD with value -1.23”, that object will remain -1.23” and can never be changed. You can use it’s .compareTo() method to compare to BigDecimal numbers private static void testBdEquality() { BigDecimal a = new BigDecimal(&quot;2.00&quot;); BigDecimal b = new BigDecimal(&quot;2.0&quot;); System.out.println(a.equals(b)); // false System.out.println(a.compareTo(b) == 0); // true } Which one will take more memory, an int or Integer? (answer) An Integer object will take more memory. an Integer is the an object and it store meta data overhead about the object and int is primitive type so its takes less space. Autoboxing and Unboxing? If a method(remember only method – not direct) requires Integer Object value, we can directly pass primitive value without issue. Autoboxing will take care about these. We can also do direct initializations (1.8 V) Integer i = 10;// it will create Integer value of 10 using Autoboxing int j = i;// ;// it will convert Integer to int using Autoboxing Previously it shows Integer i = 10;// it will create Integer value of 10 using Autoboxing int j = i;//But we cant assign int to Integer Type mismatch: cannot convert from Integer to int How to convert Primitives to Wrapper &amp; Wrapper to Primitive ?? // 1. using constructor Integer i =new Integer(10); // 2. using static factory method Integer i = Integer.valueOf(10); //3.wrapper to primitive int val = i.intValue(); How does Autoboxing of Integer works in Java? (answer) Compiler uses valueOf() method to convert primitive to Object uses intValue(), doubleValue() etc to get primitive value from Object. what if I make main() private/protected ? if you do not make main() method public, there is no compilation error. You will runtime error because matching main() method is not present. Remember that whole syntax should match to execute main() method. Error: Main method not found in class Main, please define the main method as: public static void main(String[] args) What is blank final variable? A blank final variable in Java is a final variable that is not initialized during declaration. Below is a simple example of blank final. // A simple blank final example final int i; Value must be assigned in constructor/Static(static final) /Instance block before using it. If we have more than one constructors or overloaded constructor in class, then blank final variable must be initialized in all of them. Difference between java.util.Date &amp; java.sql.Date? java.util.Date represent both Date and Time information. java.sql.Date just represent DATE without time information. java.sql.Time and java.sql.TimeStamp which represents TIME and TIMESTAMP type of SQL database is more close to java.util.Date. java.util.Date is Super class of java.sql.Date Why Java does not support Operator Overloading? The meaning of an operator is always same for variable of basic types like: int, float, double etc. For example: To add two integers, + operator is used. However, for user-defined types (like: objects), you can redefine the way operator works. For example: If there are two objects of a class that contains string as its data members. You can redefine the meaning of + operator and use it to concatenate those strings. To overload an operator, a special operator function is defined inside the class as class className { ... .. ... public returnType operator symbol (arguments) { ... .. ... } ... .. ... }; #include &lt;iostream&gt; using namespace std; class Test { private: int count; public: Test(): count(5){} void operator ++() { count = count+1; } void Display() { cout&lt;&lt;&quot;Count: &quot;&lt;&lt;count; } }; int main() { Test t; // this calls &quot;function void operator ++()&quot; function ++t; t.Display(); return 0; } This function is called when ++ operator operates on the object of Test class (object t in this case). In the program, void operator ++ () operator function is defined (inside Test class). This function increments the value of count by 1 for t object. Why Java Doesn’t Support it? 1.Java is Simple, No Confusions Please!! Java does not support operator overloading: Java is relatively a very simple language to use compared C/C++ with the non-support of complex and confusing features like pointers, multiple inheritance and operator overloading. These features are rarely used in practice and at the same time poorly understood by the language beginners. 2.JVM Performance: How many things Should i do? Form JVM perspective supporting operator overloading is more difficult and if the same thing can be achieved by using method overloading in more intuitive and clean way it does make sense to not support operator overloading in java. a complex JVM will result in slower JVM Can you store String in an Integer array in Java? compile time error or runtime exception? [answer] You cannot store an String in an array of primitive int, it will result in compile time error as shown below, but if you create an array of Object and assign String[] to it and then try to store Integer object on it. Compiler won’t be able to detect that and it will throw ArrayStoreExcpetion at runtime int[] primes = new int[10]; primes[0] = &quot;a&quot;; // compile time error Object[] names = new String[3]; names[0] = new Integer(0);// ArrayStoreException at runtime What is difference between ArrayIndexOutfOBounds and ArrayStoreException? [answer] ArrayIndexOutOfBoundsException comes when your code tries to access an invalid index for a given array e.g. negative index or higher index than length - 1. ArrayStoreException comes when you have stored an element of type other than type of array, as shown in above example. Is it legal to initialize an array int i[] = {1, 2, 3, 4, 5}; [answer] Yes, it’s perfectly legal. You can create and initialize array in same line in Java. Where does array stored in memory? [answer] Array is created in heap space of JVM memory. Since array is object in Java, even if you create array locally inside a method or block, object is always allocated memory from heap. Array concept interview questions and answers in Java Reverse Array using Iterative and Recursive approaches Steps to Solve this 1.initialize array 2.Choose start index 3.Choose end index 4.Swap the elements using temp variable package array; public class ReverseArry { /* * Recursive approach: In recursive approach the function calls itself until * the condition is met. And it is slower than iteration, which means it uses * more memory than iteration. recursion is like a selection structure, and * which makes code smaller and clean. And a function partially defined by * itself. Here tracing the code will be more difficult in the case large * programs */ public static int[] recursiveArry(int a[], int start, int end) { if (start &lt;= end) { int temp; temp = a[start]; a[start] = a[end]; a[end] = temp; recursiveArry(a, start + 1, end - 1);//calling it again } return a; } /* *Iterative approach: Iterative approach is a repetition process until the condition fails.here loops are used such as for, while etc. Here code may be longer but it is faster than recursive. And it consumes less memory compared to recursive approach.If the loop condition is always true in such cases it will be an infinite loop. */ public static int[] iteravtiveArray(int a[], int start, int end) { while(start&lt;end) { int temp; temp = a[start]; a[start]=a[end]; a[end]=temp; start++; end--; } return a; } static void printArray(int arr[], int size) { int i; for (i = 0; i &lt; size; i++) System.out.print(arr[i] + &quot; &quot;); System.out.println(&quot;&quot;); } public static void main(String[] args) { // 1. Initialize array int arr[] = { 1, 2, 3, 4, 5, 6 }; System.out.println(&quot;Input array is &quot;); printArray(arr, 6); // 2. Choose Starting &amp; ending point int b[] = recursiveArry(arr, 0, 5); System.out.println(&quot;Recursive -Reversed array is &quot;); printArray(b, 6); int c[] = iteravtiveArray(arr, 0, 5); System.out.println(&quot;IteravtiveArray -Reversed array is &quot;); printArray(c, 6); } } Input array is 1 2 3 4 5 6 Recursive -Reversed array is 6 5 4 3 2 1 How do you reverse an array in Java? org.apache.commons.lang.ArrayUtils class to reverse Array in Java. As discussed in our last post How to print array element in Java, We are using Arrays.toString() to print content of array. int[] iArray = new int[] {101,102,103,104,105}; String[] sArray = new String[] {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;}; //reverse int array using Apache commons ArrayUtils.reverse() method System.out.println(&quot;Original int array : &quot; + Arrays.toString(iArray)); ArrayUtils.reverse(iArray); java.lang Package We have mainly five classes in java.lang. Which are most commonly used in any java program Object String StringBuffer StringBuilder Wrapper Classes (AutoBoxing / AutoUnboxing) Object Class The most common general methods which can be applicable on any java object are defined in object class. Object class is the parent class of any java class, whether it is predefined or programmer defined, hence all the object class methods are by default available to any java class. Object class define the following 11 methods 1.toString():Returns a string representation of the object. public String toString() { return getClass.getName() + &#39;@&#39; + Integer.toHexString(HashCode); } 2.hashCode():returns the integer representation of memory location which used by JVM while saving/adding Objects into Hashsets, Hashtables or Hashmap 3.equals(Object): Compares two Objects for equality. 4.clone(): Creates a new object of the same class as this object which implements Clonable interface. Test t1 = new Test(); Test t2 = (Test)t1.clone(); 5.finalize():Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. 6.getClass():Returns the runtime class of an obj.getClass(), or the class-literal (Foo.class) return a Class object, which contains some metadata about the class: name package methods fields constructors annotations we can create Class object by following ways Class c = Class.forName(-StudentBO&quot;) Class c = StudentBO.class Class c = a.getClass(); public static void main(String[] args) throws Exception { TestApp a = new TestApp(); Class c1 = a.getClass(); Class c = Class.forName(&quot;java.lang.String&quot;); System.out.print(&quot;Class represented by c : &quot; + c.toString()); Object obj = c.newInstance(); } 7.wait():Waits to be notified by another thread of a change in this object. 8.wait(long):Waits to be notified by another thread of a change in this object. 9.wait(long, int):Waits to be notified by another thread of a change in this object. 10.notify():Wakes up a single thread that is waiting on this object’s monitor. 11.notifyAll():Wakes up all threads that are waiting on this object’s monitor. equals(Object otherObject) – As method name suggests, is used to simply verify the equality of two objects. It’s default implementation simply check the object references of two objects to verify their equality. By default, two objects are equal if and only if they are stored in the same memory address. hashcode() – Returns a unique integer value for the object in runtime. By default, integer value is mostly derived from memory address of the object in heap (but it’s not mandatory always). If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. Whenever we override the equals() method, we should override hashcode() method In String class(not StringBuilder, StringBuffer) &amp; All Wrapper classes equals() method is overridden for Content Comparison Compare two employee Objects based on Their Id? public class Employe { int id; String name; //Setters &amp; Getters @Override public boolean equals(Object obj) { Employe e = (Employe) obj; boolean flag = false; if (this.getId() == e.getId()) { flag = true; } return flag; } public static void main(String[] args) { Employe e1 = new Employe(); Employe e2 = new Employe(); e1.setId(101); e2.setId(101); System.out.println(e1.equals(e2));//true System.out.println(e1.hashCode()); //366712642 System.out.println(e2.hashCode()); //1829164700 – here different } } So are we done? If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. But here it is not!! Not yet. Lets test again above modified Employee class in different way. public static void main(String[] args) { Employe e1 = new Employe(); Employe e2 = new Employe(); e1.setId(101); e2.setId(101); Set&lt;Employe&gt; set = new HashSet&lt;&gt;(); set.add(e1); set.add(e2); System.out.println(set); //[basic.Employe@15db9742, basic.Employe@6d06d69c] } Above class prints two objects in the second print statement. If both employee objects have been equal, in a Set which stores only unique objects, there must be only one instance inside HashSet We are missing the second important method hashCode(). As java docs say, if you override equals()method then you must override hashCode() method public class Employe { int id; String name; @Override public boolean equals(Object obj) { Employe e = (Employe) obj; boolean flag = false; if (this.getId() == e.getId()) { flag = true; } return flag; } @Override public int hashCode() { return getId(); } public static void main(String[] args) { Employe e1 = new Employe(); Employe e2 = new Employe(); e1.setId(101); e2.setId(101); Set&lt;Employe&gt; set = new HashSet&lt;&gt;(); set.add(e1); set.add(e2); System.out.println(set); //[basic.Employe@65] } } Apache commons provide two excellent utility classes EqualsBuilder &amp; HashCodeBuilder for generating hash code and equals methods. Can a top-level class be private or protected? Top level classes in java can’t be private or protected, but inner classes in java can. The reason for not making a top-level class as private is very obvious, because nobody can see a private class and thus they cannot use it What Happens if we compile Empty java file? Compiles but Runtime Error. Is it possible to make array volatile in Java? Yes, you can make an array (both primitive and reference type array e.g. an int array and String array) volatile in Java, but only changes to reference pointing to an array will be visible to all threads, not the whole array. What this means is that suppose you have a reference variable called primes as shown below: protected volatile int[] primes = new int[10]; then if you assign a new array to primes variable, change will be visible to all threads, but changes to individual indices(a[0], a[1]…a[n]) will not be covered under volatile guarantee i.e. primes = new int[20]; It will follow the “happens-before” rule(Happens-before relationship is a guarantee that action performed by one thread is visible to another action in different thread.) and cause memory refresh, but following code will not do so if multiple threads are changing individual array elements e.g. storing updates, there won’t be any happens-before guarantee provided by the volatile modifier for such modification primes[0] = 10; primes[1] = 20; primes[2] = 30; primes[3] = 40; So, if your use-case is to provide memory visibility guarantee for individual array elements than volatile is not the right choice. You must rely on other synchronization and a thread-safety mechanism to cover this case e.g. synchronized** keyword, atomic variables, or ReentrantLock.** Is it possible to make ArrayList, Hashset volatile in Java? On a similar note, sometimes instead of an array, Interviewer put the collection i.e. they will ask can you make a collection variable volatile in Java or not e.g. an ArrayList or HashMap. The answer is same, of course, you can make a reference variable pointing to a Collection volatile in Java, but the happens-before guarantee will only be provided if the value of that reference variable is changed e.g. you assign a new collection to it. Any modification done on actual collection object e.g. adding or removing elements from ArrayList will not invoke happens-before guarantee or memory barrier refresh. What is a.hashCode() used for? How is it related to a.equals(b)? According to the Java specification, two objects which are identical to each other using equals() method needs to have the same hash code What is a compile time constant in Java? What is the risk of using it? Answer: Public static final variables are also known as the compile time constant, the public is optional there. They are substituted with actual values at compile time because compiler recognizes their value up-front, and also recognize that it cannot be altered during runtime. One of the issues is that if you choose to use a public static final variable from in-house or a third party library, and their value changed later, then your client will still be using the old value even after you deploy a new version of JARs. Explain Liskov Substitution Principle. According to the Liskov Substitution Principle, Subtypes must be appropriate for super type i.e. methods or functions which use super class type must be able to work with object of subclass without issues. Co-Variant return types are implemented based on this principle. What is double checked locking in Singleton? Singleton means we can create only one instance of that class Rules: Create Singleton class Object make it as PRIVATE Create PRIVATE constructor Every Singleton class contains at least one factory method class Student { private static Student st; private Student() { System.out.println(&quot;OBJECET Created FIRST TIME&quot;); } public static Student getObject() { if (st == null) { st = new Student(); } else { System.out.println(&quot;OBJECET ALREDAY CREATED&quot;); } return st; } } public class Singleton { public static void main(String[] args) { Student s1 = Student.getObject(); Student s2 = Student.getObject(); System.out.println(s1.hashCode());//7855445 System.out.println(s2.hashCode());//7855445 } } Double checked locking in Singleton means, at any cost only one instance is created in multi-threaded environment. In this case at null checking make Block as Synchronized. public static Singleton getInstanceDC() { if (_instance == null) { // Single Checked synchronized (Singleton.class) { if (_instance == null) { // Double checked _instance = new Singleton(); } } } return _instance; } When to use volatile variable in Java? Volatile keyword is used with only variable in Java it guarantees that value of volatile variable will always be read from main memory and not from Thread’s local cache. So, we can use volatile to achieve synchronization because its guaranteed that all reader thread will see updated value of volatile variable once write operation completed Difference between Serializable and Externalizable in Java? Serialization is a default process of serializing or persisting any object’s state in Java. It’s triggered by implementing Serializable interface which is a marker interface (an interface without any method). uses default implementation to handle the object serialization process. Externalizable is used to user defined serialization process and control default serialization process which is implemented by application. Externalizable interface extends Serializable interface. It consists of two methods // to read object from stream void readExternal(ObjectInput in) // to write object into stream void writeExternal(ObjectOutput out) Difference between static and dynamic binding in Java? (detailed answer) This is usually asked as follow-up of previous question, static binding is related to overloaded method and dynamic binding is related to overridden method. Method like private, final and static are resolved using static binding at compile time but virtual methods which can be overridden are resolved using dynamic binding at runtime. Which design pattern have you used in your production code? Dependency injection Factory pattern Adapter Design pattern Singleton Decoratordesign pattern is used to modify the functionality of an object at runtime. Can you explain Liskov Substitution principle?(Comes under inheritance ) According to Liskov Substitution Principle, Subtypes must be substitutable for supertype i.e. methods or functions which uses superclass type must be able to work with the object of subclass without any issue How to create an instance of any class without using new keyword ***************************************** 1.Using newInstance method of Class class ***************************************** Class c = Class.forName(&quot;StudentBo&quot;); StudentBo bo = (StudentBo) c.newInstance(); ***************************************** 2.Using clone() of java.lang.Object ***************************************** NewClass obj = new NewClass(); NewClass obj2 = (NewClass) obj.clone(); How can we invoke any external process in java? Using, Runtime.getRuntime().exec(…) Static imports rules ? The static import feature of Java 5 facilitates the java programmer to access any static member of a class directly. There is no need to qualify it by the class name. import static java.lang.System.*; (or) import static java.lang.System.out; class StaticImportExample{ public static void main(String args[]){ out.println(&quot;Hello&quot;);//Now no need of System.out out.println(&quot;Java&quot;); } } Ambiguity in static import // both have MAX_VALUE as static import static java.lang.Integer.*; import static java.lang.Byte.*; class Geeks { public static void main(String[] args) { out.println(MAX_VALUE); } } Error:Reference to MAX_VALUE is ambigious Java OOPs Concepts Can we prevent overriding a method without using the final modifier? (answer) Yes, you can prevent the method overriding in Java without using the final modifier. In fact, there are several ways to accomplish it e.g. you can mark the method private or static, those cannot be overridden. Can we override a private method in Java? (answer) No, you cannot. Since the private method is only accessible and visible inside the class they are declared, it’s not possible to override them in subclasses. But we can re-decalre in sub class , it will trated as a new method, bcoz parent class private method is not visible to subclass. class A{ private void show() { System.out.println(&quot;Parent&quot;); } } public class Demo extends A{ private void show() { System.out.println(&quot;Child&quot;); } public static void main(String[] args) { A a = new Demo(); a.show(); } } Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: The method show() from the type A is not visible at Demo.main(Demo.java:12) Though, you can override them inside the inner class as they are accessible there. Can we change the return type of method to subclass while overriding? (answer) Yes, you can, but only from Java 5 onward. This feature is known as covariant method overriding and it was introduced in JDK 5 release. This is immensely helpful if original method return super-class e.g. clone() method return java.lang.Object. By using this, you can directly return the actual type, preventing client-side type casting of the result. Can we make a class both final and abstract at the same time? (answer) No, you cannot apply both final and abstract keyword at the class same time because they are exactly opposite of each other. A final class in Java cannot be extended and you cannot use an abstract class without extending and make it a concrete class. As per Java specification, the compiler will throw an error if you try to make a class abstract and final at the same time. Can we overload or override the main method in Java? (answer) No, since main() is a static method, you can only overload it, you cannot override it because the static method is resolved at compile time without needing object information hence we cannot override the main method in Java. Design Patterns SOLID design principles and GOF design patterns which take advantage of OOPS concept discussed here. What are SOLID Design principles Image result for solid design principles 1. Single Responsibility Principle -One class should have one and only one responsibility” In other words, we should write, change and maintain a class for only one purpose. If it is model class then it should strictly represent only one actor/ entity. This will give we the flexibility to make changes in future without worrying the impacts of changes for another entity. 2. Open Closed Principle -Software components should be open for extension, but closed for modification” If we take a look into any good framework like struts or spring, we will see that we cannot change their core logic and request processing, but we modify the desired application flow just by extending some classes and plugin them in configuration files. For example, spring framework has class DispatcherServlet. This class acts as front controller for String based web applications. To use this class, we are not required to modify this class. All we need is to pass initialization parameters and we can extend it’s functionality the way we want. 3. Liskov’s Substitution Principle -Derived types must be completely substitutable for their base types” 4. Interface Segregation/Separation Principle This principle is my favorite one. It is applicable to interfaces as single responsibility principle holds to classes. ISP says: -Clients should not be forced to implement unnecessary methods which they will not use” Take an example. Developer Alex created an interface Reportable and added two methods generateExcel() and generatedPdf(). Now client ‘A’ wants to use this interface but he intend to use reports only in PDF format and not in excel. Will he be able to use the functionality easily? NO. He will have to implement both the methods, out of which one is extra burden put on him by designer of software. Either he will implement another method or leave it blank. This is not a good design. 5. Dependency Inversion/Injection Principle Remove dependency from classes In spring framework, all modules are provided as separate components which can work together by simply injected dependencies in other module. This dependency is managed externally in XML files. What are GOF(Gang of Four) design patterns? Image result for gof design patterns 1. Creational Design Patterns (Object Creation) Creational patterns often used in place of direct instantiation with constructors. They make the creation process more adaptable and dynamic. In particular, they can provide a great deal of flexibility about which objects are created, how those objects are created, and how they are initialized. DESIGN PATTERN NAME PURPOSE Builder Builder design pattern is an alternative way to construct complex objects and should be used only when we want to build different types of immutable objects using same object building process. Prototype Prototype design pattern is used in scenarios where application needs to create a large number of instances of a class, which have almost same state or differ very little. Factory Factory design pattern is most suitable when complex object creation steps are involved. To ensure that these steps are centralized and not exposed to composing classes. Abstract factory Abstract factory pattern is used whenever we need another level of abstraction over a group of factories created using factory pattern. Singleton Singleton enables an application to have one and only one instance of a class per JVM. 2. Structural Design Patterns Structural design patterns show us how to glue different pieces of a system together in a flexible and extensible fashion. These patterns help us guarantee that when one of the parts changes, the entire application structure does not need to change. DESIGN PATTERN NAME PURPOSE Adapter An adapter convert the interface of a class into another interface clients expect. It lets classes work together that couldn’t otherwise because of incompatible interfaces. Bridge Bridge design pattern is used to decouple a class into two parts – abstraction and it’s implementation – so that both can evolve in future without affecting each other. It increases the loose coupling between class abstraction and it’s implementation. Composite Composite design pattern helps to compose the objects into tree structures to represent whole-part hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly. Decorator Decorator design pattern is used to add additional features or behaviors to a particular instance of a class, while not modifying the other instances of same class. Facade Facade design pattern provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use. Flyweight Flyweight design pattern enables use sharing of objects to support large numbers of fine-grained objects efficiently. A flyweight is a shared object that can be used in multiple contexts simultaneously. The flyweight acts as an independent object in each context. Proxy In proxy design pattern, a proxy object provide a surrogate or placeholder for another object to control access to it. Proxy is heavily used to implement lazy loading related usecases where we do not want to create full object until it is actually needed. 3. Behavioral Design Patterns Behavioral patterns abstract an action we want to take on the object or class that takes the action. By changing the object or class, we can change the algorithm used, the objects affected, or the behavior, while still retaining the same basic interface for client classes. DESIGN PATTERN NAME PURPOSE Chain of responsibility Chain of responsibility design pattern gives more than one object an opportunity to handle a request by linking receiving objects together in form of a chain. Command Command design pattern is useful to abstract the business logic into discrete actions which we call commands. These command objects help in loose coupling between two classes where one class (invoker) shall call a method on other class (receiver) to perform a business operation. Interpreter Interpreter pattern specifies how to evaluate sentences in a language, programatically. It helps in building a grammar for a simple language, so that sentences in the language can be interpreted. Iterator Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. Mediator Mediator pattern defines an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets us vary their interaction independently. Memento Memento pattern is used to restore state of an object to a previous state. It is also known as snapshot pattern. Observer Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It is also referred to as the publish-subscribe pattern. State In state pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class. There shall be a separate concrete class per possible state of an object. Strategy Strategy pattern is used where we choose a specific implementation of algorithm or task in run time – out of multiple other implementations for same task. Template method Template method pattern defines the sequential steps to execute a multi-step algorithm and optionally can provide a default implementation as well (based on requirements). Visitor Visitor pattern is used when we want a hierarchy of objects to modify their behavior but without modifying their source code. What is Strategy pattern in Java? Strategy pattern allows you to introduce new strategy without changing the code. For example, the Collections.sort() method which sorts the list of the object uses the Strategy pattern to compare object. Since every object uses different comparison strategy you can compare various object differently without changing sort method. What is Decorator Design Pattern? Decorator pattern provides new features without modifying the original class. Inheritance is the example. What is the difference between Decorator, Proxy and Adapter pattern in Java? (answer) Again they look similar because their structure or class diagram is very similar but their intent is quite different. Decorator adds additional functionality without touching the class, Proxy provides access control and Adapter is used to make two incompatible interfaces work together. What is a strongly typed programming language? In a strongly typed language compiler ensure type correctness, for example, you can not store the number in String or vice-versa. Java is a strongly typed language, that’s why you have different data types Ex int, float, String, char, boolean etc. On the other hand, weakly typed language don’t enforce type checking at compile time and they tree values based upon context. Python and Perl are two popular example of weakly typed programming language, where you can store a numeric string in number type. Can you describe three different kinds of testing that might be performed? Unit Testing, Integration Testing and Smoke Testing. Unit testing is used to test individual units to verify whether they are working as expected Integration Testing is done to verify whether individually tested module can work together or not Smoke Testing is a way to test whether most common functionality of software is working properly or not e.g. in a flight booking website, you should be able to book, cancel or change flights. What is the difference between iteration and recursion? (detailed answer) Iteration uses a loop to perform the same step again and again. Recursion calls the same method itself to do the repetitive task What is test-driven development? Test driven is one of the popular development methodologies in which tests are written before writing any function code. In fact, test drives the structure of your program. Purists never wrote a single line of application code without writing a test for that. It greatly improve code quality and often attributed as a quality of rockstar developers. How do you find a running Java process on UNIX? You can use the combination of ‘ps’ and ‘grep’ command to find any process running on UNIX machine. ps -e will list every process i.e. process from all user not just you and ps -f will give you full details including PID, which will be required if you want to investigate more or would like to kill this process using kill command. ps -ef grep “java” Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Garbage Collection? there are four kind of reference in Java : Strong reference Weak Reference Soft Reference Phantom Reference","url":"/Java-Interview-Questions-1.html","headline":"Java - Interview Questions PART-1","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- start custom head snippets -->

<!-- end custom head snippets --><script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.isFormElement = function(node) {
    var tagName = node.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i;
      loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cbs[i]();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();
(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();
(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();
</script><script>
  (function() {
    var TEXT_VARIABLES = {
      version: '2.2.4',
      sources: {
        font_awesome: 'https://use.fontawesome.com/releases/v5.0.13/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        valine: 'https://unpkg.com/valine/dist/Valine.min.js',
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3'
        }
      },
      paths: {
        search_js: '/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script></head>
  <body>
    <div class="root" data-is-touch="false">
      <div class="layout--page js-page-root"><div class="page__main js-page-main page__viewport has-aside cell cell--auto">

      <div class="page__main-inner"><div class="page__header d-print-none"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="76px" height="76px" viewBox="0 0 76 76" enable-background="new 0 0 76 76" xml:space="preserve">  <image id="image0" width="76" height="76" x="0" y="0"
    xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEwAAABMCAIAAABI9cZ8AAAAIGNIUk0AAHomAACAhAAA+gAAAIDo
AAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQflBwgJKRMy4DHU
AAAAXnRFWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMACmlwdGMKICAgICAgMjgKMzg0MjQ5NGQwNDA0
MDAwMDAwMDAwMDBmMWMwMjZlMDAwMzUyNDY0NzFjMDIwMDAwMDIwMDA0MDAKYJo9ngAAD4RJREFU
eNrtm2tsE1fax894Lp7xeGzHzgUSbNI0YJJwSQKEWxWlUWkSKEIqq20RsBUrtewXpBatSlu1WvVT
F7XbW1RKqxaqCiEl25KkYUkpYlPEQrkkAsIlgZAEcnOcOAQntseeGXveD09z3sFODLm1+/JyhCxn
PHPm/M7znHOe838OhKqq6FEvut+7AY8hH0M+hnwM+UiWx5CPSqF+rxePGYQQBPEoQEYiEcyjqqqq
qgAWiUTgCkEQcAV/+W+HxOZSVXVkZGR4eJiiKFmWRVHs6upiWTYQCJw6dSonJyc3N1eW5cTERIZh
jEYjEOp0Op1ON3VUYiZiV6gTLCNJksvlunXr1ldffXXlyhWLxRIIBHw+3+DgIMMwCKGBgQGj0ZiW
liaKYkZGhiAI69atKygoyMzMhBtIkpwi6jRDgr8pijI8PNzT09PY2Hjq1KnGxka32+12u8cbh1HX
OY7Lysp6+eWXZ8+evXz5covFQtM0oE6+WdNSIpGIqqqiKN68eXPv3r1lZWVPPvkkwzCTsAD4Ksdx
FoulvLx8YGDA6/WGQqFwODy5tk0DJOD5/f76+vo33ngjMzOT53ltcyfpYwSBEFq4cOHRo0fdbvfw
8LAkSfCu3xQSXhkKhVpbW997772UlBTsUdMyMUIlq1atOnnypNvt9vl8sixPgnOSs6uqqgghWZab
mpoqKirq6upaW1slScJsaszwg5+iroOpteuK9nFVVQmCOHv2bE1Njd1upyiKoqhJTEKTgYQWuFyu
r7/++sCBA52dneFweDwGbYsRQiaTyWq1UhQlCILFYrHZbAzDeDwer9fb3d3d398vy3Is8KVLlzwe
D8Mwer2eoibc5gk/AF56/vz5d999t76+HlsvFu/X8YCQIAjp6enp6enJyclZWVmzZ8+madpoNHIc
R9O0TqeLRCKyLLtcrjt37nR1dd2+ffvMmTP37t3DnFevXm1vb09MTJRlmWGYiRpzYpCqqsqyXFtb
+/bbb7e0tICzafG0fyYkJGRnZ6empi5ZsiQrKyshIYFlWVgM4BMvgPBUWlpafn6+JEmBQKC6uvrz
zz/3er3wqyiKfX19kiTBmJwpS8LwcLvd+/bt++KLL/r6+mLXN+jd5ORkg8HgdDqfeeYZp9MpCALL
sgzDgLMxDANDCwixTcBBwuGwLMuCIGzbto2iqI8//tjn88HC6/V6FUUJh8Mw8Uy/JaHSO3fu7N69
u6qqClwUE+JWkiSZlpa2detWp9OZkpIiCIJer2dZlmVZLZ5OpyNJktAUpFmugZPjuNTUVJZlfT4f
QogkSb1ejwlnxJIEQbS3t7/++uvV1dXhcBhpAjf4TlFUenp6cXHx0qVL582bx/M8x3EcxwEeTdPY
PyEixc9qDfLrdE9RDMNcvXr1o48+8ng8cIOiKD6fDw/y6YdUVdXj8bz11ltVVVVjDr/09PSSkpKV
K1c6HA6e5w0GA3wCHvZMrd3G60pc54ULFzo6OrSdKAgCuPf0Q6qqGgwGP/jgg6qqqthdkiAICxYs
ePHFF3NzczmO43neaDQaDAYYhFq8h28QLJt5eXlz585ta2tDCJEkuXr16kWLFuG5aqKQ8QJ0+Km2
tvaVV15xu924EfC5ePHiDRs25OfnW61WQRCMRiOsCpPGwyUcDkuSVFlZ+emnn4qiuHLlyg0bNjgc
joSEBKvVajAYaJqeWMfF9/L29vatW7f+8ssveEerqqpery8qKtqyZcucOXN4ngdCMCDeLkwlrItE
IpIk+Xy+rq4ur9drNBppmuZ53mQyGY1GvV5PkuSEKhzXXcEhq6qqLly4oCUkSbKsrGzbtm1JSUkm
kwlejP1zeva4BEFRFMdxDocjFAopigKzKwQPk6g/3pj0er11dXWKomjrLSwsfOGFF5KSkhISEiwW
C8/zYEA8tUyRECCBCj6hf/HyM4kxGQ+yt7e3s7MTaUK2RYsWbd68efbs2Waz2WKxwEI/XQaM5QQ2
NDrxTroTx4UkCKK3t3doaAhfYVm2rKwM1okoA6LRgGHaOaelqnhjUhAEjuPwlVAodPjwYbfbvWLF
ihUrVpjNZu2eTbtjQvdvl2dIaJxAf403u4bD4Xv37u3YseP777/X7npIkuR5fsGCBcuWLTMajYsX
LxZFMTk52WazzZkzh2EYHOVoIafibDMLqSjK6dOnd+3a1dTUhCGjolaWZRVFMRgMBoPB4XDQNG02
mzMyMkpKSpJGC1Z6sNCIflvzjgsJu6pAIHDx4sU9e/acOnUqGAyCBKy9Z+xKCQIWT7vdXlRUNGvW
rJycnHnz5hmNRp7nYYbEMfrvDBmJREKhkCiKnZ2dDQ0Np0+fPnnyZHd3t6IoGOaBModOp6MoymKx
2O12q9W6ffv2oqIiQRAgKvptUB8Q1oXD4VAoFAwGRVH0er23bt26fPny7du3m5ub29vbQSkcky0K
G19PS0tzOp2lpaXPP/98cnIyRVEQJM0o5wPCukgkAtqEJEnBYDAUCkmSJIri0NBQd3d3U1PT9evX
dTrd9evXOzo6sIXHfdkorV6vX7t27e7du7OzsyFamlHOByvo4LeRSERRFKAFGUJRFDCyLMs9PT2n
T59uampyuVwDAwMejyeOSIFh1qxZ8/7778+bN4/juElEpNMJiVGxQgEFmPGnoigjIyNer7erq+vK
lStXrly5du2a2+0GIW/MoUsQxGuvvbZz505BEHien5zcPp2QsbS4YGBt8fv9bW1tdXV1J06ccLlc
ODOnhVRVddWqVZ988klaWprZbGZZ9mGMqZVkH7JTJixJ4rUuSqXG5gVgQRBsNltOTs7GjRtramoO
Hz4Mak1UW/v6+vr6+pKSkhRFgY7A+sB4GKqqhhUFEQRomQ+T3pt8flLbAlAowLAYWJZlnufNZvP8
+fMTEhL27t2rKEqs42CHhxYPDg663e6UlBSTyQTLKQQP8GC4rQ1VVKC2NmSxhEpLwwUFJMOQJPmA
TcJUciGxRevAoKAODQ253e6qqqqEhITYt+fl5dXV1bW0tPT399+4ceOzzz4rLS1NS0vbtWvXwMCA
z+eTJAlEurCiSGfPKsXFEZJUEYoQhJyaeu9vf/PcvOn1egOBQJw0yTRnmrUaHLaDXq93uVyBQCAq
JFRV9YknnmBZtr29/eDBgz/88MPNmzeDwSBCqKOjw+v14hoig4NqRQVZXk60tiKEVIJACJG9vaa/
/108c2bk1VelggJQXsYUgWYwnQ6oNE03Nzd/++23OGzAHgTN2r9//5kzZ27fvg1iJ0LIaDSuWbMG
lB69Xk96vcSbb1KHDhGhEOARMPcQBAqFDMePI5dr8B//UPPyQJoZYyRPr7vGeu/du3e3b98+Zi+w
LGu1WnG8jluWlZV1+PDha9eu9fb2BgKB0IEDEZZVCSJCECpC2n8RhCIEEUHo7vr1HU1N/f39fr8f
Rr62zOA5HlVVJUnau3dvZWXlmFNCMBi8e/euOrrbVlWVZdm1a9fu3LkTkkIURSFZ1v3730QwiA14
n7MgRKgqgZCpvp6orfX7/RCcRN02U+4K08+xY8f27dvn9/vHm/cwHk3Ts2bN2rhxY0lJSWJiIoQH
er2ecLmIxkbos3FfRhBkIJB48OCA0xkoKNDpdCzLziAknlcURamsrHznnXe6u7vHi3jAl0iSzMzM
LC4uzs/Ph1S8IAgmk4nneZqmdf/6l66tDXaxcd6KCIJvbibefHPor3/1rVtnsVhmBBJjyLLc2tpa
UVHx5Zdfut3uMQnhfrPZ7HQ6Fy9eXFhY6HA4IH0Ce06Yk3R9fURFBZ5v4r0dIYIgDK2tuj17+m02
NGfOdEJqTdfT03P27NlLly7V1tbeuHEjNmqFPymKMhgMdrt906ZNy5YtM5vNgAdsoJ7AblPp6KBa
WtSxRmNUwfOtvqODPnIEbdo0PZDqaGIrFApdvny5pqbm2LFjzc3NcBYlKj+Lv9vt9qeffnrJkiVz
585NTk7mOA6kE9iIMAxzn4SLD3TFd1ctLUJUe3vUxcmfGUAIBYPBixcvfvfdd1VVVZ2dnVpxJMpF
wTmLi4ufffZZGHjcaNGm97SBaDgcjjid0lNPMUePTmhvEonpjgmn09FoqquhoeHQoUNHjhzp6elB
YykD+IrFYsnKyiotLS0oKDCZTNrcHuBFZZ3/t1itob/8hWxooPr7H9KMCssO5uWlTA4S4w0ODv70
008nTpw4fvx4T0+POqrfjYnHMExubu7GjRsXLlxotVo5joO1AeYVbXYodo2B65GCAmn1aqq6+oEe
CzfcnT/f89RTE7YktD4YDHZ2dv744481NTUNDQ0jIyPxrYcQSkpKWr9+fVlZWUpKCqQu8dSiTTzH
ebVOp2MEQdq8Wf+f/5AezwObqrBsT0kJSokyZFxIaKsoiufOnfvmm28aGxtv3LgBQk6s9bRPWa3W
lStXFhcXL1myBPKWgiDg5OzD4KHRNEE4HEZFRf4//9lYXq4TxXh3q6pr+fJ7q1bx90cC40JC6wOB
wLlz5yorK48cOdLb24t3sbF42IA6nS4zM3Pbtm1Lly4Fz8T+CQvDhJJfvyazDIbAjh1hv9+8f79O
FMf2W1X1Ohydf/wjk5RkNBofDAkM169f//DDD+vq6uAI53iKo3YXn52dXVxcvGzZsvT0dIynTc5O
VGIFCYKmab3NJr766l2WtXz1FeX1otHVBTfLn5TU8qc/STk5VqNREIToesZ0ua6urpdeeunnn39W
788LjGk9juNSUlLy8/Ofe+65jIwMfHgAZ76mmNsDkUEURdHrRdXVln37uNZWYlQNjJDksMNxc8uW
kaIiOMdmNpujNuhju2tbW9v58+dRjEYe9afBYMjNzS0sLMzJyZk1axacGcB4OHCZogYHxoTv/j/8
wb1gAffPfxoaGwm/P2ixDC1aNFBYGMnIsAqC2WyGlGlUDWND2mw2u93e0tIS+5PBYLBYLKmpqVlZ
WdnZ2dnZ2VarFU4kQeCiXR6mJQWAnRaAxdzcQEbGiNsdGh6W9HqJ51mGgc7F5/Wia4h1xXA4HAwG
6+vry8vLL126BHvQ5ORkh8Nht9vT09Ptdjs+cEXTNMuyOHCZ+tGP8QqMfJCOQqEQaPkQP9I0rR8t
2rxwPEjIC4RCoa6uro6OjqGhIVmWbTYbeAKMMYjCgAoHZTinP3OCP9byQSuDKQNySnHePgakqqqg
r0CeJxgMYlEU6sKc+ChgnMBl2kuUtIFFszhvH3ezp9XFIbEBqzNGwt32+2aRH6bEy09iHRXvqqIK
+i84DzAlSIx6393/F5AmDPlolP8X/7XwMeSjUh5DPirlfwA1QTCTlERFOgAAACV0RVh0ZGF0ZTpj
cmVhdGUAMjAyMS0wNy0wOFQxNzo0MDozOCswMzowMN3pZPAAAAAldEVYdGRhdGU6bW9kaWZ5ADIw
MjEtMDctMDhUMTc6NDA6MzgrMDM6MDCstNxMAAAAAElFTkSuQmCC" />
</svg>
<a title="Tutorials, Java Tutorials,DevOps Tutorials,Spring Tutorial,SpringBoot Tutorials, Docker,Chef,Jenkins,Git,BitBucket,Bamboo,AWS,Kubernetes,Puppet,Ansible,Nagios." href="/">SatyaCodes</a></div><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></div><nav class="navigation">
        <ul><li class="navigation__item"><a href="/posts.html">AllPosts</a></li><li class="navigation__item"><a href="/tutorials.html">Tutorials</a></li><li class="navigation__item"><a href="/java.html">Java</a></li><li class="navigation__item"><a href="/devops.html">DevOps</a></li><li class="navigation__item"><a href="/books.html">Books</a></li><li class="navigation__item"><a href="/interview-questions.html">InterviewQ's</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li></ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class ="main"><div class="grid grid--reverse">

              <div class="col-aside d-print-none js-col-aside"><aside class="page__aside js-page-aside"><div class="toc-aside js-toc-root"></div></aside></div>

              <div class="col-main cell cell--auto"><!-- start custom main top snippet -->

<!-- end custom main top snippet --><article itemscope itemtype="http://schema.org/Article"><div class="article__header"><header><h1>Java - Interview Questions PART-1</h1></header></div><meta itemprop="headline" content="Java - Interview Questions PART-1"><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=Interview">Interview</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Nov 11, 2017</span>
            </li></ul></div><meta itemprop="author" content="Satya Kaveti"/><meta itemprop="datePublished" content="2017-11-11T00:00:00+00:00">
    <meta itemprop="keywords" content="Interview"><div class="js-article-content"><div class="layout--article"><!-- start custom article top snippet -->

<!-- end custom article top snippet --><div class="article__content" itemprop="articleBody"><h1 id="basics">Basics</h1>

<h2 id="what-is-a-strongly-typed-programming-language">What is a strongly typed programming language?</h2>
<p>In a strongly typed language compiler ensure type correctness, for example, you
<strong>can not store the number in String or vice-versa</strong>.</p>

<p>Java is a strongly typed language, that’s why you have different data types
Ex <strong>int, float, String, char, boolean etc.</strong></p>

<p>On the other hand, weakly typed language don’t enforce type checking at compile
time and they tree values based upon context. <strong>Python and Perl</strong> are two
popular example of weakly typed programming language, where you can store a
numeric string in number type.</p>

<h2 id="can-you-describe-three-different-kinds-of-testing-that-might-be-performed">Can you describe three different kinds of testing that might be performed?</h2>

<p><strong>Unit Testing, Integration Testing and Smoke Testing</strong>.</p>

<ul>
  <li>
    <p><strong>Unit testing</strong> is used to test individual units to verify whether they are
working as expected</p>
  </li>
  <li>
    <p><strong>Integration Testing</strong> is done to verify whether individually tested module
can work together or not</p>
  </li>
  <li>
    <p><strong>Smoke Testing</strong> is a way to test whether most common functionality of
software is working properly or not e.g. in a flight booking website, you
should be able to book, cancel or change flights.</p>
  </li>
</ul>

<h2 id="what-is-the-difference-between-iteration-and-recursion-detailed-answer">What is the difference between iteration and recursion? (<a href="http://javarevisited.blogspot.sg/2012/12/recursion-in-java-with-example-programming.html">detailed answer</a>)</h2>

<ul>
  <li>
    <p><strong>Iteration</strong> uses a loop to perform the same step again and again.</p>
  </li>
  <li>
    <p><strong>Recursion</strong> calls the same method itself to do the repetitive task</p>
  </li>
</ul>

<h2 id="what-is-test-driven-development">What is test-driven development?</h2>

<p>Test driven is one of the popular development methodologies in which tests are
written before writing any function code. In fact, test drives the structure of
your program. Purists never wrote a single line of application code without
writing a test for that. It greatly improve code quality and often attributed as
a quality of rockstar developers.</p>

<h2 id="how-do-you-find-a-running-java-process-on-unix">How do you find a running Java process on UNIX?</h2>

<p>You can use the combination of <strong>‘ps’ and ‘grep’</strong> command to find any process
running on UNIX machine. ps -e will list every process i.e. process from all
user not just you and  ps -f will give you full details including PID, which
will be required if you want to investigate more or would like to kill this
process using kill command.</p>

<table>
  <tbody>
    <tr>
      <td>ps -ef</td>
      <td>grep “java”</td>
    </tr>
  </tbody>
</table>

<h2 id="difference-between-weakreference-vs-softreference-vs-phantomreference-vs-strong-reference-in-garbage-collection">Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Garbage Collection?</h2>

<p>there are four kind of reference in Java :</p>

<ol>
  <li>
    <p>Strong reference</p>
  </li>
  <li>
    <p>Weak Reference</p>
  </li>
  <li>
    <p>Soft Reference</p>
  </li>
  <li>
    <p>Phantom Reference</p>
  </li>
</ol>

<h1 id="jvm-internals-and-garbage-collection">JVM Internals and Garbage Collection</h1>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Zoo</span> <span class="o">{</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

 <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p>The program correctly identifies the first two -words” as the arguments. Spaces
are used to separate the arguments. If you want spaces inside an argument, you
need to use quotes as in this example:</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span><span class="w"> </span><span class="n">javac</span><span class="w"> </span><span class="nx">Zoo.java</span><span class="w">
</span><span class="err">$</span><span class="w"> </span><span class="n">java</span><span class="w"> </span><span class="nx">Zoo</span><span class="w"> </span><span class="s2">"San Diego"</span><span class="w"> </span><span class="nx">Zoo</span><span class="w">
</span></code></pre></div></div>

<p>All command-line arguments are treated as String objects, even if they represent
another data type:</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span><span class="w"> </span><span class="n">javac</span><span class="w"> </span><span class="nx">Zoo.java</span><span class="w">

</span><span class="err">$</span><span class="w"> </span><span class="n">java</span><span class="w"> </span><span class="nx">Zoo</span><span class="w"> </span><span class="nx">Zoo</span><span class="w"> </span><span class="nx">2</span><span class="w">
</span></code></pre></div></div>

<p>Finally, what happens if you don’t pass in enough arguments?</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span><span class="w"> </span><span class="n">javac</span><span class="w"> </span><span class="nx">Zoo.java</span><span class="w">

</span><span class="err">$</span><span class="w"> </span><span class="n">java</span><span class="w"> </span><span class="nx">Zoo</span><span class="w"> </span><span class="nx">Zoo</span><span class="w">

</span><span class="n">Zoo</span><span class="w">
</span></code></pre></div></div>

<p><strong>Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 1 at
mainmethod.Zoo.main(Zoo.java:7)</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Conflicts</span> <span class="o">{</span>

<span class="nc">Date</span> <span class="n">date</span><span class="o">;</span>

<span class="c1">// some more code</span>

<span class="o">}</span>
</code></pre></div></div>

<p>The answer should be easy by now. You can write either import java.util.*; or
import java.util.Date;. The tricky cases come about when other imports are
present:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.sql.*</span><span class="o">;</span> <span class="c1">// DOES NOT COMPILE</span>

<span class="kn">import</span> <span class="nn">java.util.Date</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.sql.*</span><span class="o">;</span>
</code></pre></div></div>

<p>If you explicitly import a class name, it takes precedence over any wildcards
present.</p>

<p>■ octal (digits 0–7), which uses the number 0 as a prefix—for example, 017</p>

<p>■ hexadecimal (digits 0–9 and letters A–F), which uses the number 0 followed by
x or X as a prefix—for example, 0xFF</p>

<p>■ binary (digits 0–1), which uses the number 0 followed by b or B as a
prefix—for example, 0b10</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">56</span><span class="o">);</span> <span class="c1">// 56</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mb">0b11</span><span class="o">);</span> <span class="c1">// 3</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mo">017</span><span class="o">);</span> <span class="c1">// 15</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mh">0x1F</span><span class="o">);</span> <span class="c1">// 31</span>
</code></pre></div></div>
<p><br /></p>

<p>added in Java 7. You can have underscores in numbers to make them easier to
read:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">million1</span> <span class="o">=</span> <span class="mi">1000000</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">million2</span> <span class="o">=</span> <span class="mi">1_000_000</span><span class="o">;</span>

<span class="kt">double</span> <span class="n">notAtStart</span> <span class="o">=</span> <span class="n">_1000</span><span class="o">.</span><span class="mo">00</span><span class="o">;</span> <span class="c1">// DOES NOT COMPILE</span>

<span class="kt">double</span> <span class="n">notAtEnd</span> <span class="o">=</span> <span class="mf">1000.00</span><span class="n">_</span><span class="o">;</span> <span class="c1">// DOES NOT COMPILE</span>

<span class="kt">double</span> <span class="n">notByDecimal</span> <span class="o">=</span> <span class="mi">1000</span><span class="n">_</span><span class="o">.</span><span class="mo">00</span><span class="o">;</span> <span class="c1">// DOES NOT COMPILE</span>

<span class="kt">double</span> <span class="n">annoyingButLegal</span> <span class="o">=</span> <span class="mf">1_00_0.0_0</span><span class="o">;</span> <span class="c1">// this one compiles</span>
</code></pre></div></div>

<h2 id="declaring-multiple-variables"><strong>Declaring Multiple Variables</strong></h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i1</span><span class="o">,</span> <span class="n">i2</span><span class="o">,</span> <span class="n">i3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</code></pre></div></div>

<p>As you should expect, three variables were declared: i1, i2, and i3. However,
only one of those values was initialized: i3. The other two remain declared but
not yet initialized.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="nc">String</span> <span class="n">value</span><span class="o">;</span> <span class="c1">// DOES NOT COMPILE</span>
</code></pre></div></div>

<p>This code doesn’t compile because it tries to declare multiple variables of
different types in the same statement.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">d1</span><span class="o">,</span> <span class="kt">double</span> <span class="n">d2</span><span class="o">;</span> <span class="c1">// DOES NOT COMPILE</span>
</code></pre></div></div>

<p>If you want to declare multiple variables in the same statement, they must share
the same type declaration and not repeat it. double d1, d2; would have been
legal.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="n">b1</span><span class="o">,</span> <span class="n">b2</span><span class="o">;</span>

<span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"1"</span><span class="o">,</span> <span class="n">s2</span><span class="o">;</span>

<span class="kt">double</span> <span class="n">d1</span><span class="o">,</span> <span class="kt">double</span> <span class="n">d2</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">i1</span><span class="o">;</span> <span class="kt">int</span> <span class="n">i2</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">i3</span><span class="o">;</span> <span class="n">i4</span><span class="o">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>The first statement is legal. It declares two variables without initializing
them.</p>
  </li>
  <li>second statement is also legal. It declares two variables and initializes
only one of them.</li>
  <li>
    <p>The third statement is not legal. Variables d1 and d2 are the
same type &amp; breaks between them.</p>
  </li>
  <li>The fourth statement is legal.The fifth statement is not legal.The second one is
not a valid declaration because it omits the type.</li>
</ul>

<h1 id="garbage-collection"><strong>Garbage Collection</strong></h1>

<p>The methods to request JVM to run Garbage Collector</p>

<p><strong>System.gc()</strong> : ‘System’ class contains a static ‘gc’ method for requesting
JVM to run Garbage Collector.</p>

<p><strong>Runtime.getRuntime().gc()</strong> : gc() method available in Runtime class is an
instance method.</p>

<p><br /></p>

<h3 id="1nullifying-the-reference-variable"><strong>1.Nullifying the reference Variable</strong></h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
<span class="nc">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
<span class="c1">//No Object eligible for Garbage Collector</span>

<span class="n">s1</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="c1">//One Object eligible for Garbage Collector</span>

<span class="n">s2</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="nc">Both</span> <span class="nc">Objects</span> <span class="n">eligible</span> <span class="k">for</span> <span class="nc">Garbage</span> <span class="nc">Collector</span>
</code></pre></div></div>

<h3 id="2reassigning-the-reference-variable"><strong>2.Reassigning the reference Variable</strong></h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
<span class="nc">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">s2</span><span class="o">;</span>
<span class="c1">//One Object eligible for Garbage Collector</span>
</code></pre></div></div>

<h3 id="3the-objects-created-inside-a-method"><strong>3.The Objects Created inside a method</strong></h3>

<p>The objects which are created in a method are by default eligible for Garbage
Collector once the</p>

<p>method completes</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">:</span> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Scope</span> <span class="o">{</span>

<span class="mi">2</span><span class="o">:</span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

<span class="mi">3</span><span class="o">:</span> <span class="nc">String</span> <span class="n">one</span><span class="o">,</span> <span class="n">two</span><span class="o">;</span>

<span class="mi">4</span><span class="o">:</span> <span class="n">one</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span>
<span class="mi">5</span><span class="o">:</span> <span class="n">two</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"b"</span><span class="o">);</span>

<span class="mi">6</span><span class="o">:</span> <span class="n">one</span> <span class="o">=</span> <span class="n">two</span><span class="o">;</span>

<span class="mi">7</span><span class="o">:</span> <span class="nc">String</span> <span class="n">three</span> <span class="o">=</span> <span class="n">one</span><span class="o">;</span>
<span class="mi">8</span><span class="o">:</span> <span class="n">one</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

<span class="mi">9</span><span class="o">:</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div></div>

<h3 id="difference-between-path-and-classpath-in-java"><strong>Difference between PATH and Classpath in Java?</strong></h3>
<p>Answer : PATH is a environment variable in Java which is used to help Java
program to compile and run.To set the PATH variable we have to
include JDK_HOME/bin directory in PATH environment variable and also we cannot
override this variable.</p>

<p>On the other hand,  <a href="http://java67.blogspot.sg/2012/08/what-is-path-and-classpath-in-java-difference.html">ClassPath
variable</a> is
used by class loader to locate and load compiled Java codes stored in .class
file. We you want to run JUnit from any where from cmdline you eed to add
Junit.jar in class path.</p>

<h2 id="difference-between-interpreter-and-jit-compiler">Difference between interpreter and JIT compiler?</h2>

<p>The interpreter interprets the bytecode line by line and executes it
sequentially. It results in poor performance. JIT compiler add optimization to
this process by analyzing the code in blocks and then prepare more optimized
machine code.</p>

<h2 id="difference-between-jre-and-jvm">Difference between JRE and JVM?</h2>

<p>JVM is the specification for runtime environment which executes the Java
applications. Hotspot JVM is such one implementation of the specification. It
loads the class files and uses interpreter and JIT compiler to convert bytecode
into machine code and execute it.</p>

<h2 id="difference-between-jvm--hotspot-vm">Difference Between JVM &amp; HotSpot VM</h2>

<p><strong>JVM :</strong> is a Specification, <strong>HotSpot</strong> : is a implementation of JVM.</p>

<p><a href="http://en.wikipedia.org/wiki/HotSpot">HotSpot</a>** **is an implementation of the
JVM concept, originally developed by Sun and now owned by Oracle. There are
other implementations of the JVM specification,
like <a href="http://en.wikipedia.org/wiki/JRockit">JRockit</a>, <a href="http://en.wikipedia.org/wiki/IBM_J9">IBM
J9</a>, among many others.</p>

<p><strong>Is Java a pure object oriented language? (answer)</strong><br />
Java is not a pure object-oriented programming language e.g. There are many
things in Java which are not objects e.g. primitive data types
e.g. boolean, char, short, int, long, float, double, different kinds of
arithmetic, logical and bitwise operator e.g. +, -. *, /, &amp;&amp;, || etc. Few
pure OO languages are <strong>Smalltalk</strong> and <strong>Eiffel</strong>.</p>

<p><strong>There are seven qualities to be satisfied for a programming language to be
pure Object Oriented. They are:</strong><br />
<strong>1.</strong><a href="http://java67.blogspot.sg/2012/08/difference-between-abstraction-and-encapsulation-java-oops.html">Encapsulation/Data
Hiding</a><br />
<strong>2.</strong><a href="http://java67.blogspot.sg/2012/08/what-is-inheritance-in-java-oops-programming-example.html">Inheritance</a><br />
<strong>3.</strong><a href="http://java67.blogspot.sg/2012/10/difference-between-polymorphism-overloading-overriding-java.html">Polymorphism</a><br />
<strong>4.</strong><a href="http://java67.blogspot.sg/2012/09/what-is-difference-between-interface-abstract-class-java.html">Abstraction</a><br />
<strong>5. All predefined types are objects</strong><br />
<strong>6. All operations are performed by sending messages to objects</strong><br />
<strong>7. All user defined types are objects</strong></p>

<h2 id="how-does-weakhashmap-work">How does WeakHashMap work?</h2>

<p>WeakHashMap operates like a normal HashMap but uses WeakReference for keys.
Meaning if the key object does not devise any reference then both key/value
mapping will become appropriate for garbage collection.</p>

<h2 id="how-do-you-locate-memory-usage-from-a-java-program">How do you locate memory usage from a Java program?</h2>

<p>Answer: You can use memory related methods from <strong>java.lang.Runtime</strong> class to
get the free memory, total memory and maximum heap memory in Java.</p>

<table>
  <thead>
    <tr>
      <th><strong>public static Runtime getRuntime()</strong></th>
      <th>returns the instance of Runtime class.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>public void exit(int status)</strong></td>
      <td>terminates the current virtual machine.</td>
    </tr>
    <tr>
      <td><strong>public void addShutdownHook(Thread hook)</strong></td>
      <td>registers new hook thread.</td>
    </tr>
    <tr>
      <td><strong>public Process exec(String command)</strong></td>
      <td>executes given command in a separate process.</td>
    </tr>
    <tr>
      <td><strong>public int availableProcessors()</strong></td>
      <td>returns no. of available processors.</td>
    </tr>
    <tr>
      <td><strong>public long freeMemory()</strong></td>
      <td>returns amount of free memory in JVM.</td>
    </tr>
    <tr>
      <td><strong>public long totalMemory()</strong></td>
      <td>returns amount of total memory in JVM.</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestApp</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">Runtime</span> <span class="n">r</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">();</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">totalMemory</span><span class="o">());</span> <span class="c1">//16252928</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">freeMemory</span><span class="o">());</span> <span class="c1">//15709576</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">availableProcessors</span><span class="o">());</span><span class="c1">//24</span>
 <span class="n">r</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="what-is-classloader-in-java">What is ClassLoader in Java?</h2>

<p>When a Java program is converted into <strong>.class</strong> file by Java compiler which is
collection of byte code. <strong>ClassLoader</strong> is responsible to load that class file
from file system, network or any other location</p>

<ul>
  <li>
    <p>Bootstrap ClassLoader - <strong>JRE/lib/rt.jar</strong></p>
  </li>
  <li>
    <p>Extension ClassLoader - <strong>JRE/lib/ext</strong> or any directory denoted
by java.ext.dirs</p>
  </li>
  <li>
    <p>Application ClassLoader - <strong>CLASSPATH environment
variable, -classpath or -cp option, Class-Path attribute of Manifest
inside **<a href="http://javarevisited.blogspot.sg/2012/03/how-to-create-and-execute-jar-file-in.html">JAR
file</a></strong>.**</p>
  </li>
</ul>

<p><img src="media/3438307fb91a1358228d96022b257978.png" alt="Class Loader in Java BootStrap Extension and Application" /></p>

<p>Class Loader in Java BootStrap Extension and Application</p>

<h2 id="java-heap-memory"><br />Java heap memory</h2>

<p>When a Java program started Java Virtual Machine gets some memory from Operating
System.</p>

<p>whenever we create an object using new operator or by any another means the
object is allocated memory from Heap and When object dies or garbage collected,
memory goes back to Heap space.</p>

<p><strong>How to increase heap size in Java</strong></p>

<p>Default size of Heap space in Java is 128MB on most of 32 bit
Sun’s <a href="http://javarevisited.blogspot.sg/2011/12/jre-jvm-jdk-jit-in-java-programming.html">JVM</a> but
its highly varies from JVM to JVM. change size of heap space by using JVM
<strong>options -Xms and -Xmx</strong>. Xms denotes starting size of Heap while -Xmx denotes
maximum size of Heap in Java.</p>

<p><strong>Java Heap and Garbage Collection</strong></p>

<p>As we know objects are created inside heap memory and Garbage Collection is a
process which removes dead objects from Java Heap space and returns memory back
to Heap in Java.</p>

<p>For the sake of Garbage collection Heap is divided into three main regions named
as <strong>New Generation, Old Generation, and Perm space</strong></p>

<p><img src="media/91fb80148afafb44921c49d394908e9f.png" alt="Screen Clipping" /></p>

<p>Screen Clipping</p>

<ul>
  <li>
    <p><strong>New Generation</strong> of Java Heap is part of Java Heap memory where a newly
created object is stored,</p>
  </li>
  <li>
    <p><strong>Old Generation</strong> During the course of application many objects created and
died but those remain live they got moved to Old Generation by Java Garbage
collector thread</p>
  </li>
  <li>
    <p><strong>Perm space</strong> of Java Heap is where JVM stores Metadata about classes and
methods, String pool and Class level details.</p>
  </li>
  <li>
    <p>Perm Gen stands for permanent generation which holds the meta-data
information about the classes.</p>
  </li>
  <li>
    <p>Suppose if you create a class name A, it’s instance variable will be stored
in heap memory and class A along with static classloaders will be stored in
permanent generation.</p>
  </li>
  <li>
    <p>Garbage collectors will find it difficult to clear or free the memory space
stored in permanent generation memory. Hence it is always recommended to
keep the permgen memory settings to the advisable limit.</p>
  </li>
  <li>
    <p>JAVA8 has introduced the concept called meta-space generation, hence permgen
is no longer needed when you use jdk 1.8 versions.</p>
  </li>
</ul>

<p><img src="media/dd4d248bbfe25b26bc538bb566ef4a30.png" alt="" /></p>

<p><strong>Eden Space</strong> – New Objects are Created</p>

<p><strong>Survivor Space –</strong> Once Eden space is full, Minor thread try to clear the
Space, the objects which are survived by GC will be placed in Survivor space.</p>

<p><strong>Old Gen</strong> – Objects which are survived from a long time, let say 16 Cycles (GC
cycle Threshold) of Minor Garbage Collector, those objects moved to Old Gen. The
Old Gen space finally collected by Main Garbage collector.</p>

<p>Finally, Minor Garbage collector will runs only on Young Gen, Main Garbage
Collector will run on whole heap space</p>

<p><img src="media/e5880dbcd8151159f64495c713f0b64c.png" alt="" /></p>

<p><img src="media/c717df6f72e8aed78d9cb50816635ab2.png" alt="" /></p>

<p><img src="media/5d7370992d2359426dca78da42ba5c61.png" alt="" /></p>

<p><img src="media/f528096d20b94321efb19c4b5af8416f.png" alt="" /></p>

<p><img src="media/3c44dd271c41ffd5073584c704e71293.png" alt="" /></p>

<p><img src="media/881a459de153b986a6e010d48aee63a0.png" alt="" /></p>

<p><img src="media/23b68a2fe7b0056ba1f50ec96cdded1e.png" alt="" /></p>

<h2 id="does-garbage-collection-occur-in-permanent-generation-space-in-jvm">Does Garbage collection occur in permanent generation space in JVM?</h2>

<p><strong>YES, Garbage Collection occur in PermGen space as well. and if PermGen space
is full or cross a threshold, it can trigger Full GC(Main Thread).</strong> If you look
at output of GC you will find that PermGen space is also garbage collected. This
is why correct sizing of PermGen space is important to avoid frequent full GC.
You can control size of PermGen space by <a href="http://javarevisited.blogspot.sg/2011/11/hotspot-jvm-options-java-examples.html">JVM
options</a> -XX:PermGenSize and
-XX:MaxPermGenSize.</p>

<h2 id="types-of-garbage-collectors">Types of Garbage Collectors</h2>

<p>When an object is no longer used, the garbage collector reclaims the underlying
memory and reuses it for future object allocation. This means there is no
explicit deletion and no memory is given back to the operating system.</p>

<p><img src="media/a308363c6d4b25d52455a7ce455ffaca.png" alt="" /></p>

<p><img src="media/d02a55f23a2e203b785f000cfd7ef742.png" alt="" /></p>

<p>Java has <strong>four types of garbage collectors</strong>,</p>

<ul>
  <li>
    <p><a href="https://javapapers.com/java/types-of-java-garbage-collectors/#serial-garbage-collector">Serial Garbage
Collector</a></p>
  </li>
  <li>
    <p><a href="https://javapapers.com/java/types-of-java-garbage-collectors/#parallel-garbage-collector">Parallel Garbage
Collector</a></p>
  </li>
  <li>
    <p><a href="https://javapapers.com/java/types-of-java-garbage-collectors/#cms-garbage-collector">CMS Garbage
Collector</a></p>
  </li>
  <li>
    <p><a href="https://javapapers.com/java/types-of-java-garbage-collectors/#g1-garbage-collector">G1 Garbage
Collector</a></p>
  </li>
</ul>

<p>Each of these four types has its own advantages and disadvantages. Most
importantly, we the programmers can choose the type of garbage collector to be
used by the JVM. We can choose them by passing the choice as JVM argument</p>

<h4 id="1-serial-garbage-collector">1. Serial Garbage Collector</h4>

<ul>
  <li>
    <p>It is designed for <strong>the single-threaded environments</strong>.</p>
  </li>
  <li>
    <p>It <strong>uses just a single thread for garbage collection</strong>.</p>
  </li>
  <li>
    <p>It freezes(stops) all the application threads while performing garbage
collection.</p>
  </li>
  <li>
    <p>it may not be suitable for a server environment. It is best suited for
simple command-line programs.</p>
  </li>
</ul>

<p>Turn on the **-XX:+UseSerialGC **JVM argument to use the serial garbage
collector.</p>

<h4 id="2-parallel-garbage-collector">2. Parallel Garbage Collector</h4>

<ul>
  <li>
    <p>It is the <strong>default garbage</strong> collector of the JVM.</p>
  </li>
  <li>
    <p>It uses <strong>multiple threads for garbage collection</strong>.</p>
  </li>
  <li>
    <p>Similar to serial garbage collector this also freezes(siops) all the
application threads while performing garbage collection.</p>
  </li>
</ul>

<h4 id="3-concurrent-garbage-collector">3. Concurrent Garbage Collector</h4>

<ul>
  <li>
    <p>Concurrent Mark Sweep (CMS) garbage collector uses multiple threads to scan
the heap memory to mark instances for eviction and then sweep the marked
instances.</p>
  </li>
  <li>
    <p>It runs along with our Application. Uses multiple cores(cpus) to run
multiple GC’s concurrently.</p>
  </li>
  <li>
    <p>Here your application won’t pass/stop</p>
  </li>
</ul>

<p>Turn on the <strong>XX:+USeParNewGC</strong> JVM argument to use the CMS garbage collector.</p>

<p><img src="media/8c9bda99fa0f542b1e718efcca19fe64.png" alt="" /></p>

<h4 id="4-g1-garbage-collector">4. G1 Garbage Collector</h4>

<ul>
  <li>
    <p>G1 <strong>garbage collector is used for large heap memory areas.</strong></p>
  </li>
  <li>
    <p>It separates the heap memory into regions and does collection within them in
parallel.</p>
  </li>
  <li>
    <p>G1 also does compacts the free heap space on the go just after reclaiming
the memory.</p>
  </li>
  <li>
    <p>G1 collector prioritizes the region based on most garbage first.</p>
  </li>
</ul>

<p>Turn on <strong>the –XX:+UseG1GC JVM</strong> argument to use the G1 garbage collector.</p>

<p><img src="media/24649538831db226d2f6a4f876047896.png" alt="" /></p>

<p><a href="https://www.youtube.com/watch?v=UnaNQgzw4zY">https://www.youtube.com/watch?v=UnaNQgzw4zY</a></p>

<p><img src="media/33acaef014ef9ffad6c99140924a0c18.png" alt="" /></p>

<p><strong>Java 8 Improvement</strong></p>

<p>Turn on the <strong>-XX:+UseStringDeduplication **JVM argument while using G1 garbage
collector</strong>. This optimizes the heap memory by removing duplicate String values
to a single char[] array**. This option is introduced in <a href="https://javapapers.com/java/java-8-features/">Java
8</a> u 20.</p>

<p>Given all the above four types of Java garbage collectors, which one to use
depends on the application scenario, hardware available and the throughput
requirements.</p>

<h4 id="garbage-collection-jvm-options">Garbage Collection JVM Options</h4>

<p><strong>Type of Garbage Collector to run</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>Option</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>-XX:+UseSerialGC</strong></td>
      <td><strong>Serial Garbage Collector</strong></td>
    </tr>
    <tr>
      <td><strong>-XX:+UseParallelGC</strong></td>
      <td><strong>Parallel Garbage Collector</strong></td>
    </tr>
    <tr>
      <td><strong>-XX:+UseConcMarkSweepGC</strong></td>
      <td><strong>CMS Garbage Collector</strong></td>
    </tr>
    <tr>
      <td><strong>-XX:ParallelCMSThreads=</strong></td>
      <td><strong>CMS Collector – number of threads to use</strong></td>
    </tr>
    <tr>
      <td><strong>-XX:+UseG1GC</strong></td>
      <td><strong>G1 Gargbage Collector</strong></td>
    </tr>
  </tbody>
</table>

<p><strong>GC Optimization Options</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>Option</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>-Xms</strong></td>
      <td><strong>Initial heap memory size</strong></td>
    </tr>
    <tr>
      <td><strong>-Xmx</strong></td>
      <td><strong>Maximum heap memory size</strong></td>
    </tr>
    <tr>
      <td><strong>-Xmn</strong></td>
      <td><strong>Size of Young Generation</strong></td>
    </tr>
    <tr>
      <td><strong>-XX:PermSize</strong></td>
      <td><strong>Initial Permanent Generation size</strong></td>
    </tr>
    <tr>
      <td><strong>-XX:MaxPermSize</strong></td>
      <td><strong>Maximum Permanent Generation size</strong></td>
    </tr>
  </tbody>
</table>

<p><strong>Garbage collection is performed by a daemon thread called Garbage
Collector(GC). This thread calls the finalize() method before object is garbage
collected.</strong></p>

<p><strong>The Garbage collector of JVM collects only those objects that are created by
new keyword. So if you have created any object without new, you can use finalize
method to perform cleanup processing (destroying remaining objects).</strong></p>

<p><strong>Neither finalization nor garbage collection is guaranteed.</strong></p>

<h2 id="how-string-literals-garbage-collected">How String Literals Garbage Collected?</h2>

<p>Strings created without using the new keyword are <strong>NEVER garbage collected</strong>.
Even if there are no references to them. All such strings go into the String
pool and just sit there till the whole program ends (ie. the JVM).The String
Const. pool cleaned up when the class is unloaded by the JVM.</p>

<h2 id="how-to-you-monitor-garbage-collection-activities">How to you monitor garbage collection activities?</h2>
<p>just to check whether candidate has ever monitored GC activities or not. You can
monitor garbage collection activities either offline or real-time. You can use
tools like <strong>JConsole</strong> and <strong>VisualVM</strong> VM with its Visual GC plug-in to
monitor real time garbage collection activities and memory status of JVM or you
can redirect Garbage collection output to a log file for offline analysis by
using -XlogGC=&lt;PATH&gt; JVM parameter. Anyway you should always enable GC
options like -XX:PrintGCDetails -X:verboseGCand -XX:PrintGCTimeStamps as it
doesn’t impact <a href="http://javarevisited.blogspot.sg/2012/01/improve-performance-java-database.html">application
performance</a> much
but provide useful states for performance monitoring.</p>

<p><img src="media/88015acfb687957254ed8e87e568c4b1.png" alt="" /></p>

<p><img src="media/62a8fdcbbc5c6067acd698eb5210c766.png" alt="" /></p>

<h2 id="how-do-you-identify-minor-and-major-garbage-collection-in-java">How do you identify minor and major garbage collection in Java?</h2>

<ul>
  <li>
    <p>Minor collection prints <strong>GC</strong> if garbage
collection <a href="http://javarevisited.blogspot.sg/2011/05/top-10-tips-on-logging-in-java.html">logging</a> is
enable using <strong>–verbose:gc or -XX:PrintGCDetails</strong></p>
  </li>
  <li>
    <p>Major collection prints <strong>-Full GC”.</strong></p>
  </li>
</ul>

<h2 id="how-to-generate-gc-log-file">How to Generate GC Log File?</h2>

<p>In order to understand the GC log, you first need to generate one. Passing the
following system properties to your JVM would generate GC logs</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="nc">PrintGCDetails</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="nc">PrintGCDateStamps</span> <span class="err">–</span><span class="nl">Xloggc:D:</span><span class="c1">//gc.log</span>
</code></pre></div></div>

<p>Or add visual-gc plugin to visualVM</p>

<h2 id="what-security-model-used-by-java">What Security model used by Java?</h2>

<p><strong>Sandbox</strong>. The sandbox security model makes it easier to work with software
that comes from sources you don’t fully trust.</p>

<h2 id="what-is--phontom-memory">What is -Phontom” memory</h2>

<p><strong>A memory that doesn’t exist in reality.</strong></p>

<p>A phantom reference lets you do final touch up closing on an object, even after
it has been declared dead — no longer referenced by any live object.</p>

<p>During garbage collection, these reference objects are handled specially; that
is, the referent field is not traced during the marking phase. When marking is
complete, the references are processed in sequence for sweeping phase.</p>

<ol>
  <li>
    <p>Soft</p>
  </li>
  <li>
    <p>Weak</p>
  </li>
  <li>
    <p>Final</p>
  </li>
  <li>
    <p>Phantom</p>
  </li>
</ol>

<h2 id="how-many-jvms-can-run-on-a-single-machine">How many JVMs can run on a single machine?</h2>

<p><strong>Multiple</strong>, yes You can run as many JVMs as you can fit on your disk and in
memory :)</p>

<p>Whenever you start a Java application, you’re first starting the JVM and then
telling it which application to run. The answer to “which JVM” is simply: The
JVM that you loaded the application with! for example, for execution of applets
a separate JVM may exist and another JVM can be started by the User for
execution of Java Byte Code, on a single machine.</p>

<h2 id="difference-between-object-oriented-and-object-based-language">Difference between Object Oriented and Object Based language</h2>

<p><strong>Object Oriented Languages</strong></p>

<ul>
  <li>
    <p>Object Oriented Languages supports all the features of Oops Abstraction,
Encapsulation, Polymorhisum, Inhertance.</p>
  </li>
  <li>
    <p>C#, Java, VB. Net are the examples of object oriented languages.</p>
  </li>
</ul>

<p><strong>Object Based Languages</strong></p>

<ul>
  <li>
    <p>Object based languages does not support inheritance or, polymorphism or,
both.</p>
  </li>
  <li>
    <p>Object based languages does not support built-in objects.</p>
  </li>
  <li>
    <p>Javascript, VB are the examples of object bases languages.</p>
  </li>
</ul>

<h2 id="if-i-dont-provide-any-arguments-on-commandline-then-string-array-of-main-is-empty-or-null">If I don’t provide any arguments on commandline, then String array of main() is Empty or NULL?</h2>

<p>It’s Empty, but not Null.</p>

<h2 id="is-main-method-compulsory-in-java">Is main method compulsory in Java?</h2>

<p>The answer to this question depends on version of java you are using. <strong>Prior to
JDK 5, main method was not mandatory in a java program.</strong></p>

<ul>
  <li>
    <p>You could write your full code under <a href="https://www.geeksforgeeks.org/g-fact-79/">static
block</a> and it ran normally.</p>
  </li>
  <li>
    <p>The static block is first executed as soon as the class is loaded before the
main();</p>
  </li>
</ul>

<p>Read
more: <a href="https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html#ixzz5fwmNzRHE">https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html#ixzz5fwmNzRHE</a></p>

<p>Read
more: <a href="https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html#ixzz5fwm9nzDa">https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html#ixzz5fwm9nzDa</a></p>

<h1 id="data-types">Data Types</h1>

<h2 id="how-do-you-convert-bytes-to-string">How do you convert bytes to String?</h2>

<p>you can convert bytes to the string using string constructor which
accepts byte[], just make sure that right character encoding otherwise
platform’s default character encoding will be used which may or may not be same.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div>

<h2 id="how-do-you-convert-bytes-to-long-in-java"><strong>How do you convert bytes to long in Java</strong></h2>
<p>The byte takes 1 byte of memory and long takes 8 bytes of memory. Assignment 1
byte value to 8 bytes is done implicitly by the JVM.</p>

<p><strong>byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double</strong></p>

<p>The left-side value can be assigned to any right-side value and is done
implicitly. The reverse requires explicit casting.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span> <span class="n">b1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>  <span class="c1">// 1 byte  </span>
<span class="kt">long</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">b1</span><span class="o">;</span>  <span class="c1">//  one byte to 8 bytes, assigned implicitly</span>
</code></pre></div></div>

<h2 id="is--operator-is-thread-safe-in-java">Is ++ operator is thread-safe in Java?</h2>

<p>No it’s not a thread safe operator because its involve multiple instructions
like reading a value, incriminating it and storing it back into memory which can
be overlapped between multiple threads.</p>

<h2 id="volatile-vs-atomic-variables">Volatile Vs Atomic variables?</h2>

<p>Volatile Example</p>

<p><img src="media/b59a4e041451824eb295e590ec74bed3.png" alt="" /></p>

<p><img src="media/5902f9fbd937fdce66c2cb7b0bbfdc83.png" alt="" /></p>

<p><img src="media/9e82ba6bea4a8f122795d0d94898f961.png" alt="" /></p>

<ul>
  <li>
    <p>If <strong>writerThread()</strong> is executed by one thread &amp; <strong>readerThread()</strong> is
executed by another thread</p>
  </li>
  <li>
    <p>the ‘x’ value is different for two threads because they are reading value
from their LocalCache.</p>
  </li>
  <li>
    <p>Here the changes of X value is not <strong>visible</strong> globally (Field Visibility),
because they are changing in <strong>LocalCache.</strong></p>
  </li>
</ul>

<p><strong>To avoid this, we need to use ‘volatile’ keyword for fields.</strong></p>

<ul>
  <li>
    <p>The Java <strong>volatile</strong> keyword is used to mark a Java variable as <strong>“being
stored in main memory</strong>”.</p>
  </li>
  <li>
    <p>that means, every <strong>read</strong> of a volatile variable will <strong>be read from the
main memory(Shared Memory)</strong>, and not from the CPU cache</p>
  </li>
  <li>
    <p><strong>every write</strong> to a volatile variable will be <strong>written to main memory</strong>,
and not just to the CPU cache.</p>
  </li>
</ul>

<p><img src="media/108c47392235feab85ea0d31a5798264.png" alt="" /></p>

<ul>
  <li>
    <p>In the above diagram two threads t1, t2 are trying to change the value of
flag.</p>
  </li>
  <li>
    <p>If Thread1 changes value flag=false, then it will flush(push) the changes
from LocalCache to SharedCache and it will refresh the all Thread
LocalCaches with updated value.</p>
  </li>
  <li>
    <p>If Thread 2 is trying to read, it will get updated value.</p>
  </li>
  <li>
    <p>Volatile solves the visibility problem, where Only one operation is perform</p>
  </li>
</ul>

<h3 id="amtomic-problem">Amtomic Problem</h3>

<p>Atomic - forming a single irreducible unit or component in a larger system.</p>

<p>Increment (++) is an <strong>Compound Operation(multiple). AtomicVaribles</strong> makes
compound operations as <strong>Atomic(Single)</strong></p>

<p><img src="media/93c1ee6fcabace8d14ab3f5580ab05d1.png" alt="" /></p>

<p><img src="media/0aaacf326e63502204b2c122aca05a21.png" alt="" /></p>

<p>We can solve this problem using Synchronization</p>

<p><img src="media/dc3656580c87f2a3da159e0be12ecc99.png" alt="" /></p>

<p>Another Way using Atomic Variables</p>

<p><img src="media/a72224f177af3dcd43c1e4fe2e71f5f1.png" alt="" /></p>

<p><img src="media/f2f84e27927df3a608c5425081f109b8.png" alt="" /></p>

<h2 id="atomic-varibles">Atomic Varibles</h2>

<p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html">java.util.concurrent.atomic</a> package
defines classes that support atomic operations on single variables. All classes
have <strong>get and set methods</strong> that work like reads and writes
on volatile variables.</p>

<p>We have following Atomic classes</p>

<ul>
  <li>
    <p>AtomicInteger</p>
  </li>
  <li>
    <p>AtomicLong</p>
  </li>
  <li>
    <p>AtomicBoolean</p>
  </li>
  <li>
    <p>AtomicReference</p>
  </li>
  <li>
    <p>AtomicIntegerArray</p>
  </li>
  <li>
    <p>AtomicLongArray</p>
  </li>
  <li>
    <p>AtomicReferenceArray</p>
  </li>
</ul>

<p>Common methods</p>

<ul>
  <li>
    <p><strong>incrementAndGet()</strong>: Atomically increments by one the current value.</p>
  </li>
  <li>
    <p><strong>decrementAndGet()</strong>: Atomically decrements by one the current value.</p>
  </li>
  <li>
    <p><strong>addAndGet(int delta)</strong>: Atomically adds the given value to the current
value.</p>
  </li>
  <li>
    <p><strong>compareAndSet(int expect, int update):</strong> Atomically sets the value to the
given updated value if the current value == the expected value.</p>
  </li>
  <li>
    <p><strong>getAndAdd(int delta):</strong> Atomically adds the given value to the current
value.</p>
  </li>
  <li>
    <p><strong>set(int newValue):</strong> Sets to the given value.</p>
  </li>
</ul>

<h2 id="what-will-this-return-301--03-true-or-false">What will this return 3*0.1 == 0.3? true or false?</h2>

<p>Both are not equal, because floating point arithmetic has a certain precision.
Check the difference (a-b) it should be really small.</p>

<p><strong>In computer memory, floats and doubles are stored using</strong> <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE
754</a> <strong>standard format.</strong></p>

<ul>
  <li>f1 = (0.1+0.1+0.1….11 times) = 1.0999999999999999</li>
  <li>f2 = 0.1*11 = 1.1</li>
</ul>

<p>In <a href="https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html">BigDecimal</a> class,
<strong>you can specify the rounding mode</strong> and exact precision which you want to use.
<strong>Using the exact precision limit, rounding errors are mostly solved. Best part
is that BigDecimal numbers are immutable</strong> i.e. if you create a BigDecimal BD
with value -1.23”, that object will remain -1.23” and can never be changed. You
can use it’s .compareTo() method to compare to BigDecimal numbers</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testBdEquality</span><span class="o">()</span>
<span class="o">{</span>
     <span class="nc">BigDecimal</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"2.00"</span><span class="o">);</span>
     <span class="nc">BigDecimal</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"2.0"</span><span class="o">);</span>
 
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>           <span class="c1">// false</span>
 
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">);</span>   <span class="c1">// true</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="which-one-will-take-more-memory-an-int-or-integer-answer"><strong>Which one will take more memory, an int or Integer? (answer)</strong></h2>
<p>An Integer object will take more memory. an Integer is the an object and it
 store meta data overhead about the object and int is primitive type so its
takes less space.</p>

<h2 id="autoboxing-and-unboxing">Autoboxing and Unboxing?</h2>

<p>If a <strong>method(remember only method – not direct)</strong> requires Integer Object
value, we can directly pass primitive value without issue. Autoboxing will take
care about these.</p>

<p>We can also do direct initializations (1.8 V)</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span><span class="c1">// it will create Integer value of 10 using Autoboxing</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span><span class="c1">// ;// it will convert Integer to int using Autoboxing</span>
</code></pre></div></div>

<p>Previously it shows</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span><span class="c1">// it will create Integer value of 10 using Autoboxing</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span><span class="c1">//But we cant assign int to Integer Type mismatch: cannot convert from Integer to int</span>
</code></pre></div></div>

<h2 id="how-to-convert-primitives-to-wrapper--wrapper-to-primitive-">How to convert Primitives to Wrapper &amp; Wrapper to Primitive ??</h2>

<p>// 1. using constructor</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
</code></pre></div></div>

<p>// 2. using static factory method</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
</code></pre></div></div>

<p>//3.wrapper to primitive</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="how-does-autoboxing-of-integer-works-in-java-answer"><strong>How does Autoboxing of Integer works in Java? (</strong><a href="http://javarevisited.blogspot.sg/2012/07/auto-boxing-and-unboxing-in-java-be.html#axzz59AWpr6cb">answer</a><strong>)</strong></h2>

<p>Compiler uses valueOf() method to convert primitive to Object 
uses intValue(), doubleValue() etc to get primitive value from Object.</p>

<h2 id="what-if-i-make-main-privateprotected-">what if I make main() private/protected ?</h2>

<p>if you do not make main() method public, there is no compilation error. You
will <strong>runtime error</strong> because matching main() method is not present. Remember
that whole syntax should match to execute main() method.</p>

<p>Error: Main method not found in class Main, please define the main method as:</p>

<p>public static void main(String[] args)</p>

<h2 id="what-is-blank-final-variable">What is blank final variable?</h2>

<p>A <strong>blank final</strong> variable in Java is
a <a href="https://www.geeksforgeeks.org/g-fact-48/">final</a> variable that is not
initialized during declaration. Below is a simple example of blank final.</p>

<p>// A simple blank final example</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Value must be assigned in constructor/Static(static final) /Instance block
before using it.</p>
  </li>
  <li>
    <p>If we have more than one constructors or overloaded constructor in class,
then blank final variable must be initialized in all of them.</p>
  </li>
</ul>

<h2 id="difference-between-javautildate--javasqldate">Difference between java.util.Date &amp; java.sql.Date?</h2>
<p><img src="media/date.png" alt="date" /></p>

<ul>
  <li>
    <p><strong>java.util.Date</strong> represent <strong>both Date and Time information</strong>.</p>
  </li>
  <li>
    <p><strong>java.sql.Date</strong> just represent DATE <strong>without time information</strong>.</p>
  </li>
  <li>
    <p><strong>java.sql.Time and java.sql.TimeStamp</strong> which represents TIME and TIMESTAMP
type of SQL database is more close to java.util.Date.</p>
  </li>
  <li>
    <p>java.util.Date is Super class of java.sql.Date</p>
  </li>
</ul>

<h2 id="why-java-does-not-support-operator-overloading">Why Java does not support Operator Overloading?</h2>

<p>The meaning of an operator is always same for variable of basic types like: int,
float, double etc. For example: To add two integers, <em>+</em> operator is used.</p>

<p>However, for user-defined types (like: objects), you can redefine the way
operator works. For example: If there are two objects of a class that contains
string as its data members. You can redefine the meaning of + operator and use
it to concatenate those strings.</p>

<p>To overload an operator, a special operator function is defined inside the class
as</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">className</span>
<span class="o">{</span>
    <span class="o">...</span> <span class="o">..</span> <span class="o">...</span>
    <span class="kd">public</span>
       <span class="n">returnType</span> <span class="n">operator</span> <span class="nf">symbol</span> <span class="o">(</span><span class="n">arguments</span><span class="o">)</span>
       <span class="o">{</span>
           <span class="o">...</span> <span class="o">..</span> <span class="o">...</span>
       <span class="o">}</span> 
    <span class="o">...</span> <span class="o">..</span> <span class="o">...</span>
<span class="o">};</span>
<span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Test</span>
<span class="o">{</span>
   <span class="kd">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>

   <span class="kd">public</span><span class="o">:</span>
       <span class="nc">Test</span><span class="o">():</span> <span class="n">count</span><span class="o">(</span><span class="mi">5</span><span class="o">){}</span>

       <span class="kt">void</span> <span class="n">operator</span> <span class="o">++()</span> 
       <span class="o">{</span> 
          <span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> 
       <span class="o">}</span>
       <span class="kt">void</span> <span class="nf">Display</span><span class="o">()</span> <span class="o">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Count: "</span><span class="o">&lt;&lt;</span><span class="n">count</span><span class="o">;</span> <span class="o">}</span>
<span class="o">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="o">()</span>
<span class="o">{</span>
    <span class="nc">Test</span> <span class="n">t</span><span class="o">;</span>
    <span class="c1">// this calls "function void operator ++()" function</span>
    <span class="o">++</span><span class="n">t</span><span class="o">;</span>    
    <span class="n">t</span><span class="o">.</span><span class="na">Display</span><span class="o">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>This function is called when <em>++</em> operator operates on the object
of <em>Test</em> class (object <em>t</em> in this case).</p>
  </li>
  <li>
    <p>In the program, void operator ++ () operator function is defined
(inside <em>Test</em> class).</p>
  </li>
  <li>
    <p>This function increments the value of <em>count</em> by 1 for <em>t</em> object.</p>
  </li>
</ul>

<p><strong>Why Java Doesn’t Support it?</strong></p>

<p><strong>1.Java is Simple, No Confusions Please!!</strong><br />
Java does not support operator overloading: Java is relatively a very simple
language to use compared C/C++ with the non-support of complex and confusing
features like <strong>pointers</strong>, <strong>multiple inheritance</strong> and <strong>operator
overloading</strong>. These features are rarely used in practice and at the same time
poorly understood by the language beginners.</p>

<p><strong>2.JVM Performance: How many things Should i do?</strong><br />
Form JVM perspective supporting operator overloading is more difficult and if
the <strong>same thing can be achieved by using method overloading in more intuitive
and clean way it does make sense to not support operator overloading in java</strong>.
a complex JVM will result in slower JVM</p>

<h2 id="can-you-store-string-in-an-integer-array-in-java-compile-time-error-or-runtime-exception-answer"><strong>Can you store String in an Integer array in Java? compile time error or runtime exception? [</strong><a href="http://javarevisited.blogspot.co.uk/2013/11/java-array-101-for-programmers-and.html">answer</a><strong>]</strong></h2>

<ul>
  <li>
    <p>You cannot store an String in an array of primitive int, it will result in
compile time error as shown below,</p>
  </li>
  <li>
    <p>but if you create an array of Object and assign String[] to it and then try
to store Integer object on it. Compiler won’t be able to detect that and it
will throw ArrayStoreExcpetion at runtime</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">primes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
<span class="n">primes</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"a"</span><span class="o">;</span> <span class="c1">// compile time error</span>

<span class="nc">Object</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span> 
<span class="n">names</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span><span class="c1">// ArrayStoreException at runtime</span>
</code></pre></div></div>

<h2 id="what-is-difference-between-arrayindexoutfobounds-and-arraystoreexception-answer"><strong>What is difference between ArrayIndexOutfOBounds and ArrayStoreException? [</strong><a href="http://javarevisited.blogspot.sg/2014/05/exception-in-thread-main-arrayindexoutofboundsexception-java.html">answer</a><strong>]</strong></h2>

<p><code class="language-plaintext highlighter-rouge">ArrayIndexOutOfBoundsException</code> comes when your code tries to access an invalid
index for a given array e.g. negative index or higher index than length - 1.</p>

<p><code class="language-plaintext highlighter-rouge">ArrayStoreException</code> comes when you have stored an element of type other than
type of array, as shown in above example.</p>

<h2 id="is-it-legal-to-initialize-an-array-int-i--1-2-3-4-5-answer"><strong>Is it legal to initialize an array int i[] = {1, 2, 3, 4, 5}; [answer]</strong></h2>

<p>Yes, it’s perfectly legal. You can create and initialize array in same line in
Java.</p>

<h2 id="where-does-array-stored-in-memory-answer"><strong>Where does array stored in memory? [answer]</strong></h2>

<p>Array is created in heap space of JVM memory<strong>. Since array is object in Java</strong>,
even if you create array locally inside a method or block, object is always
allocated memory from heap.</p>

<p><img src="media/20b96719dbcbcab3daa0b9cfcdc11bc6.jpg" alt="Array concept interview questions and answers in Java" /></p>

<p>Array concept interview questions and answers in Java</p>

<h2 id="reverse-array-using-iterative-and-recursive-approaches">Reverse Array using Iterative and Recursive approaches</h2>

<p>Steps to Solve this</p>

<p>1.initialize array</p>

<p>2.Choose <strong>start</strong> index</p>

<p>3.Choose <strong>end</strong> index</p>

<p>4.Swap the elements using <strong>temp</strong> variable</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">array</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReverseArry</span> <span class="o">{</span>

	<span class="cm">/*
	 * Recursive approach: In recursive approach the function calls itself until
	 * the condition is met. And it is slower than iteration, which means it uses
	 * more memory than iteration. recursion is like a selection structure, and
	 * which makes code smaller and clean. And a function partially defined by
	 * itself. Here tracing the code will be more difficult in the case large
	 * programs
	 */</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">recursiveArry</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
 	<span class="kt">int</span> <span class="n">temp</span><span class="o">;</span>
 	<span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
 	<span class="n">a</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">end</span><span class="o">];</span>
 	<span class="n">a</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
 	<span class="n">recursiveArry</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span><span class="c1">//calling it again</span>
 <span class="o">}</span>
 <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
	<span class="o">}</span>

	
	<span class="cm">/*
	 *Iterative approach: Iterative approach is a repetition process until the condition fails.here loops are used such as for, while etc. Here code may be longer but it is faster than recursive. And it consumes less memory compared to recursive approach.If the loop condition is always true in such cases it will be an infinite loop.
 */</span>	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">iteravtiveArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">while</span><span class="o">(</span><span class="n">start</span><span class="o">&lt;</span><span class="n">end</span><span class="o">)</span>
 <span class="o">{</span>
 	<span class="kt">int</span> <span class="n">temp</span><span class="o">;</span>
 	<span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
 	<span class="n">a</span><span class="o">[</span><span class="n">start</span><span class="o">]=</span><span class="n">a</span><span class="o">[</span><span class="n">end</span><span class="o">];</span>
 	<span class="n">a</span><span class="o">[</span><span class="n">end</span><span class="o">]=</span><span class="n">temp</span><span class="o">;</span> 	
 	<span class="n">start</span><span class="o">++;</span>
 	<span class="n">end</span><span class="o">--;</span>
 <span class="o">}</span> 
 
 <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
	<span class="o">}</span>
  
	<span class="kd">static</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
 <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
 <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
 	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
	<span class="o">}</span>
	 
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 
                <span class="c1">// 1. Initialize array</span>
                <span class="kt">int</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span> <span class="o">};</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Input array is "</span><span class="o">);</span>
 <span class="n">printArray</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
	
 <span class="c1">// 2. Choose Starting &amp; ending point</span>
 <span class="kt">int</span> <span class="n">b</span><span class="o">[]</span> <span class="o">=</span> <span class="n">recursiveArry</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Recursive -Reversed array is "</span><span class="o">);</span>
 <span class="n">printArray</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
 
 <span class="kt">int</span> <span class="n">c</span><span class="o">[]</span> <span class="o">=</span> <span class="n">iteravtiveArray</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"IteravtiveArray -Reversed array is "</span><span class="o">);</span>
 <span class="n">printArray</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
 
<span class="nc">Input</span> <span class="n">array</span> <span class="n">is</span> 
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> 
<span class="nc">Recursive</span> <span class="o">-</span><span class="nc">Reversed</span> <span class="n">array</span> <span class="n">is</span> 
<span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span>
</code></pre></div></div>

<h2 id="how-do-you-reverse-an-array-in-java"><strong>How do you reverse an array in Java?</strong></h2>
<p>org.apache.commons.lang.ArrayUtils class to reverse Array in Java. As discussed
in our last post <a href="http://javarevisited.blogspot.com/2012/12/3-example-to-print-array-values-in-java.html">How to print array element in
Java</a>,
We are using <strong>Arrays.toString()</strong> to print content of array.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">iArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">101</span><span class="o">,</span><span class="mi">102</span><span class="o">,</span><span class="mi">103</span><span class="o">,</span><span class="mi">104</span><span class="o">,</span><span class="mi">105</span><span class="o">};</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">sArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">,</span> <span class="s">"four"</span><span class="o">,</span> <span class="s">"five"</span><span class="o">};</span>

<span class="c1">//reverse int array using Apache commons ArrayUtils.reverse() method </span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Original int array : "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">iArray</span><span class="o">));</span>
<span class="nc">ArrayUtils</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">iArray</span><span class="o">);</span>
</code></pre></div></div>

<h1 id="javalang-package">java.lang Package</h1>

<p>We have mainly five classes in java.lang. Which are most commonly used in any
java program</p>

<ol>
  <li>
    <p><strong>Object</strong></p>
  </li>
  <li>
    <p><strong>String</strong></p>
  </li>
  <li>
    <p><strong>StringBuffer</strong></p>
  </li>
  <li>
    <p><strong>StringBuilder</strong></p>
  </li>
  <li>
    <p><strong>Wrapper Classes (AutoBoxing / AutoUnboxing)</strong></p>
  </li>
</ol>

<h2 id="object-class">Object Class</h2>

<p>The most common general methods which can be applicable on any java object are
defined in object class. Object class is the parent class of any java class,
whether it is predefined or programmer defined, hence all the object class
methods are by default available to any java class.</p>

<p>Object class define the following 11 methods</p>

<p><strong>1.toString</strong>():Returns a string representation of the object.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
 <span class="k">return</span> <span class="n">getClass</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="sc">'@'</span> <span class="o">+</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toHexString</span><span class="o">(</span><span class="nc">HashCode</span><span class="o">);</span>
	<span class="o">}</span>
</code></pre></div></div>

<p><strong>2.hashCode</strong>():returns the integer representation of memory location which
used by JVM while saving/adding Objects into Hashsets, Hashtables or Hashmap</p>

<p><strong>3.equals</strong>(Object): Compares two Objects for equality.</p>

<p><strong>4.clone</strong>(): Creates a new object of the same class as this object which
implements <strong>Clonable interface.</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Test</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Test</span><span class="o">();</span>
<span class="nc">Test</span> <span class="n">t2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Test</span><span class="o">)</span><span class="n">t1</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
</code></pre></div></div>

<p><strong>5.finalize</strong>():Called by the garbage collector on an object when garbage
collection determines that there are no more references to the object.</p>

<p><strong>6.getClass</strong>():Returns the runtime class of an <strong>obj.getClass(),</strong> or the
class-literal (<strong>Foo.class</strong>) return a Class object, which contains some
metadata about the class:</p>

<ul>
  <li>name</li>
  <li>package</li>
  <li>methods</li>
  <li>fields</li>
  <li>constructors</li>
  <li>annotations</li>
</ul>

<p>we can create Class object by following ways</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(-</span><span class="nc">StudentBO</span><span class="err">"</span><span class="o">)</span>
<span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">StudentBO</span><span class="o">.</span><span class="na">class</span>
<span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
 <span class="nc">TestApp</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TestApp</span><span class="o">();</span>
 <span class="nc">Class</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
 
  <span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"java.lang.String"</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Class represented by c : "</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
  
  <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
	<span class="o">}</span>
</code></pre></div></div>

<p><strong>7.wait</strong>():Waits to be notified by another thread of a change in this object.</p>

<p><strong>8.wait</strong>(long):Waits to be notified by another thread of a change in this
object.</p>

<p><strong>9.wait</strong>(long, int):Waits to be notified by another thread of a change in this
object.</p>

<p><strong>10.notify</strong>():Wakes up a single thread that is waiting on this object’s
monitor.</p>

<p><strong>11.notifyAll</strong>():Wakes up all threads that are waiting on this object’s
monitor.</p>

<p><code class="language-plaintext highlighter-rouge">equals(Object otherObject)</code> – As method name suggests, is used to simply verify
the equality of two objects. It’s default implementation simply check the object
references of two objects to verify their equality<strong>. By default, two objects
are equal if and only if they are stored in the same memory address.</strong></p>

<p><code class="language-plaintext highlighter-rouge">hashcode()</code> – Returns a unique integer value for the object in runtime. By
default, integer value is mostly derived from memory address of the object in
heap (but it’s not mandatory always).</p>

<p>If two objects are equal according to the equals(Object) method, then calling
the hashCode method on each of the two objects must produce the same integer
result.</p>

<p><strong>Whenever we override the equals() method, we should override hashcode()
method</strong></p>

<p><code class="language-plaintext highlighter-rouge">In String class(not StringBuilder, StringBuffer) &amp; All Wrapper classes equals()
method is overridden for Content Comparison</code></p>

<h2 id="compare-two-employee-objects-based-on-their-id">Compare two employee Objects based on Their Id?</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employe</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
	<span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="c1">//Setters &amp; Getters</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span> 
 <span class="nc">Employe</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Employe</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
 <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
 <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span> <span class="o">{</span>
 	<span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">Employe</span> <span class="n">e1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employe</span><span class="o">();</span>
 <span class="nc">Employe</span> <span class="n">e2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employe</span><span class="o">();</span>
 <span class="n">e1</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">101</span><span class="o">);</span>
 <span class="n">e2</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">101</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">e2</span><span class="o">));</span><span class="c1">//true</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>  	  <span class="c1">//366712642</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span> <span class="c1">//1829164700 – here different</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So are we done? If two objects are equal according to the <code class="language-plaintext highlighter-rouge">equals(Object)</code> method,
then calling the <code class="language-plaintext highlighter-rouge">hashCode</code> method on each of the two objects must produce the
same integer result. <strong><code class="language-plaintext highlighter-rouge">But here it is not!!</code></strong></p>

<p>Not yet. Lets test again above modified Employee class in different way.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">Employe</span> <span class="n">e1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employe</span><span class="o">();</span>
 <span class="nc">Employe</span> <span class="n">e2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employe</span><span class="o">();</span>
 <span class="n">e1</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">101</span><span class="o">);</span>
 <span class="n">e2</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">101</span><span class="o">);</span>
 
 <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Employe</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
 <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e1</span><span class="o">);</span>
 <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e2</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span> <span class="c1">//[basic.Employe@15db9742, basic.Employe@6d06d69c]	</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>Above class prints two objects in the second print statement. If both employee
objects have been equal, in a <code class="language-plaintext highlighter-rouge">Set</code> which stores only unique objects, there must
be only one instance inside HashSet</p>

<p>We are missing the second important method <code class="language-plaintext highlighter-rouge">hashCode()</code>. As java docs say, <code class="language-plaintext highlighter-rouge">if you
override equals()method then you must override hashCode() method</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employe</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
	<span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span> 
 <span class="nc">Employe</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Employe</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
 <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
 <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span> <span class="o">{</span>
 	<span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span> 
 <span class="k">return</span> <span class="nf">getId</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">Employe</span> <span class="n">e1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employe</span><span class="o">();</span>
 <span class="nc">Employe</span> <span class="n">e2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employe</span><span class="o">();</span>
 <span class="n">e1</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">101</span><span class="o">);</span>
 <span class="n">e2</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">101</span><span class="o">);</span>
 
 <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Employe</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
 <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e1</span><span class="o">);</span>
 <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e2</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span> <span class="c1">//[basic.Employe@65] </span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><a href="https://commons.apache.org/proper/commons-lang/">Apache commons</a> provide two
excellent utility
classes <a href="https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html">EqualsBuilder</a>
<strong>&amp;</strong>
<a href="https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html">HashCodeBuilder</a> 
for generating hash code and equals methods.</p>

<h2 id="can-a-top-level-class-be-private-or-protected">Can a top-level class be private or protected?</h2>

<p>Top level classes in java <code class="language-plaintext highlighter-rouge">can’t be private or protected</code>, but inner classes in
java can. The reason for not making a top-level class as private is very
obvious, because nobody can see a private class and thus they cannot use it</p>

<h2 id="what-happens-if-we-compile-empty-java-file">What Happens if we compile Empty java file?</h2>

<p>Compiles but Runtime Error.</p>

<p><img src="media/539858d3e49c4d31fc94353e31ff3f58.png" alt="" /></p>

<h2 id="is-it-possible-to-make-array-volatile-in-java">Is it possible to make array volatile in Java?</h2>

<p>Yes, you can make an array (both primitive and reference type array e.g. an <a href="http://www.java67.com/2015/07/array-concepts-interview-questions-answers-java.html">int
array</a> and <a href="http://www.java67.com/2012/09/java-program-to-convert-string-arraylist-to-string-array.html">String
array</a>)
volatile in Java, but only changes to reference pointing to an array will be
visible to all threads, not the whole array.</p>

<p>What this means is that suppose you have a reference variable called <strong>primes</strong>
as shown below:<br />
<strong>protected volatile int[] primes = new int[10];</strong></p>

<p>then if you assign a new array to primes variable, change will be visible to all
threads, but changes to individual indices(a[0], a[1]…a[n]) will not be covered
under volatile guarantee i.e.<br />
<strong>primes = new int[20];</strong></p>

<p>It will follow the <strong>“happens-before”</strong> rule(<em>Happens-before relationship is a
guarantee that action performed by one thread is visible to another action in
different thread</em>.) and cause memory refresh, but following code will not do so</p>

<p>if multiple threads are changing individual array elements e.g. storing updates,
there won’t be any happens-before guarantee provided by the <a href="http://javarevisited.blogspot.com/2012/03/difference-between-transient-and.html">volatile
modifier</a> for
such modification</p>

<p><strong>primes[0] = 10;</strong><br />
<strong>primes[1] = 20;</strong><br />
<strong>primes[2] = 30;</strong><br />
<strong>primes[3] = 40;</strong><br />
So, if your use-case is to provide memory visibility guarantee for individual
array elements than <strong>volatile is not the right choice</strong>. You must rely on other
synchronization and a thread-safety mechanism to cover this case
e.g. <a href="http://www.java67.com/2012/08/5-thread-interview-questions-answers-in.html">synchronized</a>** keyword, <strong><a href="http://javarevisited.blogspot.com/2011/07/java-multi-threading-interview.html">atomic
variables</a></strong>,
or <strong><a href="http://javarevisited.blogspot.sg/2013/03/reentrantlock-example-in-java-synchronized-difference-vs-lock.html">ReentrantLock</a></strong>.**</p>

<h2 id="is-it-possible-to-make-arraylist-hashset-volatile-in-java">Is it possible to make ArrayList, Hashset volatile in Java?</h2>

<p>On a similar note, sometimes instead of an array, Interviewer put the collection
i.e. they will ask <em>can you make a collection variable volatile in Java or
not</em> e.g.
an <a href="http://www.java67.com/2015/06/20-java-arraylist-interview-questions.html">ArrayList</a> or <a href="http://javarevisited.blogspot.sg/2014/11/how-to-loop-hashmap-or-hashtable-in-jsp-example.html">HashMap</a>.
The answer is same, of course, you can make a reference variable pointing to a
Collection volatile in Java, but the happens-before guarantee will only be
provided if the value of that reference variable is changed e.g. you assign a
new collection to it.</p>

<p>Any modification done on actual collection object e.g. adding or removing
elements from ArrayList will not invoke happens-before guarantee or memory
barrier refresh.</p>

<h2 id="what-is-ahashcode-used-for-how-is-it-related-to-aequalsb">What is a.hashCode() used for? How is it related to a.equals(b)?</h2>

<p>According to the Java specification, two objects which are identical to each
other using equals() method needs to have the same hash code</p>

<h2 id="what-is-a-compile-time-constant-in-java-what-is-the-risk-of-using-it">What is a compile time constant in Java? What is the risk of using it?</h2>

<p>Answer: <strong>Public static final variables</strong> are also known as the compile time
constant, the public is optional there. They are substituted with actual values
at compile time because compiler recognizes their value up-front, and also
recognize that it cannot be altered during runtime.</p>

<p>One of the issues is that if you choose to use a public static final variable
from in-house or a third party library, and their value changed later, then your
client will still be using the old value even after you deploy a new version of
JARs.</p>

<h2 id="explain-liskov-substitution-principle">Explain Liskov Substitution Principle.</h2>

<p>According to the Liskov Substitution Principle, <strong>Subtypes must be appropriate
for super type</strong> i.e. methods or functions which use super class type must be
able to work with object of subclass without issues. <strong>Co-Variant return types
are implemented based on this principle.</strong></p>

<h2 id="what-is-double-checked-locking-in-singleton">What is double checked locking in Singleton?</h2>

<p><strong>Singleton</strong> means we can create only one instance of that class</p>

<p><strong>Rules:</strong></p>

<ul>
  <li>
    <p>Create Singleton class Object make it as PRIVATE</p>
  </li>
  <li>
    <p>Create PRIVATE constructor</p>
  </li>
  <li>
    <p>Every Singleton class contains at least one factory method</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Student</span> <span class="n">st</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nf">Student</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"OBJECET Created FIRST TIME"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Student</span> <span class="nf">getObject</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">st</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"OBJECET ALREDAY CREATED"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">st</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Student</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
        <span class="nc">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">Student</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span><span class="c1">//7855445</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span><span class="c1">//7855445</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Double checked locking in Singleton means,</strong> at any cost only one instance is
created in multi-threaded environment.</p>

<p>In this case at null checking make Block as Synchronized.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstanceDC</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">_instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>                <span class="c1">// Single Checked</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">_instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>        <span class="c1">// Double checked</span>
                    <span class="n">_instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">_instance</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="when-to-use-volatile-variable-in-java">When to use volatile variable in Java?</h2>

<ul>
  <li>
    <p>Volatile keyword is used with only variable in Java</p>
  </li>
  <li>
    <p>it guarantees that value of volatile variable will always be read from main
memory and not from Thread’s local cache.</p>
  </li>
  <li>
    <p>So, we can use volatile to achieve synchronization because its guaranteed
that all reader thread will see updated value of volatile variable once
write operation completed</p>
  </li>
</ul>

<h2 id="difference-between-serializable-and-externalizable-in-java">Difference between Serializable and Externalizable in Java?</h2>

<p><strong>Serialization</strong> is a default process of serializing or persisting any object’s
state in Java. It’s triggered by implementing Serializable interface which is a
marker interface (an interface without any method). uses default implementation
to handle the object serialization process.</p>

<p><strong>Externalizable</strong> is used to user defined serialization process and control
default serialization process which is implemented by application.</p>

<p>Externalizable interface extends Serializable interface. It consists of two
methods</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// to read object from stream</span>
<span class="kt">void</span> <span class="nf">readExternal</span><span class="o">(</span><span class="nc">ObjectInput</span> <span class="n">in</span><span class="o">)</span> 

<span class="c1">// to write object into stream</span>
<span class="kt">void</span> <span class="nf">writeExternal</span><span class="o">(</span><span class="nc">ObjectOutput</span> <span class="n">out</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="difference-between-static-and-dynamic-binding-in-java-detailed-answer"><strong>Difference between static and dynamic binding in Java? (detailed answer)</strong></h2>
<p>This is usually asked as follow-up of previous question, <strong>static binding is
related to overloaded method and dynamic binding is related to overridden
method</strong>.</p>

<p><strong>Method like private, final and static are resolved using static binding at
compile time</strong> but virtual methods which can be overridden are resolved using
dynamic binding at runtime.</p>

<p><strong>Which design pattern have you used in your production code?</strong></p>

<ul>
  <li>
    <p><strong>Dependency injection</strong></p>
  </li>
  <li>
    <p><strong>Factory pattern</strong></p>
  </li>
  <li>
    <p><strong>Adapter Design pattern</strong></p>
  </li>
  <li>
    <p><strong>Singleton</strong></p>
  </li>
  <li>
    <p><strong>Decorator</strong><a href="https://www.journaldev.com/1827/java-design-patterns-example-tutorial">design
pattern</a> is
used to modify the functionality of an object at runtime.</p>
  </li>
</ul>

<h2 id="can-you-explain-liskov-substitution-principlecomes-under-inheritance-">Can you explain Liskov Substitution principle?(Comes under inheritance )</h2>

<p>According to Liskov Substitution Principle, Subtypes must be substitutable for
supertype i.e. methods or functions which uses superclass type must be able to
work with
the <a href="http://javarevisited.blogspot.com/2012/12/what-is-object-in-java-or-oops-example.html">object </a>of
subclass without any issue</p>

<h2 id="how-to-create-an-instance-of-any-class-without-using-new-keyword">How to create an instance of any class without using new keyword</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*****************************************</span>
<span class="mi">1</span><span class="o">.</span><span class="na">Using</span> <span class="n">newInstance</span> <span class="n">method</span> <span class="n">of</span> <span class="nc">Class</span> <span class="kd">class</span>
<span class="err">*****************************************</span>
<span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"StudentBo"</span><span class="o">);</span>
<span class="nc">StudentBo</span> <span class="n">bo</span> <span class="o">=</span> <span class="o">(</span><span class="nc">StudentBo</span><span class="o">)</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>


<span class="o">*****************************************</span>
<span class="mi">2</span><span class="o">.</span><span class="na">Using</span> <span class="n">clone</span><span class="o">()</span> <span class="n">of</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span>
<span class="o">*****************************************</span>
<span class="nc">NewClass</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NewClass</span><span class="o">();</span>
<span class="nc">NewClass</span> <span class="n">obj2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">NewClass</span><span class="o">)</span> <span class="n">obj</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="how-can-we-invoke-any-external-process-in-java">How can we invoke any external process in java?</h2>

<p>Using,</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">exec</span><span class="o">(</span><span class="err">…</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="static-imports-rules-">Static imports rules ?</h2>

<p>The static import feature of Java 5 facilitates the java programmer to access
any static member of a class directly. There is no need to qualify it by the
class name.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">System</span><span class="o">.*;</span>   <span class="o">(</span><span class="n">or</span><span class="o">)</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">System</span><span class="o">.</span><span class="na">out</span><span class="o">;</span>
 
<span class="kd">class</span> <span class="nc">StaticImportExample</span><span class="o">{</span>  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[]){</span>  
     
   <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span><span class="c1">//Now no need of System.out  </span>
   <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Java"</span><span class="o">);</span>  
  
 <span class="o">}</span>   
<span class="o">}</span>
</code></pre></div></div>

<h3 id="ambiguity-in-static-import"><strong>Ambiguity in static import</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// both have MAX_VALUE as static</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Integer</span><span class="o">.*;</span> 
<span class="kn">import</span> <span class="nn">static</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Byte</span><span class="o">.*;</span> 
<span class="kd">class</span> <span class="nc">Geeks</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="no">MAX_VALUE</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
<span class="nl">Error:</span><span class="nc">Reference</span> <span class="n">to</span> <span class="no">MAX_VALUE</span> <span class="n">is</span> <span class="n">ambigious</span>
</code></pre></div></div>

<h1 id="java-oops-concepts">Java OOPs Concepts</h1>

<h2 id="can-we-prevent-overriding-a-method-without-using-the-final-modifier-answer"><strong>Can we prevent overriding a method without using the final modifier? (answer)</strong></h2>

<p>Yes, you can prevent the method overriding in Java without using the final
modifier. In fact, there are several ways to accomplish it e.g. you can mark the
method <strong>private or static, those cannot be overridden.</strong></p>

<h2 id="can-we-override-a-private-method-in-java-answer"><strong>Can we override a private method in Java? (</strong><a href="http://java67.blogspot.sg/2013/08/can-we-override-private-method-in-java-inner-class.html">answer</a><strong>)</strong></h2>

<p>No, you cannot. Since the private method is only accessible and visible inside
the class they are declared, it’s not possible to override them in subclasses.
But we can re-decalre in sub class , it will trated as a new method, bcoz parent
class private method is not visible to subclass.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Parent"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="kd">extends</span> <span class="no">A</span><span class="o">{</span>
	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Child"</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
 <span class="no">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Demo</span><span class="o">();</span>
 <span class="n">a</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
	
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Exception in thread "main" java.lang.Error: Unresolved compilation problem:</code></p>

<p>The method show() from the type A is not visible at Demo.main(Demo.java:12)</p>

<p>Though, you can override them inside the inner class as they are accessible
there.</p>

<h2 id="can-we-change-the-return-type-of-method-to-subclass-while-overriding-answer"><strong>Can we change the return type of method to subclass while overriding? (answer)</strong></h2>

<p>Yes, you can, but only from Java 5 onward. This feature is known as <strong>covariant
method</strong> overriding and it was introduced in JDK 5 release. This is immensely
helpful if original method return super-class e.g. clone() method return
java.lang.Object. By using this, you can directly return the actual type,
preventing client-side type casting of the result.</p>

<h2 id="can-we-make-a-class-both-final-and-abstract-at-the-same-time-answer"><strong>Can we make a class both final and abstract at the same time? (</strong><a href="http://javarevisited.blogspot.com/2011/12/final-variable-method-class-java.html">answer</a><strong>)</strong></h2>

<p>No, you cannot apply both final and abstract keyword at the class same time
because they are exactly opposite of each other. A final class in Java cannot be
extended and you cannot use an abstract class without extending and make it a
concrete class. As per Java specification, the compiler will throw an error if
you try to make a class abstract and final at the same time.</p>

<h2 id="can-we-overload-or-override-the-main-method-in-java-answer"><strong>Can we overload or override the main method in Java? (answer)</strong></h2>
<p>No, since main() is a static method, you can only overload it, you cannot
override it because the static method is resolved at compile time without
needing object information hence we cannot override the main method in Java.</p>

<h1 id="design-patterns">Design Patterns</h1>

<p>SOLID design principles and GOF design patterns which take advantage of OOPS
concept discussed here.</p>

<h2 id="what-are-solid-design-principles">What are SOLID Design principles</h2>

<p><img src="media/79b87bd771b85e04976268c929864380.png" alt="Image result for solid design principles" /></p>

<p>Image result for solid design principles</p>

<p><strong>1. Single Responsibility Principle</strong></p>

<p><strong>-One class should have one and only one responsibility”</strong></p>

<p>In other words, we should write, change and maintain a class for only one
purpose<strong>. If it is model class then it should strictly represent only one
actor/ entity</strong>. This will give we the flexibility to make changes in future
without worrying the impacts of changes for another entity.</p>

<p><strong>2. Open Closed Principle</strong></p>

<p><strong>-Software components should be open for extension, but closed for
modification”</strong></p>

<p>If we take a look into any good framework like struts or spring, we will see
that <strong>we cannot change their core logic and request processing</strong>, <strong>but we
modify the desired application flow just by extending some classes and plugin
them in configuration files.</strong></p>

<p>For example, spring framework has class DispatcherServlet. This class acts
as <strong>front controller</strong> for String based web applications. To use this class, we
are not required to modify this class<strong>. All we need is to pass initialization
parameters and we can extend it’s functionality the way we want.</strong></p>

<p><strong>3. Liskov’s Substitution Principle</strong></p>

<p>-Derived types must be completely substitutable for their base types”</p>

<p><strong>4. Interface Segregation/Separation Principle</strong></p>

<p>This principle is my favorite one. It is applicable to interfaces as single
responsibility principle holds to classes. ISP says:</p>

<p>-Clients should not be forced to implement unnecessary methods which they will
not use”</p>

<p>Take an example. Developer Alex created an interface Reportable and added two
methods generateExcel() and generatedPdf(). Now client ‘A’ wants to use this
interface but he intend to use reports only in PDF format and not in excel. Will
he be able to use the functionality easily?</p>

<p>NO. He will have to implement both the methods, out of which one is extra burden
put on him by designer of software. Either he will implement another method or
leave it blank. This is not a good design.</p>

<p><strong>5. Dependency Inversion/Injection Principle</strong></p>

<p><strong>Remove dependency from classes</strong></p>

<p>In spring framework, all modules are provided as separate components which can
work together by simply injected dependencies in other module. This dependency
is managed externally in XML files.</p>

<h2 id="what-are-gofgang-of-four-design-patterns">What are GOF(Gang of Four) design patterns?</h2>

<p><img src="media/2a056ac9ceb6b2be1cdadf512faee112.jpg" alt="Image result for gof design patterns" /></p>

<p>Image result for gof design patterns</p>

<p><strong>1. Creational Design Patterns (Object Creation)</strong></p>

<p>Creational patterns often used in place of direct instantiation with
constructors. They make the creation process more adaptable and dynamic. In
particular, they can provide a great deal of flexibility about which objects are
created, <strong>how those objects are created, and how they are initialized</strong>.</p>

<table>
  <thead>
    <tr>
      <th><strong>DESIGN PATTERN NAME</strong></th>
      <th><strong>PURPOSE</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/creational/builder-pattern-in-java/">Builder</a></td>
      <td>Builder design pattern is an alternative way to construct complex objects and should be used only when we want to build different types of immutable objects using same object building process.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/creational/prototype-design-pattern-in-java/">Prototype</a></td>
      <td>Prototype design pattern is used in scenarios where application needs to create a large number of instances of a class, which have almost same state or differ very little.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/creational/implementing-factory-design-pattern-in-java/">Factory</a></td>
      <td>Factory design pattern is most suitable when complex object creation steps are involved. To ensure that these steps are centralized and not exposed to composing classes.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/creational/abstract-factory-pattern-in-java/">Abstract factory</a></td>
      <td>Abstract factory pattern is used whenever we need another level of abstraction over a group of factories created using factory pattern.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/singleton-design-pattern-in-java/">Singleton</a></td>
      <td>Singleton enables an application to have one and only one instance of a class per JVM.</td>
    </tr>
  </tbody>
</table>

<p><strong>2. Structural Design Patterns</strong></p>

<p>Structural design patterns show us how to glue different pieces of a system
together in a flexible and extensible fashion. These patterns help us guarantee
that <strong>when one of the parts changes, the entire application structure does not
need to change.</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>DESIGN PATTERN NAME</strong></th>
      <th><strong>PURPOSE</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://howtodoinjava.com/2014/05/10/adapter-design-pattern-in-java/">Adapter</a></td>
      <td>An adapter convert the interface of a class into another interface clients expect. It lets classes work together that couldn’t otherwise because of incompatible interfaces.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/structural/bridge-design-pattern/">Bridge</a></td>
      <td>Bridge design pattern is used to decouple a class into two parts – <em>abstraction</em> and it’s <em>implementation</em> – so that both can evolve in future without affecting each other. It increases the loose coupling between class abstraction and it’s implementation.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/structural/composite-design-pattern/">Composite</a></td>
      <td>Composite design pattern helps to compose the objects into tree structures to represent whole-part hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/structural/decorator-design-pattern/">Decorator</a></td>
      <td>Decorator design pattern is used to add additional features or behaviors to a particular instance of a class, while not modifying the other instances of same class.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/structural/facade-design-pattern/">Facade</a></td>
      <td>Facade design pattern provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/structural/flyweight-design-pattern/">Flyweight</a></td>
      <td>Flyweight design pattern enables use sharing of objects to support large numbers of fine-grained objects efficiently. A flyweight is a shared object that can be used in multiple contexts simultaneously. The flyweight acts as an independent object in each context.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/structural/proxy-design-pattern/">Proxy</a></td>
      <td>In proxy design pattern, a proxy object provide a surrogate or placeholder for another object to control access to it. Proxy is heavily used to implement lazy loading related usecases where we do not want to create full object until it is actually needed.</td>
    </tr>
  </tbody>
</table>

<p><strong>3. Behavioral Design Patterns</strong></p>

<p>Behavioral patterns abstract an action <strong>we want to take on the object or class
that takes the action</strong>. By changing the object or class, we can change the
algorithm used, the objects affected, or the behavior, while still retaining the
same basic interface for client classes.</p>

<table>
  <thead>
    <tr>
      <th><strong>DESIGN PATTERN NAME</strong></th>
      <th><strong>PURPOSE</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/behavioral/chain-of-responsibility-design-pattern/">Chain of responsibility</a></td>
      <td>Chain of responsibility design pattern gives more than one object an opportunity to handle a request by linking receiving objects together in form of a chain.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/behavioral/command-pattern/">Command</a></td>
      <td>Command design pattern is useful to abstract the business logic into discrete actions which we call commands. These command objects help in loose coupling between two classes where one class (invoker) shall call a method on other class (receiver) to perform a business operation.</td>
    </tr>
    <tr>
      <td><strong>Interpreter</strong></td>
      <td>Interpreter pattern specifies how to evaluate sentences in a language, programatically. It helps in building a grammar for a simple language, so that sentences in the language can be interpreted.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/behavioral/iterator-design-pattern/">Iterator</a></td>
      <td>Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/behavioral/mediator-pattern/">Mediator</a></td>
      <td>Mediator pattern defines an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets us vary their interaction independently.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/behavioral/memento-design-pattern/">Memento</a></td>
      <td>Memento pattern is used to restore state of an object to a previous state. It is also known as snapshot pattern.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/behavioral/observer-design-pattern/">Observer</a></td>
      <td>Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It is also referred to as the publish-subscribe pattern.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/behavioral/state-design-pattern/">State</a></td>
      <td>In state pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class. There shall be a separate concrete class per possible state of an object.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/behavioral/strategy-design-pattern/">Strategy</a></td>
      <td>Strategy pattern is used where we choose a specific implementation of algorithm or task in run time – out of multiple other implementations for same task.</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/behavioral/template-method-pattern/">Template method</a></td>
      <td>Template method pattern defines the sequential steps to execute a multi-step algorithm and optionally can provide a default implementation as well (based on requirements).</td>
    </tr>
    <tr>
      <td><a href="https://howtodoinjava.com/design-patterns/behavioral/visitor-design-pattern-example-tutorial/">Visitor</a></td>
      <td>Visitor pattern is used when we want a hierarchy of objects to modify their behavior but without modifying their source code.</td>
    </tr>
  </tbody>
</table>

<h2 id="what-is-strategy-pattern-in-java"><strong>What is Strategy pattern in Java?</strong></h2>

<p>Strategy pattern allows you to <strong>introduce new strategy without changing the
code.</strong></p>

<p>For example, the <strong>Collections.sort()</strong> method which sorts the list of the
object uses the Strategy pattern to compare object. Since every object uses
different comparison strategy you can compare various object differently without
changing sort method.</p>

<h2 id="what-is-decorator-design-pattern">What is Decorator Design Pattern?</h2>

<p>Decorator pattern <strong>provides new features without modifying the original
class</strong>. <strong>Inheritance is the example.</strong></p>

<p><strong>What is the difference between Decorator, Proxy and Adapter pattern in
Java? (answer)</strong><br />
Again they look similar because their structure or class diagram is very similar
but their intent is quite different. Decorator adds additional functionality
without touching the class, Proxy provides access control and Adapter is used to
make two incompatible interfaces work together.</p>

<h2 id="what-is-a-strongly-typed-programming-language-1">What is a strongly typed programming language?</h2>

<p>In a strongly typed language compiler ensure type correctness, for example, you
<strong>can not store the number in String or vice-versa</strong>.</p>

<p>Java is a strongly typed language, that’s why you have different data types
Ex <strong>int, float, String, char, boolean etc.</strong></p>

<p>On the other hand, weakly typed language don’t enforce type checking at compile
time and they tree values based upon context. <strong>Python and Perl</strong> are two
popular example of weakly typed programming language, where you can store a
numeric string in number type.</p>

<h2 id="can-you-describe-three-different-kinds-of-testing-that-might-be-performed-1">Can you describe three different kinds of testing that might be performed?</h2>

<p><strong>Unit Testing, Integration Testing and Smoke Testing</strong>.</p>

<ul>
  <li>
    <p><strong>Unit testing</strong> is used to test individual units to verify whether they are
working as expected</p>
  </li>
  <li>
    <p><strong>Integration Testing</strong> is done to verify whether individually tested module
can work together or not</p>
  </li>
  <li>
    <p><strong>Smoke Testing</strong> is a way to test whether most common functionality of
software is working properly or not e.g. in a flight booking website, you
should be able to book, cancel or change flights.</p>
  </li>
</ul>

<h2 id="what-is-the-difference-between-iteration-and-recursion-detailed-answer-1">What is the difference between iteration and recursion? (<a href="http://javarevisited.blogspot.sg/2012/12/recursion-in-java-with-example-programming.html">detailed answer</a>)</h2>

<ul>
  <li>
    <p><strong>Iteration</strong> uses a loop to perform the same step again and again.</p>
  </li>
  <li>
    <p><strong>Recursion</strong> calls the same method itself to do the repetitive task</p>
  </li>
</ul>

<h2 id="what-is-test-driven-development-1">What is test-driven development?</h2>

<p>Test driven is one of the popular development methodologies in which tests are
written before writing any function code. In fact, test drives the structure of
your program. Purists never wrote a single line of application code without
writing a test for that. It greatly improve code quality and often attributed as
a quality of rockstar developers.</p>

<h2 id="how-do-you-find-a-running-java-process-on-unix-1">How do you find a running Java process on UNIX?</h2>

<p>You can use the combination of <strong>‘ps’ and ‘grep’</strong> command to find any process
running on UNIX machine. ps -e will list every process i.e. process from all
user not just you and  ps -f will give you full details including PID, which
will be required if you want to investigate more or would like to kill this
process using kill command.</p>

<table>
  <tbody>
    <tr>
      <td>ps -ef</td>
      <td>grep “java”</td>
    </tr>
  </tbody>
</table>

<h2 id="difference-between-weakreference-vs-softreference-vs-phantomreference-vs-strong-reference-in-garbage-collection-1">Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Garbage Collection?</h2>

<p>there are four kind of reference in Java :</p>

<ol>
  <li>
    <p>Strong reference</p>
  </li>
  <li>
    <p>Weak Reference</p>
  </li>
  <li>
    <p>Soft Reference</p>
  </li>
  <li>
    <p>Phantom Reference</p>
  </li>
</ol>
</div><section class="article__sharing d-print-none"><!-- Addthis BEGIN --><script type="text/javascript"
    src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5dd2bcde40b385b7"></script>
  <div class="addthis_inline_share_toolbox addthis_default_style"></div><!-- Addthis END -->
</section><div class="d-print-none"><footer class="article__footer"><meta itemprop="dateModified" content="2017-11-11T00:00:00+00:00"><!-- start custom article footer snippet -->

<!-- end custom article footer snippet --></footer><div class="article__section-navigator clearfix"><div class="previous"><span>PREVIOUS</span><a href="/JDBC-Interview-Questions.html">JDBC - Interview Questions</a></div><div class="next"><span>NEXT</span><a href="/Java-Interview-Questions-2.html">Java - Interview Questions PART-2</a></div></div></div>

</div>

<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    $(function() {
      var $this ,$scroll;
      var $articleContent = $('.js-article-content');
      var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
      var scroll = hasSidebar ? '.js-page-main' : 'html, body';
      $scroll = $(scroll);

      $articleContent.find('.highlight').each(function() {
        $this = $(this);
        $this.attr('data-lang', $this.find('code').attr('data-lang'));
      });
      $articleContent.find('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]').each(function() {
        $this = $(this);
        $this.append($('<a class="anchor d-print-none" aria-hidden="true"></a>').html('<i class="fas fa-anchor"></i>'));
      });
      $articleContent.on('click', '.anchor', function() {
        $scroll.scrollToAnchor('#' + $(this).parent().attr('id'), 400);
      });
    });
  });
})();
//alert('start .......');
document.getElementsByClassName('article__header')[0].style.display = 'none';
document.getElementsByClassName('article__info')[0].style.display = 'none';
//alert(' end .......');
 
 document.onreadystatechange = function(){
     if(document.readyState === 'complete'){
         /*code here*/
		 //alert('onreadystatechange comled ... start .......');
document.getElementsByClassName('article__header')[0].style.display = 'none';
document.getElementsByClassName('article__info')[0].style.display = 'none';
//alert('onreadystatechange comled ... end .......');
     }
}

</script></div><section class="page__comments d-print-none"></section></article><!-- start custom main bottom snippet -->

<!-- end custom main bottom snippet --></div>
            </div></div></div><div class="page__footer d-print-none"><footer class="footer py-4 js-page-footer">
  <div class="main"><div itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Satya Kaveti"><meta itemprop="url" content="/"><meta itemprop="description" content="I am an amazing person."><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"></ul>
</div>
</div>
    </div><div class="site-info mt-2">
      <div>© SatyaCodes 2020 ,
        <a title="Satya Kaveti" href="about/">Satya Kaveti's Writing</a>.
		<span>| <a href="about/">About Me</a> &nbsp |  </span>
		<span><a href="/terms.html">Terms</a> &nbsp |  </span>
		<span><a href="/contact.html">Contact</a> &nbsp |  </span>
		<span><a href="http://www.satyacodesapps.ml/" target="_blank">Our Apps</a> &nbsp |  </span>
		<span><a href="https://www.facebook.com/isatyakaveti" target="_blank"><i class="fab fa-facebook-f"></i></a> &nbsp |  </span>
		<span><a href="https://www.youtube.com/" target="_blank"><i class="fab fa-youtube-square"></i></a> &nbsp |  </span>
		<span><a href="https://in.linkedin.com/in/satyakaveti"target="_blank"><i class="fab fa-linkedin-in"></i></a> &nbsp | 
		<span>[ 
		<!-- Start of WebFreeCounter Code -->
<a href="http://www.statworker.com/" target="_blank"><img src="https://www.webfreecounter.com/hit.php?id=gfpapx&nd=7&style=2" border="0" alt="statworker.com"></a>
<!-- End of WebFreeCounter Code -->
</span>
<span><a href="https://statcounter.com/p12408441/?guest=1" target="_blank"> ]</a></span>


      </div>
    </div>
  </div>
</footer></div></div>
    </div><script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $body = $('body'), $window = $(window);
    var $pageRoot = $('.js-page-root'), $pageMain = $('.js-page-main');
    var activeCount = 0;
    function modal(options) {
      var $root = this, visible, onChange, hideWhenWindowScroll = false;
      var scrollTop;
      function setOptions(options) {
        var _options = options || {};
        visible = _options.initialVisible === undefined ? false : show;
        onChange = _options.onChange;
        hideWhenWindowScroll = _options.hideWhenWindowScroll;
      }
      function init() {
        setState(visible);
      }
      function setState(isShow) {
        if (isShow === visible) {
          return;
        }
        visible = isShow;
        if (visible) {
          activeCount++;
          scrollTop = $(window).scrollTop() || $pageMain.scrollTop();
          $root.addClass('modal--show');
          $pageMain.scrollTop(scrollTop);
          activeCount === 1 && ($pageRoot.addClass('show-modal'), $body.addClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.on('scroll', hide);
          $window.on('keyup', handleKeyup);
        } else {
          activeCount > 0 && activeCount--;
          $root.removeClass('modal--show');
          $window.scrollTop(scrollTop);
          activeCount === 0 && ($pageRoot.removeClass('show-modal'), $body.removeClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.off('scroll', hide);
          $window.off('keyup', handleKeyup);
        }
        onChange && onChange(visible);
      }
      function show() {
        setState(true);
      }
      function hide() {
        setState(false);
      }
      function handleKeyup(e) {
        // Char Code: 27  ESC
        if (e.which ===  27) {
          hide();
        }
      }
      setOptions(options);
      init();
      return {
        show: show,
        hide: hide,
        $el: $root
      };
    }
    $.fn.modal = modal;
  });
})();
</script><div class="modal modal--overflow page__search-modal d-print-none js-page-search-modal"><script>
(function () {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    // search panel
    var search = (window.search || (window.search = {}));
    var useDefaultSearchBox = window.useDefaultSearchBox === undefined ?
      true : window.useDefaultSearchBox ;

    var $searchModal = $('.js-page-search-modal');
    var $searchToggle = $('.js-search-toggle');
    var searchModal = $searchModal.modal({ onChange: handleModalChange, hideWhenWindowScroll: true });
    var modalVisible = false;
    search.searchModal = searchModal;

    var $searchBox = null;
    var $searchInput = null;
    var $searchClear = null;

    function getModalVisible() {
      return modalVisible;
    }
    search.getModalVisible = getModalVisible;

    function handleModalChange(visible) {
      modalVisible = visible;
      if (visible) {
        search.onShow && search.onShow();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].focus();
      } else {
        search.onShow && search.onHide();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].blur();
        setTimeout(function() {
          useDefaultSearchBox && ($searchInput.val(''), $searchBox.removeClass('not-empty'));
          search.clear && search.clear();
          window.pageAsideAffix && window.pageAsideAffix.refresh();
        }, 400);
      }
    }

    $searchToggle.on('click', function() {
      modalVisible ? searchModal.hide() : searchModal.show();
    });
    // Char Code: 83  S, 191 /
    $(window).on('keyup', function(e) {
      if (!modalVisible && !window.isFormElement(e.target || e.srcElement) && (e.which === 83 || e.which === 191)) {
        modalVisible || searchModal.show();
      }
    });

    if (useDefaultSearchBox) {
      $searchBox = $('.js-search-box');
      $searchInput = $searchBox.children('input');
      $searchClear = $searchBox.children('.js-icon-clear');
      search.getSearchInput = function() {
        return $searchInput.get(0);
      };
      search.getVal = function() {
        return $searchInput.val();
      };
      search.setVal = function(val) {
        $searchInput.val(val);
      };

      $searchInput.on('focus', function() {
        $(this).addClass('focus');
      });
      $searchInput.on('blur', function() {
        $(this).removeClass('focus');
      });
      $searchInput.on('input', window.throttle(function() {
        var val = $(this).val();
        if (val === '' || typeof val !== 'string') {
          search.clear && search.clear();
        } else {
          $searchBox.addClass('not-empty');
          search.onInputNotEmpty && search.onInputNotEmpty(val);
        }
      }, 400));
      $searchClear.on('click', function() {
        $searchInput.val(''); $searchBox.removeClass('not-empty');
        search.clear && search.clear();
      });
    }
  });
})();
</script><div class="search search--dark">
  <div class="main">
    <div class="search__header">Search</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--theme-dark button--pill search__cancel js-search-toggle">
        Cancel</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>
<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var search = (window.search || (window.search = {}));
  var searchData = window.TEXT_SEARCH_DATA || {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) { return null; }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function clear() {
    $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }
  function onInputNotEmpty(val) {
    $result.html(render(searchByQuery(val)));
    $resultItems = $('.search-result__item'); activeIndex = 0;
    $resultItems.eq(0).addClass('active');
  }

  search.clear = clear;
  search.onInputNotEmpty = onInputNotEmpty;

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  // Char Code: 13  Enter, 37  ⬅, 38  ⬆, 39  ➡, 40  ⬇
  $(window).on('keyup', function(e) {
    var modalVisible = search.getModalVisible && search.getModalVisible();
    if (modalVisible) {
      if (e.which === 38) {
        modalVisible && moveActiveIndex('up');
      } else if (e.which === 40) {
        modalVisible && moveActiveIndex('down');
      } else if (e.which === 13) {
        modalVisible && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });
});
</script></div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function affix(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroll,
        offsetBottom = 0, scrollTarget = window, scroll = window.document, disabled = false, isOverallScroller = true,
        rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop,
        hasInit = false, curState;

      function setOptions(options) {
        var _options = options || {};
        _options.offsetBottom && (offsetBottom = _options.offsetBottom);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroll && (scroll = _options.scroll);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $scrollTarget = $(scrollTarget);
        isOverallScroller = window.isOverallScroller($scrollTarget[0]);
        $scroll = $(scroll);
      }
      function preCalc() {
        top();
        rootHeight = $root.outerHeight();
        rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
        rootLeft = $root.offset().left;
      }
      function calc(needPreCalc) {
        needPreCalc && preCalc();
        scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
        rootBottomTop = scrollBottom - rootTop;
      }
      function top() {
        if (curState !== 'top') {
          $root.removeClass('fixed').css({
            left: 0,
            top: 0
          });
          curState = 'top';
        }
      }
      function fixed() {
        if (curState !== 'fixed') {
          $root.addClass('fixed').css({
            left: rootLeft + 'px',
            top: 0
          });
          curState = 'fixed';
        }
      }
      function bottom() {
        if (curState !== 'bottom') {
          $root.removeClass('fixed').css({
            left: 0,
            top: rootBottomTop + 'px'
          });
          curState = 'bottom';
        }
      }
      function setState() {
        var scrollTop = $scrollTarget.scrollTop();
        if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
          fixed();
        } else if (scrollTop < rootTop) {
          top();
        } else {
          bottom();
        }
      }
      function init() {
        if(!hasInit) {
          var interval, timeout;
          calc(true); setState();
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState();
          });
          $window.on('resize', function() {
            disabled || (calc(true), setState());
          });
          hasInit = true;
        }
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true, { animation: false }); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function toc(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroller, $tocUl = $('<ul class="toc toc--ellipsis"></ul>'), $tocLi, $headings, $activeLast, $activeCur,
        selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false,
        headingsPos, scrolling = false, hasRendered = false, hasInit = false;

      function setOptions(options) {
        var _options = options || {};
        _options.selectors && (selectors = _options.selectors);
        _options.container && (container = _options.container);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroller && (scroller = _options.scroller);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $headings = $(container).find(selectors).filter('[id]');
        $scrollTarget = $(scrollTarget);
        $scroller = $(scroller);
      }
      function calc() {
        headingsPos = [];
        $headings.each(function() {
          headingsPos.push(Math.floor($(this).position().top));
        });
      }
      function setState(element, disabled) {
        var scrollTop = $scrollTarget.scrollTop(), i;
        if (disabled || !headingsPos || headingsPos.length < 1) { return; }
        if (element) {
          $activeCur = element;
        } else {
          for (i = 0; i < headingsPos.length; i++) {
            if (scrollTop >= headingsPos[i]) {
              $activeCur = $tocLi.eq(i);
            } else {
              $activeCur || ($activeCur = $tocLi.eq(i));
              break;
            }
          }
        }
        $activeLast && $activeLast.removeClass('active');
        ($activeLast = $activeCur).addClass('active');
      }
      function render() {
        if(!hasRendered) {
          $root.append($tocUl);
          $headings.each(function() {
            var $this = $(this);
            $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
              .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
          });
          $tocLi = $tocUl.children('li');
          $tocUl.on('click', 'a', function(e) {
            e.preventDefault();
            var $this = $(this);
            scrolling = true;
            setState($this.parent());
            $scroller.scrollToAnchor($this.attr('href'), 400, function() {
              scrolling = false;
            });
          });
        }
        hasRendered = true;
      }
      function init() {
        var interval, timeout;
        if(!hasInit) {
          render(); calc(); setState(null, scrolling);
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState(null, scrolling);
          });
          $window.on('resize', window.throttle(function() {
            if (!disabled) {
              render(); calc(); setState(null, scrolling);
            }
          }, 100));
        }
        hasInit = true;
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();
/*(function () {

})();*/
</script><script>
  /* toc must before affix, since affix need to konw toc' height. */(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  var TOC_SELECTOR = window.TEXT_VARIABLES.site.toc.selectors;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window);
    var $articleContent = $('.js-article-content');
    var $tocRoot = $('.js-toc-root'), $col2 = $('.js-col-aside');
    var toc;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
    var hasToc = $articleContent.find(TOC_SELECTOR).length > 0;

    function disabled() {
      return $col2.css('display') === 'none' || !hasToc;
    }

    tocDisabled = disabled();

    toc = $tocRoot.toc({
      selectors: TOC_SELECTOR,
      container: $articleContent,
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      tocDisabled = disabled();
      toc && toc.setOptions({
        disabled: tocDisabled
      });
    }, 100));

  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $pageFooter = $('.js-page-footer');
    var $pageAside = $('.js-page-aside');
    var affix;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');

    affix = $pageAside.affix({
      offsetBottom: $pageFooter.outerHeight(),
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      scroll: hasSidebar ? $('.js-page-main').children() : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      affix && affix.setOptions({
        disabled: tocDisabled
      });
    }, 100));

    window.pageAsideAffix = affix;
  });
})();
</script>
    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();
</script>
  </body>
</html>